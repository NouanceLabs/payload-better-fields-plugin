"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dataloader@2.2.3";
exports.ids = ["vendor-chunks/dataloader@2.2.3"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/dataloader@2.2.3/node_modules/dataloader/index.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/.pnpm/dataloader@2.2.3/node_modules/dataloader/index.js ***!
  \*******************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */\n  ;\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise;\n\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\n  } // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var _value = values[i];\n\n      if (_value instanceof Error) {\n        batch.callbacks[i].reject(_value);\n      } else {\n        batch.callbacks[i].resolve(_value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n}\n\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n\n  return null;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RhdGFsb2FkZXJAMi4yLjMvbm9kZV9tb2R1bGVzL2RhdGFsb2FkZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7OztBQUc1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQSx5Q0FBeUM7QUFDekMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxHQUFHOztBQUVILHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTiw2QkFBNkI7O0FBRTdCLG9CQUFvQiw0QkFBNEI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL2RhdGFsb2FkZXJAMi4yLjMvbm9kZV9tb2R1bGVzL2RhdGFsb2FkZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQsIEdyYXBoUUwgRm91bmRhdGlvblxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBBIEZ1bmN0aW9uLCB3aGljaCB3aGVuIGdpdmVuIGFuIEFycmF5IG9mIGtleXMsIHJldHVybnMgYSBQcm9taXNlIG9mIGFuIEFycmF5XG4vLyBvZiB2YWx1ZXMgb3IgRXJyb3JzLlxuLy8gT3B0aW9uYWxseSB0dXJuIG9mZiBiYXRjaGluZyBvciBjYWNoaW5nIG9yIHByb3ZpZGUgYSBjYWNoZSBrZXkgZnVuY3Rpb24gb3IgYVxuLy8gY3VzdG9tIGNhY2hlIGluc3RhbmNlLlxuLy8gSWYgYSBjdXN0b20gY2FjaGUgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgb2YgdGhpcyB0eXBlIChhIHN1YnNldCBvZiBFUzYgTWFwKS5cblxuLyoqXG4gKiBBIGBEYXRhTG9hZGVyYCBjcmVhdGVzIGEgcHVibGljIEFQSSBmb3IgbG9hZGluZyBkYXRhIGZyb20gYSBwYXJ0aWN1bGFyXG4gKiBkYXRhIGJhY2stZW5kIHdpdGggdW5pcXVlIGtleXMgc3VjaCBhcyB0aGUgYGlkYCBjb2x1bW4gb2YgYSBTUUwgdGFibGUgb3JcbiAqIGRvY3VtZW50IG5hbWUgaW4gYSBNb25nb0RCIGRhdGFiYXNlLCBnaXZlbiBhIGJhdGNoIGxvYWRpbmcgZnVuY3Rpb24uXG4gKlxuICogRWFjaCBgRGF0YUxvYWRlcmAgaW5zdGFuY2UgY29udGFpbnMgYSB1bmlxdWUgbWVtb2l6ZWQgY2FjaGUuIFVzZSBjYXV0aW9uIHdoZW5cbiAqIHVzZWQgaW4gbG9uZy1saXZlZCBhcHBsaWNhdGlvbnMgb3IgdGhvc2Ugd2hpY2ggc2VydmUgbWFueSB1c2VycyB3aXRoXG4gKiBkaWZmZXJlbnQgYWNjZXNzIHBlcm1pc3Npb25zIGFuZCBjb25zaWRlciBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZSBwZXJcbiAqIHdlYiByZXF1ZXN0LlxuICovXG52YXIgRGF0YUxvYWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFMb2FkZXIoYmF0Y2hMb2FkRm4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGJhdGNoTG9hZEZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhTG9hZGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgJyArIChcIkFycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgZ290OiBcIiArIGJhdGNoTG9hZEZuICsgXCIuXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYXRjaExvYWRGbiA9IGJhdGNoTG9hZEZuO1xuICAgIHRoaXMuX21heEJhdGNoU2l6ZSA9IGdldFZhbGlkTWF4QmF0Y2hTaXplKG9wdGlvbnMpO1xuICAgIHRoaXMuX2JhdGNoU2NoZWR1bGVGbiA9IGdldFZhbGlkQmF0Y2hTY2hlZHVsZUZuKG9wdGlvbnMpO1xuICAgIHRoaXMuX2NhY2hlS2V5Rm4gPSBnZXRWYWxpZENhY2hlS2V5Rm4ob3B0aW9ucyk7XG4gICAgdGhpcy5fY2FjaGVNYXAgPSBnZXRWYWxpZENhY2hlTWFwKG9wdGlvbnMpO1xuICAgIHRoaXMuX2JhdGNoID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBnZXRWYWxpZE5hbWUob3B0aW9ucyk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgdmFyIF9wcm90byA9IERhdGFMb2FkZXIucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGtleSwgcmV0dXJuaW5nIGEgYFByb21pc2VgIGZvciB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhhdCBrZXkuXG4gICAqL1xuICBfcHJvdG8ubG9hZCA9IGZ1bmN0aW9uIGxvYWQoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxvYWRlci5sb2FkKCkgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHZhbHVlLCAnICsgKFwiYnV0IGdvdDogXCIgKyBTdHJpbmcoa2V5KSArIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGJhdGNoID0gZ2V0Q3VycmVudEJhdGNoKHRoaXMpO1xuICAgIHZhciBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwO1xuICAgIHZhciBjYWNoZUtleTsgLy8gSWYgY2FjaGluZyBhbmQgdGhlcmUgaXMgYSBjYWNoZS1oaXQsIHJldHVybiBjYWNoZWQgUHJvbWlzZS5cblxuICAgIGlmIChjYWNoZU1hcCkge1xuICAgICAgY2FjaGVLZXkgPSB0aGlzLl9jYWNoZUtleUZuKGtleSk7XG4gICAgICB2YXIgY2FjaGVkUHJvbWlzZSA9IGNhY2hlTWFwLmdldChjYWNoZUtleSk7XG5cbiAgICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICAgIHZhciBjYWNoZUhpdHMgPSBiYXRjaC5jYWNoZUhpdHMgfHwgKGJhdGNoLmNhY2hlSGl0cyA9IFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgY2FjaGVIaXRzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWRQcm9taXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBuZXcgUHJvbWlzZSBmb3IgdGhpcyBrZXksIGFuZCBlbnF1ZXVlIGl0IHRvIGJlXG4gICAgLy8gZGlzcGF0Y2hlZCBhbG9uZyB3aXRoIHRoZSBjdXJyZW50IGJhdGNoLlxuXG5cbiAgICBiYXRjaC5rZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGJhdGNoLmNhbGxiYWNrcy5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBJZiBjYWNoaW5nLCBjYWNoZSB0aGlzIHByb21pc2UuXG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIGNhY2hlTWFwLnNldChjYWNoZUtleSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG11bHRpcGxlIGtleXMsIHByb21pc2luZyBhbiBhcnJheSBvZiB2YWx1ZXM6XG4gICAqXG4gICAqICAgICB2YXIgWyBhLCBiIF0gPSBhd2FpdCBteUxvYWRlci5sb2FkTWFueShbICdhJywgJ2InIF0pO1xuICAgKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIG1vcmUgdmVyYm9zZTpcbiAgICpcbiAgICogICAgIHZhciBbIGEsIGIgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICogICAgICAgbXlMb2FkZXIubG9hZCgnYScpLFxuICAgKiAgICAgICBteUxvYWRlci5sb2FkKCdiJylcbiAgICogICAgIF0pO1xuICAgKlxuICAgKiBIb3dldmVyIGl0IGlzIGRpZmZlcmVudCBpbiB0aGUgY2FzZSB3aGVyZSBhbnkgbG9hZCBmYWlscy4gV2hlcmVcbiAgICogUHJvbWlzZS5hbGwoKSB3b3VsZCByZWplY3QsIGxvYWRNYW55KCkgYWx3YXlzIHJlc29sdmVzLCBob3dldmVyIGVhY2ggcmVzdWx0XG4gICAqIGlzIGVpdGhlciBhIHZhbHVlIG9yIGFuIEVycm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAgICAgdmFyIFsgYSwgYiwgYyBdID0gYXdhaXQgbXlMb2FkZXIubG9hZE1hbnkoWyAnYScsICdiJywgJ2JhZGtleScgXSk7XG4gICAqICAgICAvLyBjIGluc3RhbmNlb2YgRXJyb3JcbiAgICpcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubG9hZE1hbnkgPSBmdW5jdGlvbiBsb2FkTWFueShrZXlzKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShrZXlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxvYWRlci5sb2FkTWFueSgpIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggQXJyYXk8a2V5PiAnICsgKFwiYnV0IGdvdDogXCIgKyBrZXlzICsgXCIuXCIpKTtcbiAgICB9IC8vIFN1cHBvcnQgQXJyYXlMaWtlIGJ5IHVzaW5nIG9ubHkgbWluaW1hbCBwcm9wZXJ0eSBhY2Nlc3NcblxuXG4gICAgdmFyIGxvYWRQcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2FkUHJvbWlzZXMucHVzaCh0aGlzLmxvYWQoa2V5c1tpXSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkUHJvbWlzZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHZhbHVlIGF0IGBrZXlgIGZyb20gdGhlIGNhY2hlLCBpZiBpdCBleGlzdHMuIFJldHVybnMgaXRzZWxmIGZvclxuICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoa2V5KSB7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMuX2NhY2hlS2V5Rm4oa2V5KTtcblxuICAgICAgY2FjaGVNYXBbXCJkZWxldGVcIl0oY2FjaGVLZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGVudGlyZSBjYWNoZS4gVG8gYmUgdXNlZCB3aGVuIHNvbWUgZXZlbnQgcmVzdWx0cyBpbiB1bmtub3duXG4gICAqIGludmFsaWRhdGlvbnMgYWNyb3NzIHRoaXMgcGFydGljdWxhciBgRGF0YUxvYWRlcmAuIFJldHVybnMgaXRzZWxmIGZvclxuICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyQWxsID0gZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIGNhY2hlTWFwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHByb3ZpZGVkIGtleSBhbmQgdmFsdWUgdG8gdGhlIGNhY2hlLiBJZiB0aGUga2V5IGFscmVhZHlcbiAgICogZXhpc3RzLCBubyBjaGFuZ2UgaXMgbWFkZS4gUmV0dXJucyBpdHNlbGYgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICpcbiAgICogVG8gcHJpbWUgdGhlIGNhY2hlIHdpdGggYW4gZXJyb3IgYXQgYSBrZXksIHByb3ZpZGUgYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByaW1lID0gZnVuY3Rpb24gcHJpbWUoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwO1xuXG4gICAgaWYgKGNhY2hlTWFwKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLl9jYWNoZUtleUZuKGtleSk7IC8vIE9ubHkgYWRkIHRoZSBrZXkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cblxuXG4gICAgICBpZiAoY2FjaGVNYXAuZ2V0KGNhY2hlS2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENhY2hlIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiB0aGUgdmFsdWUgaXMgYW4gRXJyb3IsIGluIG9yZGVyIHRvIG1hdGNoXG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciBvZiBsb2FkKGtleSkuXG4gICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KHZhbHVlKTsgLy8gU2luY2UgdGhpcyBpcyBhIGNhc2Ugd2hlcmUgYW4gRXJyb3IgaXMgaW50ZW50aW9uYWxseSBiZWluZyBwcmltZWRcbiAgICAgICAgICAvLyBmb3IgYSBnaXZlbiBrZXksIHdlIHdhbnQgdG8gZGlzYWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVNYXAuc2V0KGNhY2hlS2V5LCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIG5hbWUgZ2l2ZW4gdG8gdGhpcyBgRGF0YUxvYWRlcmAgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgQVBNIHRvb2xzLlxuICAgKlxuICAgKiBJcyBgbnVsbGAgaWYgbm90IHNldCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICA7XG5cbiAgcmV0dXJuIERhdGFMb2FkZXI7XG59KCk7IC8vIFByaXZhdGU6IEVucXVldWUgYSBKb2IgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIFwiUHJvbWlzZUpvYnNcIiBKb2JzLlxuLy9cbi8vIEVTNiBKYXZhU2NyaXB0IHVzZXMgdGhlIGNvbmNlcHRzIEpvYiBhbmQgSm9iUXVldWUgdG8gc2NoZWR1bGUgd29yayB0byBvY2N1clxuLy8gYWZ0ZXIgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgaGFzIGNvbXBsZXRlZDpcbi8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1qb2JzLWFuZC1qb2ItcXVldWVzXG4vL1xuLy8gTm9kZS5qcyB1c2VzIHRoZSBgcHJvY2Vzcy5uZXh0VGlja2AgbWVjaGFuaXNtIHRvIGltcGxlbWVudCB0aGUgY29uY2VwdCBvZiBhXG4vLyBKb2IsIG1haW50YWluaW5nIGEgZ2xvYmFsIEZJRk8gSm9iUXVldWUgZm9yIGFsbCBKb2JzLCB3aGljaCBpcyBmbHVzaGVkIGFmdGVyXG4vLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGVuZHMuXG4vL1xuLy8gV2hlbiBjYWxsaW5nIGB0aGVuYCBvbiBhIFByb21pc2UsIGl0IGVucXVldWVzIGEgSm9iIG9uIGEgc3BlY2lmaWNcbi8vIFwiUHJvbWlzZUpvYnNcIiBKb2JRdWV1ZSB3aGljaCBpcyBmbHVzaGVkIGluIE5vZGUgYXMgYSBzaW5nbGUgSm9iIG9uIHRoZVxuLy8gZ2xvYmFsIEpvYlF1ZXVlLlxuLy9cbi8vIERhdGFMb2FkZXIgYmF0Y2hlcyBhbGwgbG9hZHMgd2hpY2ggb2NjdXIgaW4gYSBzaW5nbGUgZnJhbWUgb2YgZXhlY3V0aW9uLCBidXRcbi8vIHNob3VsZCBpbmNsdWRlIGluIHRoZSBiYXRjaCBhbGwgbG9hZHMgd2hpY2ggb2NjdXIgZHVyaW5nIHRoZSBmbHVzaGluZyBvZiB0aGVcbi8vIFwiUHJvbWlzZUpvYnNcIiBKb2JRdWV1ZSBhZnRlciB0aGF0IHNhbWUgZXhlY3V0aW9uIGZyYW1lLlxuLy9cbi8vIEluIG9yZGVyIHRvIGF2b2lkIHRoZSBEYXRhTG9hZGVyIGRpc3BhdGNoIEpvYiBvY2N1cmluZyBiZWZvcmUgXCJQcm9taXNlSm9ic1wiLFxuLy8gQSBQcm9taXNlIEpvYiBpcyBjcmVhdGVkIHdpdGggdGhlIHNvbGUgcHVycG9zZSBvZiBlbnF1ZXVpbmcgYSBnbG9iYWwgSm9iLFxuLy8gZW5zdXJpbmcgdGhhdCBpdCBhbHdheXMgb2NjdXJzIGFmdGVyIFwiUHJvbWlzZUpvYnNcIiBlbmRzLlxuLy9cbi8vIE5vZGUuanMncyBqb2IgcXVldWUgaXMgdW5pcXVlLiBCcm93c2VycyBkbyBub3QgaGF2ZSBhbiBlcXVpdmFsZW50IG1lY2hhbmlzbVxuLy8gZm9yIGVucXVldWluZyBhIGpvYiB0byBiZSBwZXJmb3JtZWQgYWZ0ZXIgcHJvbWlzZSBtaWNyb3Rhc2tzIGFuZCBiZWZvcmUgdGhlXG4vLyBuZXh0IG1hY3JvdGFzay4gRm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzLCBhIG1hY3JvdGFzayBpcyB1c2VkICh2aWFcbi8vIHNldEltbWVkaWF0ZSBvciBzZXRUaW1lb3V0KSBhdCBhIHBvdGVudGlhbCBwZXJmb3JtYW5jZSBwZW5hbHR5LlxuXG5cbnZhciBlbnF1ZXVlUG9zdFByb21pc2VKb2IgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgfSk7XG59IDogdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIChmbikge1xuICBzZXRJbW1lZGlhdGUoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICBzZXRUaW1lb3V0KGZuKTtcbn07IC8vIFByaXZhdGU6IGNhY2hlZCByZXNvbHZlZCBQcm9taXNlIGluc3RhbmNlXG5cbnZhciByZXNvbHZlZFByb21pc2U7IC8vIFByaXZhdGU6IERlc2NyaWJlcyBhIGJhdGNoIG9mIHJlcXVlc3RzXG5cbi8vIFByaXZhdGU6IEVpdGhlciByZXR1cm5zIHRoZSBjdXJyZW50IGJhdGNoLCBvciBjcmVhdGVzIGFuZCBzY2hlZHVsZXMgYVxuLy8gZGlzcGF0Y2ggb2YgYSBuZXcgYmF0Y2ggZm9yIHRoZSBnaXZlbiBsb2FkZXIuXG5mdW5jdGlvbiBnZXRDdXJyZW50QmF0Y2gobG9hZGVyKSB7XG4gIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGJhdGNoIHdoaWNoIGhhcyBub3QgeWV0IGRpc3BhdGNoZWQgYW5kIGlzIHdpdGhpblxuICAvLyB0aGUgbGltaXQgb2YgdGhlIGJhdGNoIHNpemUsIHRoZW4gcmV0dXJuIGl0LlxuICB2YXIgZXhpc3RpbmdCYXRjaCA9IGxvYWRlci5fYmF0Y2g7XG5cbiAgaWYgKGV4aXN0aW5nQmF0Y2ggIT09IG51bGwgJiYgIWV4aXN0aW5nQmF0Y2guaGFzRGlzcGF0Y2hlZCAmJiBleGlzdGluZ0JhdGNoLmtleXMubGVuZ3RoIDwgbG9hZGVyLl9tYXhCYXRjaFNpemUpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdCYXRjaDtcbiAgfSAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBiYXRjaCBmb3IgdGhpcyBsb2FkZXIuXG5cblxuICB2YXIgbmV3QmF0Y2ggPSB7XG4gICAgaGFzRGlzcGF0Y2hlZDogZmFsc2UsXG4gICAga2V5czogW10sXG4gICAgY2FsbGJhY2tzOiBbXVxuICB9OyAvLyBTdG9yZSBpdCBvbiB0aGUgbG9hZGVyIHNvIGl0IG1heSBiZSByZXVzZWQuXG5cbiAgbG9hZGVyLl9iYXRjaCA9IG5ld0JhdGNoOyAvLyBUaGVuIHNjaGVkdWxlIGEgdGFzayB0byBkaXNwYXRjaCB0aGlzIGJhdGNoIG9mIHJlcXVlc3RzLlxuXG4gIGxvYWRlci5fYmF0Y2hTY2hlZHVsZUZuKGZ1bmN0aW9uICgpIHtcbiAgICBkaXNwYXRjaEJhdGNoKGxvYWRlciwgbmV3QmF0Y2gpO1xuICB9KTtcblxuICByZXR1cm4gbmV3QmF0Y2g7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQmF0Y2gobG9hZGVyLCBiYXRjaCkge1xuICAvLyBNYXJrIHRoaXMgYmF0Y2ggYXMgaGF2aW5nIGJlZW4gZGlzcGF0Y2hlZC5cbiAgYmF0Y2guaGFzRGlzcGF0Y2hlZCA9IHRydWU7IC8vIElmIHRoZXJlJ3Mgbm90aGluZyB0byBsb2FkLCByZXNvbHZlIGFueSBjYWNoZSBoaXRzIGFuZCByZXR1cm4gZWFybHkuXG5cbiAgaWYgKGJhdGNoLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmVzb2x2ZUNhY2hlSGl0cyhiYXRjaCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIENhbGwgdGhlIHByb3ZpZGVkIGJhdGNoTG9hZEZuIGZvciB0aGlzIGxvYWRlciB3aXRoIHRoZSBiYXRjaCdzIGtleXMgYW5kXG4gIC8vIHdpdGggdGhlIGxvYWRlciBhcyB0aGUgYHRoaXNgIGNvbnRleHQuXG5cblxuICB2YXIgYmF0Y2hQcm9taXNlO1xuXG4gIHRyeSB7XG4gICAgYmF0Y2hQcm9taXNlID0gbG9hZGVyLl9iYXRjaExvYWRGbihiYXRjaC5rZXlzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWlsZWREaXNwYXRjaChsb2FkZXIsIGJhdGNoLCBuZXcgVHlwZUVycm9yKCdEYXRhTG9hZGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgJyArICdBcnJheTxrZXk+IGFuZCByZXR1cm5zIFByb21pc2U8QXJyYXk8dmFsdWU+PiwgYnV0IHRoZSBmdW5jdGlvbiAnICsgKFwiZXJyb3JlZCBzeW5jaHJvbm91c2x5OiBcIiArIFN0cmluZyhlKSArIFwiLlwiKSkpO1xuICB9IC8vIEFzc2VydCB0aGUgZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBiYXRjaExvYWRGblxuXG5cbiAgaWYgKCFiYXRjaFByb21pc2UgfHwgdHlwZW9mIGJhdGNoUHJvbWlzZS50aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhaWxlZERpc3BhdGNoKGxvYWRlciwgYmF0Y2gsIG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgJ0FycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgdGhlIGZ1bmN0aW9uIGRpZCAnICsgKFwibm90IHJldHVybiBhIFByb21pc2U6IFwiICsgU3RyaW5nKGJhdGNoUHJvbWlzZSkgKyBcIi5cIikpKTtcbiAgfSAvLyBBd2FpdCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FsbCB0byBiYXRjaExvYWRGbi5cblxuXG4gIGJhdGNoUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAvLyBBc3NlcnQgdGhlIGV4cGVjdGVkIHJlc29sdXRpb24gZnJvbSBiYXRjaExvYWRGbi5cbiAgICBpZiAoIWlzQXJyYXlMaWtlKHZhbHVlcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgJ0FycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgdGhlIGZ1bmN0aW9uIGRpZCAnICsgKFwibm90IHJldHVybiBhIFByb21pc2Ugb2YgYW4gQXJyYXk6IFwiICsgU3RyaW5nKHZhbHVlcykgKyBcIi5cIikpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBiYXRjaC5rZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YUxvYWRlciBtdXN0IGJlIGNvbnN0cnVjdGVkIHdpdGggYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzICcgKyAnQXJyYXk8a2V5PiBhbmQgcmV0dXJucyBQcm9taXNlPEFycmF5PHZhbHVlPj4sIGJ1dCB0aGUgZnVuY3Rpb24gZGlkICcgKyAnbm90IHJldHVybiBhIFByb21pc2Ugb2YgYW4gQXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBBcnJheSAnICsgJ29mIGtleXMuJyArIChcIlxcblxcbktleXM6XFxuXCIgKyBTdHJpbmcoYmF0Y2gua2V5cykpICsgKFwiXFxuXFxuVmFsdWVzOlxcblwiICsgU3RyaW5nKHZhbHVlcykpKTtcbiAgICB9IC8vIFJlc29sdmUgYWxsIGNhY2hlIGhpdHMgaW4gdGhlIHNhbWUgbWljcm8tdGFzayBhcyBmcmVzaGx5IGxvYWRlZCB2YWx1ZXMuXG5cblxuICAgIHJlc29sdmVDYWNoZUhpdHMoYmF0Y2gpOyAvLyBTdGVwIHRocm91Z2ggdmFsdWVzLCByZXNvbHZpbmcgb3IgcmVqZWN0aW5nIGVhY2ggUHJvbWlzZSBpbiB0aGUgYmF0Y2guXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF92YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGJhdGNoLmNhbGxiYWNrc1tpXS5yZWplY3QoX3ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoLmNhbGxiYWNrc1tpXS5yZXNvbHZlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGZhaWxlZERpc3BhdGNoKGxvYWRlciwgYmF0Y2gsIGVycm9yKTtcbiAgfSk7XG59IC8vIFByaXZhdGU6IGRvIG5vdCBjYWNoZSBpbmRpdmlkdWFsIGxvYWRzIGlmIHRoZSBlbnRpcmUgYmF0Y2ggZGlzcGF0Y2ggZmFpbHMsXG4vLyBidXQgc3RpbGwgcmVqZWN0IGVhY2ggcmVxdWVzdCBzbyB0aGV5IGRvIG5vdCBoYW5nLlxuXG5cbmZ1bmN0aW9uIGZhaWxlZERpc3BhdGNoKGxvYWRlciwgYmF0Y2gsIGVycm9yKSB7XG4gIC8vIENhY2hlIGhpdHMgYXJlIHJlc29sdmVkLCBldmVuIHRob3VnaCB0aGUgYmF0Y2ggZmFpbGVkLlxuICByZXNvbHZlQ2FjaGVIaXRzKGJhdGNoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBsb2FkZXIuY2xlYXIoYmF0Y2gua2V5c1tpXSk7XG4gICAgYmF0Y2guY2FsbGJhY2tzW2ldLnJlamVjdChlcnJvcik7XG4gIH1cbn0gLy8gUHJpdmF0ZTogUmVzb2x2ZXMgdGhlIFByb21pc2VzIGZvciBhbnkgY2FjaGUgaGl0cyBpbiB0aGlzIGJhdGNoLlxuXG5cbmZ1bmN0aW9uIHJlc29sdmVDYWNoZUhpdHMoYmF0Y2gpIHtcbiAgaWYgKGJhdGNoLmNhY2hlSGl0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2guY2FjaGVIaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXRjaC5jYWNoZUhpdHNbaV0oKTtcbiAgICB9XG4gIH1cbn0gLy8gUHJpdmF0ZTogZ2l2ZW4gdGhlIERhdGFMb2FkZXIncyBvcHRpb25zLCBwcm9kdWNlIGEgdmFsaWQgbWF4IGJhdGNoIHNpemUuXG5cblxuZnVuY3Rpb24gZ2V0VmFsaWRNYXhCYXRjaFNpemUob3B0aW9ucykge1xuICB2YXIgc2hvdWxkQmF0Y2ggPSAhb3B0aW9ucyB8fCBvcHRpb25zLmJhdGNoICE9PSBmYWxzZTtcblxuICBpZiAoIXNob3VsZEJhdGNoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgbWF4QmF0Y2hTaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1heEJhdGNoU2l6ZTtcblxuICBpZiAobWF4QmF0Y2hTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1heEJhdGNoU2l6ZSAhPT0gJ251bWJlcicgfHwgbWF4QmF0Y2hTaXplIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXhCYXRjaFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcjogXCIgKyBtYXhCYXRjaFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIG1heEJhdGNoU2l6ZTtcbn0gLy8gUHJpdmF0ZVxuXG5cbmZ1bmN0aW9uIGdldFZhbGlkQmF0Y2hTY2hlZHVsZUZuKG9wdGlvbnMpIHtcbiAgdmFyIGJhdGNoU2NoZWR1bGVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5iYXRjaFNjaGVkdWxlRm47XG5cbiAgaWYgKGJhdGNoU2NoZWR1bGVGbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVucXVldWVQb3N0UHJvbWlzZUpvYjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmF0Y2hTY2hlZHVsZUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImJhdGNoU2NoZWR1bGVGbiBtdXN0IGJlIGEgZnVuY3Rpb246IFwiICsgYmF0Y2hTY2hlZHVsZUZuKTtcbiAgfVxuXG4gIHJldHVybiBiYXRjaFNjaGVkdWxlRm47XG59IC8vIFByaXZhdGU6IGdpdmVuIHRoZSBEYXRhTG9hZGVyJ3Mgb3B0aW9ucywgcHJvZHVjZSBhIGNhY2hlIGtleSBmdW5jdGlvbi5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZENhY2hlS2V5Rm4ob3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXlGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZUtleUZuO1xuXG4gIGlmIChjYWNoZUtleUZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWNoZUtleUZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhY2hlS2V5Rm4gbXVzdCBiZSBhIGZ1bmN0aW9uOiBcIiArIGNhY2hlS2V5Rm4pO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlS2V5Rm47XG59IC8vIFByaXZhdGU6IGdpdmVuIHRoZSBEYXRhTG9hZGVyJ3Mgb3B0aW9ucywgcHJvZHVjZSBhIENhY2hlTWFwIHRvIGJlIHVzZWQuXG5cblxuZnVuY3Rpb24gZ2V0VmFsaWRDYWNoZU1hcChvcHRpb25zKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFvcHRpb25zIHx8IG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlO1xuXG4gIGlmICghc2hvdWxkQ2FjaGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjYWNoZU1hcCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZU1hcDtcblxuICBpZiAoY2FjaGVNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgTWFwKCk7XG4gIH1cblxuICBpZiAoY2FjaGVNYXAgIT09IG51bGwpIHtcbiAgICB2YXIgY2FjaGVGdW5jdGlvbnMgPSBbJ2dldCcsICdzZXQnLCAnZGVsZXRlJywgJ2NsZWFyJ107XG4gICAgdmFyIG1pc3NpbmdGdW5jdGlvbnMgPSBjYWNoZUZ1bmN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgICAgcmV0dXJuIGNhY2hlTWFwICYmIHR5cGVvZiBjYWNoZU1hcFtmbk5hbWVdICE9PSAnZnVuY3Rpb24nO1xuICAgIH0pO1xuXG4gICAgaWYgKG1pc3NpbmdGdW5jdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDdXN0b20gY2FjaGVNYXAgbWlzc2luZyBtZXRob2RzOiAnICsgbWlzc2luZ0Z1bmN0aW9ucy5qb2luKCcsICcpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FjaGVNYXA7XG59XG5cbmZ1bmN0aW9uIGdldFZhbGlkTmFtZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubmFtZSkge1xuICAgIHJldHVybiBvcHRpb25zLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gUHJpdmF0ZVxuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgKHgubGVuZ3RoID09PSAwIHx8IHgubGVuZ3RoID4gMCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgeC5sZW5ndGggLSAxKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUxvYWRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/dataloader@2.2.3/node_modules/dataloader/index.js\n");

/***/ })

};
;