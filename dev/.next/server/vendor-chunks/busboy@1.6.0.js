"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/busboy@1.6.0";
exports.ids = ["vendor-chunks/busboy@1.6.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/index.js":
/*!***************************************************************************!*\
  !*** ../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { parseContentType } = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js\");\n\nfunction getInstance(cfg) {\n  const headers = cfg.headers;\n  const conType = parseContentType(headers['content-type']);\n  if (!conType)\n    throw new Error('Malformed content type');\n\n  for (const type of TYPES) {\n    const matched = type.detect(conType);\n    if (!matched)\n      continue;\n\n    const instanceCfg = {\n      limits: cfg.limits,\n      headers,\n      conType,\n      highWaterMark: undefined,\n      fileHwm: undefined,\n      defCharset: undefined,\n      defParamCharset: undefined,\n      preservePath: false,\n    };\n    if (cfg.highWaterMark)\n      instanceCfg.highWaterMark = cfg.highWaterMark;\n    if (cfg.fileHwm)\n      instanceCfg.fileHwm = cfg.fileHwm;\n    instanceCfg.defCharset = cfg.defCharset;\n    instanceCfg.defParamCharset = cfg.defParamCharset;\n    instanceCfg.preservePath = cfg.preservePath;\n    return new type(instanceCfg);\n  }\n\n  throw new Error(`Unsupported content type: ${headers['content-type']}`);\n}\n\n// Note: types are explicitly listed here for easier bundling\n// See: https://github.com/mscdex/busboy/issues/121\nconst TYPES = [\n  __webpack_require__(/*! ./types/multipart */ \"(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js\"),\n  __webpack_require__(/*! ./types/urlencoded */ \"(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js\"),\n].filter(function(typemod) { return typeof typemod.detect === 'function'; });\n\nmodule.exports = (cfg) => {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  if (typeof cfg.headers !== 'object'\n      || cfg.headers === null\n      || typeof cfg.headers['content-type'] !== 'string') {\n    throw new Error('Missing Content-Type');\n  }\n\n  return getInstance(cfg);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsNkZBQVk7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLHdCQUF3QjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFPLENBQUMsOEdBQW1CO0FBQzdCLEVBQUUsbUJBQU8sQ0FBQyxnSEFBb0I7QUFDOUIsNkJBQTZCLDhDQUE4Qzs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgcGFyc2VDb250ZW50VHlwZSB9ID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShjZmcpIHtcbiAgY29uc3QgaGVhZGVycyA9IGNmZy5oZWFkZXJzO1xuICBjb25zdCBjb25UeXBlID0gcGFyc2VDb250ZW50VHlwZShoZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XG4gIGlmICghY29uVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBjb250ZW50IHR5cGUnKTtcblxuICBmb3IgKGNvbnN0IHR5cGUgb2YgVFlQRVMpIHtcbiAgICBjb25zdCBtYXRjaGVkID0gdHlwZS5kZXRlY3QoY29uVHlwZSk7XG4gICAgaWYgKCFtYXRjaGVkKVxuICAgICAgY29udGludWU7XG5cbiAgICBjb25zdCBpbnN0YW5jZUNmZyA9IHtcbiAgICAgIGxpbWl0czogY2ZnLmxpbWl0cyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjb25UeXBlLFxuICAgICAgaGlnaFdhdGVyTWFyazogdW5kZWZpbmVkLFxuICAgICAgZmlsZUh3bTogdW5kZWZpbmVkLFxuICAgICAgZGVmQ2hhcnNldDogdW5kZWZpbmVkLFxuICAgICAgZGVmUGFyYW1DaGFyc2V0OiB1bmRlZmluZWQsXG4gICAgICBwcmVzZXJ2ZVBhdGg6IGZhbHNlLFxuICAgIH07XG4gICAgaWYgKGNmZy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgaW5zdGFuY2VDZmcuaGlnaFdhdGVyTWFyayA9IGNmZy5oaWdoV2F0ZXJNYXJrO1xuICAgIGlmIChjZmcuZmlsZUh3bSlcbiAgICAgIGluc3RhbmNlQ2ZnLmZpbGVId20gPSBjZmcuZmlsZUh3bTtcbiAgICBpbnN0YW5jZUNmZy5kZWZDaGFyc2V0ID0gY2ZnLmRlZkNoYXJzZXQ7XG4gICAgaW5zdGFuY2VDZmcuZGVmUGFyYW1DaGFyc2V0ID0gY2ZnLmRlZlBhcmFtQ2hhcnNldDtcbiAgICBpbnN0YW5jZUNmZy5wcmVzZXJ2ZVBhdGggPSBjZmcucHJlc2VydmVQYXRoO1xuICAgIHJldHVybiBuZXcgdHlwZShpbnN0YW5jZUNmZyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZTogJHtoZWFkZXJzWydjb250ZW50LXR5cGUnXX1gKTtcbn1cblxuLy8gTm90ZTogdHlwZXMgYXJlIGV4cGxpY2l0bHkgbGlzdGVkIGhlcmUgZm9yIGVhc2llciBidW5kbGluZ1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L2J1c2JveS9pc3N1ZXMvMTIxXG5jb25zdCBUWVBFUyA9IFtcbiAgcmVxdWlyZSgnLi90eXBlcy9tdWx0aXBhcnQnKSxcbiAgcmVxdWlyZSgnLi90eXBlcy91cmxlbmNvZGVkJyksXG5dLmZpbHRlcihmdW5jdGlvbih0eXBlbW9kKSB7IHJldHVybiB0eXBlb2YgdHlwZW1vZC5kZXRlY3QgPT09ICdmdW5jdGlvbic7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjZmcpID0+IHtcbiAgaWYgKHR5cGVvZiBjZmcgIT09ICdvYmplY3QnIHx8IGNmZyA9PT0gbnVsbClcbiAgICBjZmcgPSB7fTtcblxuICBpZiAodHlwZW9mIGNmZy5oZWFkZXJzICE9PSAnb2JqZWN0J1xuICAgICAgfHwgY2ZnLmhlYWRlcnMgPT09IG51bGxcbiAgICAgIHx8IHR5cGVvZiBjZmcuaGVhZGVyc1snY29udGVudC10eXBlJ10gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIENvbnRlbnQtVHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIGdldEluc3RhbmNlKGNmZyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Readable, Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst StreamSearch = __webpack_require__(/*! streamsearch */ \"(rsc)/../node_modules/.pnpm/streamsearch@1.1.0/node_modules/streamsearch/lib/sbmh.js\");\n\nconst {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition,\n} = __webpack_require__(/*! ../utils.js */ \"(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js\");\n\nconst BUF_CRLF = Buffer.from('\\r\\n');\nconst BUF_CR = Buffer.from('\\r');\nconst BUF_DASH = Buffer.from('-');\n\nfunction noop() {}\n\nconst MAX_HEADER_PAIRS = 2000; // From node\nconst MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nconst HPARSER_NAME = 0;\nconst HPARSER_PRE_OWS = 1;\nconst HPARSER_VALUE = 2;\nclass HeaderParser {\n  constructor(cb) {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n\n  reset() {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n  }\n\n  push(chunk, pos, end) {\n    let start = pos;\n    while (pos < end) {\n      switch (this.state) {\n        case HPARSER_NAME: {\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (TOKEN[code] !== 1) {\n              if (code !== 58/* ':' */)\n                return -1;\n              this.name += chunk.latin1Slice(start, pos);\n              if (this.name.length === 0)\n                return -1;\n              ++pos;\n              done = true;\n              this.state = HPARSER_PRE_OWS;\n              break;\n            }\n          }\n          if (!done) {\n            this.name += chunk.latin1Slice(start, pos);\n            break;\n          }\n          // FALLTHROUGH\n        }\n        case HPARSER_PRE_OWS: {\n          // Skip optional whitespace\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (code !== 32/* ' ' */ && code !== 9/* '\\t' */) {\n              start = pos;\n              done = true;\n              this.state = HPARSER_VALUE;\n              break;\n            }\n          }\n          if (!done)\n            break;\n          // FALLTHROUGH\n        }\n        case HPARSER_VALUE:\n          switch (this.crlf) {\n            case 0: // Nothing yet\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE)\n                  return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n                if (FIELD_VCHAR[code] !== 1) {\n                  if (code !== 13/* '\\r' */)\n                    return -1;\n                  ++this.crlf;\n                  break;\n                }\n              }\n              this.value += chunk.latin1Slice(start, pos++);\n              break;\n            case 1: // Received CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              ++this.crlf;\n              break;\n            case 2: { // Received CR LF\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n              if (code === 32/* ' ' */ || code === 9/* '\\t' */) {\n                // Folded value\n                start = pos;\n                this.crlf = 0;\n              } else {\n                if (++this.pairCount < MAX_HEADER_PAIRS) {\n                  this.name = this.name.toLowerCase();\n                  if (this.header[this.name] === undefined)\n                    this.header[this.name] = [this.value];\n                  else\n                    this.header[this.name].push(this.value);\n                }\n                if (code === 13/* '\\r' */) {\n                  ++this.crlf;\n                  ++pos;\n                } else {\n                  // Assume start of next header field name\n                  start = pos;\n                  this.crlf = 0;\n                  this.state = HPARSER_NAME;\n                  this.name = '';\n                  this.value = '';\n                }\n              }\n              break;\n            }\n            case 3: { // Received CR LF CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              // End of header\n              const header = this.header;\n              this.reset();\n              this.cb(header);\n              return pos;\n            }\n          }\n          break;\n      }\n    }\n\n    return pos;\n  }\n}\n\nclass FileStream extends Readable {\n  constructor(opts, owner) {\n    super(opts);\n    this.truncated = false;\n    this._readcb = null;\n    this.once('end', () => {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      this._read();\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        const cb = owner._finalcb;\n        owner._finalcb = null;\n        // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n        process.nextTick(cb);\n      }\n    });\n  }\n  _read(n) {\n    const cb = this._readcb;\n    if (cb) {\n      this._readcb = null;\n      cb();\n    }\n  }\n}\n\nconst ignoreData = {\n  push: (chunk, pos) => {},\n  destroy: () => {},\n};\n\nfunction callAndUnsetCb(self, err) {\n  const cb = self._writecb;\n  self._writecb = null;\n  if (err)\n    self.destroy(err);\n  else if (cb)\n    cb();\n}\n\nfunction nullDecoder(val, hint) {\n  return val;\n}\n\nclass Multipart extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.highWaterMark === 'number'\n                      ? cfg.highWaterMark\n                      : undefined),\n    };\n    super(streamOpts);\n\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string')\n      throw new Error('Multipart: Boundary not found');\n\n    const boundary = cfg.conType.params.boundary;\n    const paramDecoder = (typeof cfg.defParamCharset === 'string'\n                            && cfg.defParamCharset\n                          ? getDecoder(cfg.defParamCharset)\n                          : nullDecoder);\n    const defCharset = (cfg.defCharset || 'utf8');\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.fileHwm === 'number'\n                      ? cfg.fileHwm\n                      : undefined),\n    };\n\n    const limits = cfg.limits;\n    const fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                            ? limits.fieldSize\n                            : 1 * 1024 * 1024);\n    const fileSizeLimit = (limits && typeof limits.fileSize === 'number'\n                           ? limits.fileSize\n                           : Infinity);\n    const filesLimit = (limits && typeof limits.files === 'number'\n                        ? limits.files\n                        : Infinity);\n    const fieldsLimit = (limits && typeof limits.fields === 'number'\n                         ? limits.fields\n                         : Infinity);\n    const partsLimit = (limits && typeof limits.parts === 'number'\n                        ? limits.parts\n                        : Infinity);\n\n    let parts = -1; // Account for initial boundary\n    let fields = 0;\n    let files = 0;\n    let skipPart = false;\n\n    this._fileEndsLeft = 0;\n    this._fileStream = undefined;\n    this._complete = false;\n    let fileSize = 0;\n\n    let field;\n    let fieldSize = 0;\n    let partCharset;\n    let partEncoding;\n    let partType;\n    let partName;\n    let partTruncated = false;\n\n    let hitFilesLimit = false;\n    let hitFieldsLimit = false;\n\n    this._hparser = null;\n    const hparser = new HeaderParser((header) => {\n      this._hparser = null;\n      skipPart = false;\n\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n\n      let filename;\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n\n      const disp = parseDisposition(header['content-disposition'][0],\n                                    paramDecoder);\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n\n      if (disp.params) {\n        if (disp.params.name)\n          partName = disp.params.name;\n\n        if (disp.params['filename*'])\n          filename = disp.params['filename*'];\n        else if (disp.params.filename)\n          filename = disp.params.filename;\n\n        if (filename !== undefined && !preservePath)\n          filename = basename(filename);\n      }\n\n      if (header['content-type']) {\n        const conType = parseContentType(header['content-type'][0]);\n        if (conType) {\n          partType = `${conType.type}/${conType.subtype}`;\n          if (conType.params && typeof conType.params.charset === 'string')\n            partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n\n      if (header['content-transfer-encoding'])\n        partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            this.emit('filesLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++files;\n\n        if (this.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        fileSize = 0;\n        this._fileStream = new FileStream(fileOpts, this);\n        ++this._fileEndsLeft;\n        this.emit(\n          'file',\n          partName,\n          this._fileStream,\n          { filename,\n            encoding: partEncoding,\n            mimeType: partType }\n        );\n      } else {\n        // Non-file\n\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            this.emit('fieldsLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++fields;\n\n        if (this.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        field = [];\n        fieldSize = 0;\n      }\n    });\n\n    let matchPostBoundary = 0;\n    const ssCb = (isMatch, data, start, end, isDataSafe) => {\nretrydata:\n      while (data) {\n        if (this._hparser !== null) {\n          const ret = this._hparser.push(data, start, end);\n          if (ret === -1) {\n            this._hparser = null;\n            hparser.reset();\n            this.emit('error', new Error('Malformed part header'));\n            break;\n          }\n          start = ret;\n        }\n\n        if (start === end)\n          break;\n\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45: // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n              case 13: // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n              default:\n                matchPostBoundary = 0;\n            }\n            if (start === end)\n              return;\n          }\n\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n            if (data[start] === 45/* '-' */) {\n              // End of multipart data\n              this._complete = true;\n              this._bparser = ignoreData;\n              return;\n            }\n            // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n            const writecb = this._writecb;\n            this._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            this._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n            if (data[start] === 10/* '\\n' */) {\n              ++start;\n              if (parts >= partsLimit)\n                break;\n              // Prepare the header parser\n              this._hparser = hparser;\n              if (start === end)\n                break;\n              // Process the remaining data as a header\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              const writecb = this._writecb;\n              this._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              this._writecb = writecb;\n            }\n          }\n        }\n\n        if (!skipPart) {\n          if (this._fileStream) {\n            let chunk;\n            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fileSize += chunk.length;\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0)\n                this._fileStream.push(chunk);\n              this._fileStream.emit('limit');\n              this._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!this._fileStream.push(chunk)) {\n              if (this._writecb)\n                this._fileStream._readcb = this._writecb;\n              this._writecb = null;\n            }\n          } else if (field !== undefined) {\n            let chunk;\n            const actualLen = Math.min(\n              end - start,\n              fieldSizeLimit - fieldSize\n            );\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fieldSize += actualLen;\n            field.push(chunk);\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (isMatch) {\n        matchPostBoundary = 1;\n\n        if (this._fileStream) {\n          // End the active file stream if the previous part was a file\n          this._fileStream.push(null);\n          this._fileStream = null;\n        } else if (field !== undefined) {\n          let data;\n          switch (field.length) {\n            case 0:\n              data = '';\n              break;\n            case 1:\n              data = convertToUTF8(field[0], partCharset, 0);\n              break;\n            default:\n              data = convertToUTF8(\n                Buffer.concat(field, fieldSize),\n                partCharset,\n                0\n              );\n          }\n          field = undefined;\n          fieldSize = 0;\n          this.emit(\n            'field',\n            partName,\n            data,\n            { nameTruncated: false,\n              valueTruncated: partTruncated,\n              encoding: partEncoding,\n              mimeType: partType }\n          );\n        }\n\n        if (++parts === partsLimit)\n          this.emit('partsLimit');\n      }\n    };\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, ssCb);\n\n    this._writecb = null;\n    this._finalcb = null;\n\n    // Just in case there is no preamble\n    this.write(BUF_CRLF);\n  }\n\n  static detect(conType) {\n    return (conType.type === 'multipart' && conType.subtype === 'form-data');\n  }\n\n  _write(chunk, enc, cb) {\n    this._writecb = cb;\n    this._bparser.push(chunk, 0);\n    if (this._writecb)\n      callAndUnsetCb(this);\n  }\n\n  _destroy(err, cb) {\n    this._hparser = null;\n    this._bparser = ignoreData;\n    if (!err)\n      err = checkEndState(this);\n    const fileStream = this._fileStream;\n    if (fileStream) {\n      this._fileStream = null;\n      fileStream.destroy(err);\n    }\n    cb(err);\n  }\n\n  _final(cb) {\n    this._bparser.destroy();\n    if (!this._complete)\n      return cb(new Error('Unexpected end of form'));\n    if (this._fileEndsLeft)\n      this._finalcb = finalcb.bind(null, this, cb);\n    else\n      finalcb(this, cb);\n  }\n}\n\nfunction finalcb(self, cb, err) {\n  if (err)\n    return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\n\nfunction checkEndState(self) {\n  if (self._hparser)\n    return new Error('Malformed part header');\n  const fileStream = self._fileStream;\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n  if (!self._complete)\n    return new Error('Unexpected end of form');\n}\n\nconst TOKEN = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst FIELD_VCHAR = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\nmodule.exports = Multipart;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi90eXBlcy9tdWx0aXBhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQyxxQkFBcUIsbUJBQU8sQ0FBQywwR0FBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsOEZBQWE7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0IsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWEsR0FBRyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi90eXBlcy9tdWx0aXBhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFJlYWRhYmxlLCBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFN0cmVhbVNlYXJjaCA9IHJlcXVpcmUoJ3N0cmVhbXNlYXJjaCcpO1xuXG5jb25zdCB7XG4gIGJhc2VuYW1lLFxuICBjb252ZXJ0VG9VVEY4LFxuICBnZXREZWNvZGVyLFxuICBwYXJzZUNvbnRlbnRUeXBlLFxuICBwYXJzZURpc3Bvc2l0aW9uLFxufSA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XG5cbmNvbnN0IEJVRl9DUkxGID0gQnVmZmVyLmZyb20oJ1xcclxcbicpO1xuY29uc3QgQlVGX0NSID0gQnVmZmVyLmZyb20oJ1xccicpO1xuY29uc3QgQlVGX0RBU0ggPSBCdWZmZXIuZnJvbSgnLScpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgTUFYX0hFQURFUl9QQUlSUyA9IDIwMDA7IC8vIEZyb20gbm9kZVxuY29uc3QgTUFYX0hFQURFUl9TSVpFID0gMTYgKiAxMDI0OyAvLyBGcm9tIG5vZGUgKGl0cyBkZWZhdWx0IHZhbHVlKVxuXG5jb25zdCBIUEFSU0VSX05BTUUgPSAwO1xuY29uc3QgSFBBUlNFUl9QUkVfT1dTID0gMTtcbmNvbnN0IEhQQVJTRVJfVkFMVUUgPSAyO1xuY2xhc3MgSGVhZGVyUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoY2IpIHtcbiAgICB0aGlzLmhlYWRlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5wYWlyQ291bnQgPSAwO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLnN0YXRlID0gSFBBUlNFUl9OQU1FO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICB0aGlzLmNybGYgPSAwO1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaGVhZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnBhaXJDb3VudCA9IDA7XG4gICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIHRoaXMuc3RhdGUgPSBIUEFSU0VSX05BTUU7XG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIHRoaXMuY3JsZiA9IDA7XG4gIH1cblxuICBwdXNoKGNodW5rLCBwb3MsIGVuZCkge1xuICAgIGxldCBzdGFydCA9IHBvcztcbiAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBIUEFSU0VSX05BTUU6IHtcbiAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoOyBwb3MgPCBlbmQ7ICsrcG9zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ieXRlQ291bnQgPT09IE1BWF9IRUFERVJfU0laRSlcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgKyt0aGlzLmJ5dGVDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjaHVua1twb3NdO1xuICAgICAgICAgICAgaWYgKFRPS0VOW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlICE9PSA1OC8qICc6JyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSArPSBjaHVuay5sYXRpbjFTbGljZShzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubmFtZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBIUEFSU0VSX1BSRV9PV1M7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSArPSBjaHVuay5sYXRpbjFTbGljZShzdGFydCwgcG9zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGQUxMVEhST1VHSFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgSFBBUlNFUl9QUkVfT1dTOiB7XG4gICAgICAgICAgLy8gU2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlXG4gICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKDsgcG9zIDwgZW5kOyArK3Bvcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnl0ZUNvdW50ID09PSBNQVhfSEVBREVSX1NJWkUpXG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICsrdGhpcy5ieXRlQ291bnQ7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gY2h1bmtbcG9zXTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSAzMi8qICcgJyAqLyAmJiBjb2RlICE9PSA5LyogJ1xcdCcgKi8pIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gSFBBUlNFUl9WQUxVRTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEZBTExUSFJPVUdIXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBIUEFSU0VSX1ZBTFVFOlxuICAgICAgICAgIHN3aXRjaCAodGhpcy5jcmxmKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIE5vdGhpbmcgeWV0XG4gICAgICAgICAgICAgIGZvciAoOyBwb3MgPCBlbmQ7ICsrcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYnl0ZUNvdW50ID09PSBNQVhfSEVBREVSX1NJWkUpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gY2h1bmtbcG9zXTtcbiAgICAgICAgICAgICAgICBpZiAoRklFTERfVkNIQVJbY29kZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAxMy8qICdcXHInICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICArK3RoaXMuY3JsZjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IGNodW5rLmxhdGluMVNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBSZWNlaXZlZCBDUlxuICAgICAgICAgICAgICBpZiAodGhpcy5ieXRlQ291bnQgPT09IE1BWF9IRUFERVJfU0laRSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICsrdGhpcy5ieXRlQ291bnQ7XG4gICAgICAgICAgICAgIGlmIChjaHVua1twb3MrK10gIT09IDEwLyogJ1xcbicgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICArK3RoaXMuY3JsZjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IHsgLy8gUmVjZWl2ZWQgQ1IgTEZcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYnl0ZUNvdW50ID09PSBNQVhfSEVBREVSX1NJWkUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICArK3RoaXMuYnl0ZUNvdW50O1xuICAgICAgICAgICAgICBjb25zdCBjb2RlID0gY2h1bmtbcG9zXTtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDMyLyogJyAnICovIHx8IGNvZGUgPT09IDkvKiAnXFx0JyAqLykge1xuICAgICAgICAgICAgICAgIC8vIEZvbGRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JsZiA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5wYWlyQ291bnQgPCBNQVhfSEVBREVSX1BBSVJTKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlclt0aGlzLm5hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyW3RoaXMubmFtZV0gPSBbdGhpcy52YWx1ZV07XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyW3RoaXMubmFtZV0ucHVzaCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzLyogJ1xccicgKi8pIHtcbiAgICAgICAgICAgICAgICAgICsrdGhpcy5jcmxmO1xuICAgICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBzdGFydCBvZiBuZXh0IGhlYWRlciBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICAgIHRoaXMuY3JsZiA9IDA7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gSFBBUlNFUl9OQU1FO1xuICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOiB7IC8vIFJlY2VpdmVkIENSIExGIENSXG4gICAgICAgICAgICAgIGlmICh0aGlzLmJ5dGVDb3VudCA9PT0gTUFYX0hFQURFUl9TSVpFKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgKyt0aGlzLmJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgaWYgKGNodW5rW3BvcysrXSAhPT0gMTAvKiAnXFxuJyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIC8vIEVuZCBvZiBoZWFkZXJcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXI7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgdGhpcy5jYihoZWFkZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zO1xuICB9XG59XG5cbmNsYXNzIEZpbGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMsIG93bmVyKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy50cnVuY2F0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkY2IgPSBudWxsO1xuICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBjYWxsIGFueSBvdXRzdGFuZGluZyBfd3JpdGVjYigpIHRoYXQgaXNcbiAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpbGUgc28gdGhhdCBwcm9jZXNzaW5nIG9mIHRoZSByZXN0IG9mIHRoZSBmb3JtXG4gICAgICAvLyBjYW4gY29udGludWUuIFRoaXMgbWF5IG5vdCBoYXBwZW4gaWYgdGhlIGZpbGUgc3RyZWFtIGVuZHMgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGJhY2twcmVzc3VyZSBraWNrcyBpbiwgc28gd2UgZm9yY2UgaXQgaGVyZS5cbiAgICAgIHRoaXMuX3JlYWQoKTtcbiAgICAgIGlmICgtLW93bmVyLl9maWxlRW5kc0xlZnQgPT09IDAgJiYgb3duZXIuX2ZpbmFsY2IpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvd25lci5fZmluYWxjYjtcbiAgICAgICAgb3duZXIuX2ZpbmFsY2IgPSBudWxsO1xuICAgICAgICAvLyBNYWtlIHN1cmUgb3RoZXIgJ2VuZCcgZXZlbnQgaGFuZGxlcnMgZ2V0IGEgY2hhbmNlIHRvIGJlIGV4ZWN1dGVkXG4gICAgICAgIC8vIGJlZm9yZSBidXNib3kncyAnZmluaXNoJyBldmVudCBpcyBlbWl0dGVkXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWFkKG4pIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX3JlYWRjYjtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRoaXMuX3JlYWRjYiA9IG51bGw7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpZ25vcmVEYXRhID0ge1xuICBwdXNoOiAoY2h1bmssIHBvcykgPT4ge30sXG4gIGRlc3Ryb3k6ICgpID0+IHt9LFxufTtcblxuZnVuY3Rpb24gY2FsbEFuZFVuc2V0Q2Ioc2VsZiwgZXJyKSB7XG4gIGNvbnN0IGNiID0gc2VsZi5fd3JpdGVjYjtcbiAgc2VsZi5fd3JpdGVjYiA9IG51bGw7XG4gIGlmIChlcnIpXG4gICAgc2VsZi5kZXN0cm95KGVycik7XG4gIGVsc2UgaWYgKGNiKVxuICAgIGNiKCk7XG59XG5cbmZ1bmN0aW9uIG51bGxEZWNvZGVyKHZhbCwgaGludCkge1xuICByZXR1cm4gdmFsO1xufVxuXG5jbGFzcyBNdWx0aXBhcnQgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIGNvbnN0IHN0cmVhbU9wdHMgPSB7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIGVtaXRDbG9zZTogdHJ1ZSxcbiAgICAgIGhpZ2hXYXRlck1hcms6ICh0eXBlb2YgY2ZnLmhpZ2hXYXRlck1hcmsgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgPyBjZmcuaGlnaFdhdGVyTWFya1xuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICB9O1xuICAgIHN1cGVyKHN0cmVhbU9wdHMpO1xuXG4gICAgaWYgKCFjZmcuY29uVHlwZS5wYXJhbXMgfHwgdHlwZW9mIGNmZy5jb25UeXBlLnBhcmFtcy5ib3VuZGFyeSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGFydDogQm91bmRhcnkgbm90IGZvdW5kJyk7XG5cbiAgICBjb25zdCBib3VuZGFyeSA9IGNmZy5jb25UeXBlLnBhcmFtcy5ib3VuZGFyeTtcbiAgICBjb25zdCBwYXJhbURlY29kZXIgPSAodHlwZW9mIGNmZy5kZWZQYXJhbUNoYXJzZXQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2ZnLmRlZlBhcmFtQ2hhcnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdldERlY29kZXIoY2ZnLmRlZlBhcmFtQ2hhcnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsRGVjb2Rlcik7XG4gICAgY29uc3QgZGVmQ2hhcnNldCA9IChjZmcuZGVmQ2hhcnNldCB8fCAndXRmOCcpO1xuICAgIGNvbnN0IHByZXNlcnZlUGF0aCA9IGNmZy5wcmVzZXJ2ZVBhdGg7XG4gICAgY29uc3QgZmlsZU9wdHMgPSB7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIGVtaXRDbG9zZTogdHJ1ZSxcbiAgICAgIGhpZ2hXYXRlck1hcms6ICh0eXBlb2YgY2ZnLmZpbGVId20gPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgPyBjZmcuZmlsZUh3bVxuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICB9O1xuXG4gICAgY29uc3QgbGltaXRzID0gY2ZnLmxpbWl0cztcbiAgICBjb25zdCBmaWVsZFNpemVMaW1pdCA9IChsaW1pdHMgJiYgdHlwZW9mIGxpbWl0cy5maWVsZFNpemUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsaW1pdHMuZmllbGRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxICogMTAyNCAqIDEwMjQpO1xuICAgIGNvbnN0IGZpbGVTaXplTGltaXQgPSAobGltaXRzICYmIHR5cGVvZiBsaW1pdHMuZmlsZVNpemUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxpbWl0cy5maWxlU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBJbmZpbml0eSk7XG4gICAgY29uc3QgZmlsZXNMaW1pdCA9IChsaW1pdHMgJiYgdHlwZW9mIGxpbWl0cy5maWxlcyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGltaXRzLmZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5KTtcbiAgICBjb25zdCBmaWVsZHNMaW1pdCA9IChsaW1pdHMgJiYgdHlwZW9mIGxpbWl0cy5maWVsZHMgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyBsaW1pdHMuZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBJbmZpbml0eSk7XG4gICAgY29uc3QgcGFydHNMaW1pdCA9IChsaW1pdHMgJiYgdHlwZW9mIGxpbWl0cy5wYXJ0cyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGltaXRzLnBhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5KTtcblxuICAgIGxldCBwYXJ0cyA9IC0xOyAvLyBBY2NvdW50IGZvciBpbml0aWFsIGJvdW5kYXJ5XG4gICAgbGV0IGZpZWxkcyA9IDA7XG4gICAgbGV0IGZpbGVzID0gMDtcbiAgICBsZXQgc2tpcFBhcnQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2ZpbGVFbmRzTGVmdCA9IDA7XG4gICAgdGhpcy5fZmlsZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xuICAgIGxldCBmaWxlU2l6ZSA9IDA7XG5cbiAgICBsZXQgZmllbGQ7XG4gICAgbGV0IGZpZWxkU2l6ZSA9IDA7XG4gICAgbGV0IHBhcnRDaGFyc2V0O1xuICAgIGxldCBwYXJ0RW5jb2Rpbmc7XG4gICAgbGV0IHBhcnRUeXBlO1xuICAgIGxldCBwYXJ0TmFtZTtcbiAgICBsZXQgcGFydFRydW5jYXRlZCA9IGZhbHNlO1xuXG4gICAgbGV0IGhpdEZpbGVzTGltaXQgPSBmYWxzZTtcbiAgICBsZXQgaGl0RmllbGRzTGltaXQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2hwYXJzZXIgPSBudWxsO1xuICAgIGNvbnN0IGhwYXJzZXIgPSBuZXcgSGVhZGVyUGFyc2VyKChoZWFkZXIpID0+IHtcbiAgICAgIHRoaXMuX2hwYXJzZXIgPSBudWxsO1xuICAgICAgc2tpcFBhcnQgPSBmYWxzZTtcblxuICAgICAgcGFydFR5cGUgPSAndGV4dC9wbGFpbic7XG4gICAgICBwYXJ0Q2hhcnNldCA9IGRlZkNoYXJzZXQ7XG4gICAgICBwYXJ0RW5jb2RpbmcgPSAnN2JpdCc7XG4gICAgICBwYXJ0TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIHBhcnRUcnVuY2F0ZWQgPSBmYWxzZTtcblxuICAgICAgbGV0IGZpbGVuYW1lO1xuICAgICAgaWYgKCFoZWFkZXJbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSkge1xuICAgICAgICBza2lwUGFydCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcCA9IHBhcnNlRGlzcG9zaXRpb24oaGVhZGVyWydjb250ZW50LWRpc3Bvc2l0aW9uJ11bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbURlY29kZXIpO1xuICAgICAgaWYgKCFkaXNwIHx8IGRpc3AudHlwZSAhPT0gJ2Zvcm0tZGF0YScpIHtcbiAgICAgICAgc2tpcFBhcnQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNwLnBhcmFtcykge1xuICAgICAgICBpZiAoZGlzcC5wYXJhbXMubmFtZSlcbiAgICAgICAgICBwYXJ0TmFtZSA9IGRpc3AucGFyYW1zLm5hbWU7XG5cbiAgICAgICAgaWYgKGRpc3AucGFyYW1zWydmaWxlbmFtZSonXSlcbiAgICAgICAgICBmaWxlbmFtZSA9IGRpc3AucGFyYW1zWydmaWxlbmFtZSonXTtcbiAgICAgICAgZWxzZSBpZiAoZGlzcC5wYXJhbXMuZmlsZW5hbWUpXG4gICAgICAgICAgZmlsZW5hbWUgPSBkaXNwLnBhcmFtcy5maWxlbmFtZTtcblxuICAgICAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCAmJiAhcHJlc2VydmVQYXRoKVxuICAgICAgICAgIGZpbGVuYW1lID0gYmFzZW5hbWUoZmlsZW5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGVyWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBjb25zdCBjb25UeXBlID0gcGFyc2VDb250ZW50VHlwZShoZWFkZXJbJ2NvbnRlbnQtdHlwZSddWzBdKTtcbiAgICAgICAgaWYgKGNvblR5cGUpIHtcbiAgICAgICAgICBwYXJ0VHlwZSA9IGAke2NvblR5cGUudHlwZX0vJHtjb25UeXBlLnN1YnR5cGV9YDtcbiAgICAgICAgICBpZiAoY29uVHlwZS5wYXJhbXMgJiYgdHlwZW9mIGNvblR5cGUucGFyYW1zLmNoYXJzZXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcGFydENoYXJzZXQgPSBjb25UeXBlLnBhcmFtcy5jaGFyc2V0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRlclsnY29udGVudC10cmFuc2Zlci1lbmNvZGluZyddKVxuICAgICAgICBwYXJ0RW5jb2RpbmcgPSBoZWFkZXJbJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnXVswXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAocGFydFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRmlsZVxuXG4gICAgICAgIGlmIChmaWxlcyA9PT0gZmlsZXNMaW1pdCkge1xuICAgICAgICAgIGlmICghaGl0RmlsZXNMaW1pdCkge1xuICAgICAgICAgICAgaGl0RmlsZXNMaW1pdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbGVzTGltaXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2tpcFBhcnQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICArK2ZpbGVzO1xuXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2ZpbGUnKSA9PT0gMCkge1xuICAgICAgICAgIHNraXBQYXJ0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmaWxlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0gPSBuZXcgRmlsZVN0cmVhbShmaWxlT3B0cywgdGhpcyk7XG4gICAgICAgICsrdGhpcy5fZmlsZUVuZHNMZWZ0O1xuICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgJ2ZpbGUnLFxuICAgICAgICAgIHBhcnROYW1lLFxuICAgICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0sXG4gICAgICAgICAgeyBmaWxlbmFtZSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBwYXJ0RW5jb2RpbmcsXG4gICAgICAgICAgICBtaW1lVHlwZTogcGFydFR5cGUgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLWZpbGVcblxuICAgICAgICBpZiAoZmllbGRzID09PSBmaWVsZHNMaW1pdCkge1xuICAgICAgICAgIGlmICghaGl0RmllbGRzTGltaXQpIHtcbiAgICAgICAgICAgIGhpdEZpZWxkc0xpbWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmllbGRzTGltaXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2tpcFBhcnQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICArK2ZpZWxkcztcblxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdmaWVsZCcpID09PSAwKSB7XG4gICAgICAgICAgc2tpcFBhcnQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkID0gW107XG4gICAgICAgIGZpZWxkU2l6ZSA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgbWF0Y2hQb3N0Qm91bmRhcnkgPSAwO1xuICAgIGNvbnN0IHNzQ2IgPSAoaXNNYXRjaCwgZGF0YSwgc3RhcnQsIGVuZCwgaXNEYXRhU2FmZSkgPT4ge1xucmV0cnlkYXRhOlxuICAgICAgd2hpbGUgKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hwYXJzZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9ocGFyc2VyLnB1c2goZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2hwYXJzZXIgPSBudWxsO1xuICAgICAgICAgICAgaHBhcnNlci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTWFsZm9ybWVkIHBhcnQgaGVhZGVyJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgaWYgKG1hdGNoUG9zdEJvdW5kYXJ5ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKG1hdGNoUG9zdEJvdW5kYXJ5ID09PSAxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGFbc3RhcnRdKSB7XG4gICAgICAgICAgICAgIGNhc2UgNDU6IC8vICctJ1xuICAgICAgICAgICAgICAgIC8vIFRyeSBtYXRjaGluZyAnLS0nIGFmdGVyIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgbWF0Y2hQb3N0Qm91bmRhcnkgPSAyO1xuICAgICAgICAgICAgICAgICsrc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTM6IC8vICdcXHInXG4gICAgICAgICAgICAgICAgLy8gVHJ5IG1hdGNoaW5nIENSIExGIGJlZm9yZSBoZWFkZXJcbiAgICAgICAgICAgICAgICBtYXRjaFBvc3RCb3VuZGFyeSA9IDM7XG4gICAgICAgICAgICAgICAgKytzdGFydDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtYXRjaFBvc3RCb3VuZGFyeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaFBvc3RCb3VuZGFyeSA9PT0gMikge1xuICAgICAgICAgICAgbWF0Y2hQb3N0Qm91bmRhcnkgPSAwO1xuICAgICAgICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSA0NS8qICctJyAqLykge1xuICAgICAgICAgICAgICAvLyBFbmQgb2YgbXVsdGlwYXJ0IGRhdGFcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLl9icGFyc2VyID0gaWdub3JlRGF0YTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugc2F3IHNvbWV0aGluZyBvdGhlciB0aGFuICctJywgc28gcHV0IHRoZSBkYXNoIHdlIGNvbnN1bWVkXG4gICAgICAgICAgICAvLyBcImJhY2tcIlxuICAgICAgICAgICAgY29uc3Qgd3JpdGVjYiA9IHRoaXMuX3dyaXRlY2I7XG4gICAgICAgICAgICB0aGlzLl93cml0ZWNiID0gbm9vcDtcbiAgICAgICAgICAgIHNzQ2IoZmFsc2UsIEJVRl9EQVNILCAwLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl93cml0ZWNiID0gd3JpdGVjYjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoUG9zdEJvdW5kYXJ5ID09PSAzKSB7XG4gICAgICAgICAgICBtYXRjaFBvc3RCb3VuZGFyeSA9IDA7XG4gICAgICAgICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDEwLyogJ1xcbicgKi8pIHtcbiAgICAgICAgICAgICAgKytzdGFydDtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzID49IHBhcnRzTGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIGhlYWRlciBwYXJzZXJcbiAgICAgICAgICAgICAgdGhpcy5faHBhcnNlciA9IGhwYXJzZXI7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZW1haW5pbmcgZGF0YSBhcyBhIGhlYWRlclxuICAgICAgICAgICAgICBjb250aW51ZSByZXRyeWRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBzYXcgc29tZXRoaW5nIG90aGVyIHRoYW4gTEYsIHNvIHB1dCB0aGUgQ1Igd2UgY29uc3VtZWRcbiAgICAgICAgICAgICAgLy8gXCJiYWNrXCJcbiAgICAgICAgICAgICAgY29uc3Qgd3JpdGVjYiA9IHRoaXMuX3dyaXRlY2I7XG4gICAgICAgICAgICAgIHRoaXMuX3dyaXRlY2IgPSBub29wO1xuICAgICAgICAgICAgICBzc0NiKGZhbHNlLCBCVUZfQ1IsIDAsIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5fd3JpdGVjYiA9IHdyaXRlY2I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwUGFydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9maWxlU3RyZWFtKSB7XG4gICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxMZW4gPSBNYXRoLm1pbihlbmQgLSBzdGFydCwgZmlsZVNpemVMaW1pdCAtIGZpbGVTaXplKTtcbiAgICAgICAgICAgIGlmICghaXNEYXRhU2FmZSkge1xuICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShhY3R1YWxMZW4pO1xuICAgICAgICAgICAgICBkYXRhLmNvcHkoY2h1bmssIDAsIHN0YXJ0LCBzdGFydCArIGFjdHVhbExlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaHVuayA9IGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYWN0dWFsTGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZVNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZpbGVTaXplID09PSBmaWxlU2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0ucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0uZW1pdCgnbGltaXQnKTtcbiAgICAgICAgICAgICAgdGhpcy5fZmlsZVN0cmVhbS50cnVuY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBza2lwUGFydCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9maWxlU3RyZWFtLnB1c2goY2h1bmspKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl93cml0ZWNiKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0uX3JlYWRjYiA9IHRoaXMuX3dyaXRlY2I7XG4gICAgICAgICAgICAgIHRoaXMuX3dyaXRlY2IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsTGVuID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICBmaWVsZFNpemVMaW1pdCAtIGZpZWxkU2l6ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghaXNEYXRhU2FmZSkge1xuICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShhY3R1YWxMZW4pO1xuICAgICAgICAgICAgICBkYXRhLmNvcHkoY2h1bmssIDAsIHN0YXJ0LCBzdGFydCArIGFjdHVhbExlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaHVuayA9IGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYWN0dWFsTGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGRTaXplICs9IGFjdHVhbExlbjtcbiAgICAgICAgICAgIGZpZWxkLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgaWYgKGZpZWxkU2l6ZSA9PT0gZmllbGRTaXplTGltaXQpIHtcbiAgICAgICAgICAgICAgc2tpcFBhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICBwYXJ0VHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgbWF0Y2hQb3N0Qm91bmRhcnkgPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLl9maWxlU3RyZWFtKSB7XG4gICAgICAgICAgLy8gRW5kIHRoZSBhY3RpdmUgZmlsZSBzdHJlYW0gaWYgdGhlIHByZXZpb3VzIHBhcnQgd2FzIGEgZmlsZVxuICAgICAgICAgIHRoaXMuX2ZpbGVTdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICB0aGlzLl9maWxlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgc3dpdGNoIChmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgZGF0YSA9ICcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgZGF0YSA9IGNvbnZlcnRUb1VURjgoZmllbGRbMF0sIHBhcnRDaGFyc2V0LCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBkYXRhID0gY29udmVydFRvVVRGOChcbiAgICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KGZpZWxkLCBmaWVsZFNpemUpLFxuICAgICAgICAgICAgICAgIHBhcnRDaGFyc2V0LFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZmllbGRTaXplID0gMDtcbiAgICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgICAnZmllbGQnLFxuICAgICAgICAgICAgcGFydE5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgeyBuYW1lVHJ1bmNhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWVUcnVuY2F0ZWQ6IHBhcnRUcnVuY2F0ZWQsXG4gICAgICAgICAgICAgIGVuY29kaW5nOiBwYXJ0RW5jb2RpbmcsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0VHlwZSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3BhcnRzID09PSBwYXJ0c0xpbWl0KVxuICAgICAgICAgIHRoaXMuZW1pdCgncGFydHNMaW1pdCcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fYnBhcnNlciA9IG5ldyBTdHJlYW1TZWFyY2goYFxcclxcbi0tJHtib3VuZGFyeX1gLCBzc0NiKTtcblxuICAgIHRoaXMuX3dyaXRlY2IgPSBudWxsO1xuICAgIHRoaXMuX2ZpbmFsY2IgPSBudWxsO1xuXG4gICAgLy8gSnVzdCBpbiBjYXNlIHRoZXJlIGlzIG5vIHByZWFtYmxlXG4gICAgdGhpcy53cml0ZShCVUZfQ1JMRik7XG4gIH1cblxuICBzdGF0aWMgZGV0ZWN0KGNvblR5cGUpIHtcbiAgICByZXR1cm4gKGNvblR5cGUudHlwZSA9PT0gJ211bHRpcGFydCcgJiYgY29uVHlwZS5zdWJ0eXBlID09PSAnZm9ybS1kYXRhJyk7XG4gIH1cblxuICBfd3JpdGUoY2h1bmssIGVuYywgY2IpIHtcbiAgICB0aGlzLl93cml0ZWNiID0gY2I7XG4gICAgdGhpcy5fYnBhcnNlci5wdXNoKGNodW5rLCAwKTtcbiAgICBpZiAodGhpcy5fd3JpdGVjYilcbiAgICAgIGNhbGxBbmRVbnNldENiKHRoaXMpO1xuICB9XG5cbiAgX2Rlc3Ryb3koZXJyLCBjYikge1xuICAgIHRoaXMuX2hwYXJzZXIgPSBudWxsO1xuICAgIHRoaXMuX2JwYXJzZXIgPSBpZ25vcmVEYXRhO1xuICAgIGlmICghZXJyKVxuICAgICAgZXJyID0gY2hlY2tFbmRTdGF0ZSh0aGlzKTtcbiAgICBjb25zdCBmaWxlU3RyZWFtID0gdGhpcy5fZmlsZVN0cmVhbTtcbiAgICBpZiAoZmlsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZmlsZVN0cmVhbSA9IG51bGw7XG4gICAgICBmaWxlU3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICB9XG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIF9maW5hbChjYikge1xuICAgIHRoaXMuX2JwYXJzZXIuZGVzdHJveSgpO1xuICAgIGlmICghdGhpcy5fY29tcGxldGUpXG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBmb3JtJykpO1xuICAgIGlmICh0aGlzLl9maWxlRW5kc0xlZnQpXG4gICAgICB0aGlzLl9maW5hbGNiID0gZmluYWxjYi5iaW5kKG51bGwsIHRoaXMsIGNiKTtcbiAgICBlbHNlXG4gICAgICBmaW5hbGNiKHRoaXMsIGNiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5hbGNiKHNlbGYsIGNiLCBlcnIpIHtcbiAgaWYgKGVycilcbiAgICByZXR1cm4gY2IoZXJyKTtcbiAgZXJyID0gY2hlY2tFbmRTdGF0ZShzZWxmKTtcbiAgY2IoZXJyKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tFbmRTdGF0ZShzZWxmKSB7XG4gIGlmIChzZWxmLl9ocGFyc2VyKVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ01hbGZvcm1lZCBwYXJ0IGhlYWRlcicpO1xuICBjb25zdCBmaWxlU3RyZWFtID0gc2VsZi5fZmlsZVN0cmVhbTtcbiAgaWYgKGZpbGVTdHJlYW0pIHtcbiAgICBzZWxmLl9maWxlU3RyZWFtID0gbnVsbDtcbiAgICBmaWxlU3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBmaWxlJykpO1xuICB9XG4gIGlmICghc2VsZi5fY29tcGxldGUpXG4gICAgcmV0dXJuIG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZm9ybScpO1xufVxuXG5jb25zdCBUT0tFTiA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbl07XG5cbmNvbnN0IEZJRUxEX1ZDSEFSID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBhcnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst { getDecoder } = __webpack_require__(/*! ../utils.js */ \"(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js\");\n\nclass URLEncoded extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.highWaterMark === 'number'\n                      ? cfg.highWaterMark\n                      : undefined),\n    };\n    super(streamOpts);\n\n    let charset = (cfg.defCharset || 'utf8');\n    if (cfg.conType.params && typeof cfg.conType.params.charset === 'string')\n      charset = cfg.conType.params.charset;\n\n    this.charset = charset;\n\n    const limits = cfg.limits;\n    this.fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                           ? limits.fieldSize\n                           : 1 * 1024 * 1024);\n    this.fieldsLimit = (limits && typeof limits.fields === 'number'\n                        ? limits.fields\n                        : Infinity);\n    this.fieldNameSizeLimit = (\n      limits && typeof limits.fieldNameSize === 'number'\n      ? limits.fieldNameSize\n      : 100\n    );\n\n    this._inKey = true;\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._fields = 0;\n    this._key = '';\n    this._val = '';\n    this._byte = -2;\n    this._lastPos = 0;\n    this._encode = 0;\n    this._decoder = getDecoder(charset);\n  }\n\n  static detect(conType) {\n    return (conType.type === 'application'\n            && conType.subtype === 'x-www-form-urlencoded');\n  }\n\n  _write(chunk, enc, cb) {\n    if (this._fields >= this.fieldsLimit)\n      return cb();\n\n    let i = 0;\n    const len = chunk.length;\n    this._lastPos = 0;\n\n    // Check if we last ended mid-percent-encoded byte\n    if (this._byte !== -2) {\n      i = readPctEnc(this, chunk, i, len);\n      if (i === -1)\n        return cb(new Error('Malformed urlencoded form'));\n      if (i >= len)\n        return cb();\n      if (this._inKey)\n        ++this._bytesKey;\n      else\n        ++this._bytesVal;\n    }\n\nmain:\n    while (i < len) {\n      if (this._inKey) {\n        // Parsing key\n\n        i = skipKeyBytes(this, chunk, i, len);\n\n        while (i < len) {\n          switch (chunk[i]) {\n            case 61: // '='\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              this._inKey = false;\n              continue main;\n            case 38: // '&'\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0) {\n                this.emit(\n                  'field',\n                  this._key,\n                  '',\n                  { nameTruncated: this._keyTrunc,\n                    valueTruncated: false,\n                    encoding: this.charset,\n                    mimeType: 'text/plain' }\n                );\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue;\n            case 43: // '+'\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._key += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37: // '%'\n              if (this._encode === 0)\n                this._encode = 1;\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1)\n                return cb(new Error('Malformed urlencoded form'));\n              if (i >= len)\n                return cb();\n              ++this._bytesKey;\n              i = skipKeyBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesKey;\n          i = skipKeyBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i)\n          this._key += chunk.latin1Slice(this._lastPos, i);\n      } else {\n        // Parsing value\n\n        i = skipValBytes(this, chunk, i, len);\n\n        while (i < len) {\n          switch (chunk[i]) {\n            case 38: // '&'\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._inKey = true;\n              this._val = this._decoder(this._val, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0 || this._bytesVal > 0) {\n                this.emit(\n                  'field',\n                  this._key,\n                  this._val,\n                  { nameTruncated: this._keyTrunc,\n                    valueTruncated: this._valTrunc,\n                    encoding: this.charset,\n                    mimeType: 'text/plain' }\n                );\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue main;\n            case 43: // '+'\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._val += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37: // '%'\n              if (this._encode === 0)\n                this._encode = 1;\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1)\n                return cb(new Error('Malformed urlencoded form'));\n              if (i >= len)\n                return cb();\n              ++this._bytesVal;\n              i = skipValBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesVal;\n          i = skipValBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i)\n          this._val += chunk.latin1Slice(this._lastPos, i);\n      }\n    }\n\n    cb();\n  }\n\n  _final(cb) {\n    if (this._byte !== -2)\n      return cb(new Error('Malformed urlencoded form'));\n    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {\n      if (this._inKey)\n        this._key = this._decoder(this._key, this._encode);\n      else\n        this._val = this._decoder(this._val, this._encode);\n      this.emit(\n        'field',\n        this._key,\n        this._val,\n        { nameTruncated: this._keyTrunc,\n          valueTruncated: this._valTrunc,\n          encoding: this.charset,\n          mimeType: 'text/plain' }\n      );\n    }\n    cb();\n  }\n}\n\nfunction readPctEnc(self, chunk, pos, len) {\n  if (pos >= len)\n    return len;\n\n  if (self._byte === -1) {\n    // We saw a '%' but no hex characters yet\n    const hexUpper = HEX_VALUES[chunk[pos++]];\n    if (hexUpper === -1)\n      return -1;\n\n    if (hexUpper >= 8)\n      self._encode = 2; // Indicate high bits detected\n\n    if (pos < len) {\n      // Both hex characters are in this chunk\n      const hexLower = HEX_VALUES[chunk[pos++]];\n      if (hexLower === -1)\n        return -1;\n\n      if (self._inKey)\n        self._key += String.fromCharCode((hexUpper << 4) + hexLower);\n      else\n        self._val += String.fromCharCode((hexUpper << 4) + hexLower);\n\n      self._byte = -2;\n      self._lastPos = pos;\n    } else {\n      // Only one hex character was available in this chunk\n      self._byte = hexUpper;\n    }\n  } else {\n    // We saw only one hex character so far\n    const hexLower = HEX_VALUES[chunk[pos++]];\n    if (hexLower === -1)\n      return -1;\n\n    if (self._inKey)\n      self._key += String.fromCharCode((self._byte << 4) + hexLower);\n    else\n      self._val += String.fromCharCode((self._byte << 4) + hexLower);\n\n    self._byte = -2;\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\nfunction skipKeyBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesKey > self.fieldNameSizeLimit) {\n    if (!self._keyTrunc) {\n      if (self._lastPos < pos)\n        self._key += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._keyTrunc = true;\n    for (; pos < len; ++pos) {\n      const code = chunk[pos];\n      if (code === 61/* '=' */ || code === 38/* '&' */)\n        break;\n      ++self._bytesKey;\n    }\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\nfunction skipValBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesVal > self.fieldSizeLimit) {\n    if (!self._valTrunc) {\n      if (self._lastPos < pos)\n        self._val += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._valTrunc = true;\n    for (; pos < len; ++pos) {\n      if (chunk[pos] === 38/* '&' */)\n        break;\n      ++self._bytesVal;\n    }\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\n/* eslint-disable no-multi-spaces */\nconst HEX_VALUES = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = URLEncoded;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi90eXBlcy91cmxlbmNvZGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXJDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsOEZBQWE7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3BhdWwvcHJvamVjdHMvcGF5bG9hZC9wbHVnaW4tZGV2ZWxvcG1lbnQvYmV0dGVyLWZpZWxkcy9naXRyb290L25vZGVfbW9kdWxlcy8ucG5wbS9idXNib3lAMS42LjAvbm9kZV9tb2R1bGVzL2J1c2JveS9saWIvdHlwZXMvdXJsZW5jb2RlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCB7IGdldERlY29kZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XG5cbmNsYXNzIFVSTEVuY29kZWQgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIGNvbnN0IHN0cmVhbU9wdHMgPSB7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIGVtaXRDbG9zZTogdHJ1ZSxcbiAgICAgIGhpZ2hXYXRlck1hcms6ICh0eXBlb2YgY2ZnLmhpZ2hXYXRlck1hcmsgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgPyBjZmcuaGlnaFdhdGVyTWFya1xuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICB9O1xuICAgIHN1cGVyKHN0cmVhbU9wdHMpO1xuXG4gICAgbGV0IGNoYXJzZXQgPSAoY2ZnLmRlZkNoYXJzZXQgfHwgJ3V0ZjgnKTtcbiAgICBpZiAoY2ZnLmNvblR5cGUucGFyYW1zICYmIHR5cGVvZiBjZmcuY29uVHlwZS5wYXJhbXMuY2hhcnNldCA9PT0gJ3N0cmluZycpXG4gICAgICBjaGFyc2V0ID0gY2ZnLmNvblR5cGUucGFyYW1zLmNoYXJzZXQ7XG5cbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuXG4gICAgY29uc3QgbGltaXRzID0gY2ZnLmxpbWl0cztcbiAgICB0aGlzLmZpZWxkU2l6ZUxpbWl0ID0gKGxpbWl0cyAmJiB0eXBlb2YgbGltaXRzLmZpZWxkU2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbGltaXRzLmZpZWxkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxICogMTAyNCAqIDEwMjQpO1xuICAgIHRoaXMuZmllbGRzTGltaXQgPSAobGltaXRzICYmIHR5cGVvZiBsaW1pdHMuZmllbGRzID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBsaW1pdHMuZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5KTtcbiAgICB0aGlzLmZpZWxkTmFtZVNpemVMaW1pdCA9IChcbiAgICAgIGxpbWl0cyAmJiB0eXBlb2YgbGltaXRzLmZpZWxkTmFtZVNpemUgPT09ICdudW1iZXInXG4gICAgICA/IGxpbWl0cy5maWVsZE5hbWVTaXplXG4gICAgICA6IDEwMFxuICAgICk7XG5cbiAgICB0aGlzLl9pbktleSA9IHRydWU7XG4gICAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZTtcbiAgICB0aGlzLl92YWxUcnVuYyA9IGZhbHNlO1xuICAgIHRoaXMuX2J5dGVzS2V5ID0gMDtcbiAgICB0aGlzLl9ieXRlc1ZhbCA9IDA7XG4gICAgdGhpcy5fZmllbGRzID0gMDtcbiAgICB0aGlzLl9rZXkgPSAnJztcbiAgICB0aGlzLl92YWwgPSAnJztcbiAgICB0aGlzLl9ieXRlID0gLTI7XG4gICAgdGhpcy5fbGFzdFBvcyA9IDA7XG4gICAgdGhpcy5fZW5jb2RlID0gMDtcbiAgICB0aGlzLl9kZWNvZGVyID0gZ2V0RGVjb2RlcihjaGFyc2V0KTtcbiAgfVxuXG4gIHN0YXRpYyBkZXRlY3QoY29uVHlwZSkge1xuICAgIHJldHVybiAoY29uVHlwZS50eXBlID09PSAnYXBwbGljYXRpb24nXG4gICAgICAgICAgICAmJiBjb25UeXBlLnN1YnR5cGUgPT09ICd4LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgfVxuXG4gIF93cml0ZShjaHVuaywgZW5jLCBjYikge1xuICAgIGlmICh0aGlzLl9maWVsZHMgPj0gdGhpcy5maWVsZHNMaW1pdClcbiAgICAgIHJldHVybiBjYigpO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9sYXN0UG9zID0gMDtcblxuICAgIC8vIENoZWNrIGlmIHdlIGxhc3QgZW5kZWQgbWlkLXBlcmNlbnQtZW5jb2RlZCBieXRlXG4gICAgaWYgKHRoaXMuX2J5dGUgIT09IC0yKSB7XG4gICAgICBpID0gcmVhZFBjdEVuYyh0aGlzLCBjaHVuaywgaSwgbGVuKTtcbiAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTWFsZm9ybWVkIHVybGVuY29kZWQgZm9ybScpKTtcbiAgICAgIGlmIChpID49IGxlbilcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICBpZiAodGhpcy5faW5LZXkpXG4gICAgICAgICsrdGhpcy5fYnl0ZXNLZXk7XG4gICAgICBlbHNlXG4gICAgICAgICsrdGhpcy5fYnl0ZXNWYWw7XG4gICAgfVxuXG5tYWluOlxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy5faW5LZXkpIHtcbiAgICAgICAgLy8gUGFyc2luZyBrZXlcblxuICAgICAgICBpID0gc2tpcEtleUJ5dGVzKHRoaXMsIGNodW5rLCBpLCBsZW4pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVua1tpXSkge1xuICAgICAgICAgICAgY2FzZSA2MTogLy8gJz0nXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UG9zIDwgaSlcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXkgKz0gY2h1bmsubGF0aW4xU2xpY2UodGhpcy5fbGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MgPSArK2k7XG4gICAgICAgICAgICAgIHRoaXMuX2tleSA9IHRoaXMuX2RlY29kZXIodGhpcy5fa2V5LCB0aGlzLl9lbmNvZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9lbmNvZGUgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9pbktleSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb250aW51ZSBtYWluO1xuICAgICAgICAgICAgY2FzZSAzODogLy8gJyYnXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UG9zIDwgaSlcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXkgKz0gY2h1bmsubGF0aW4xU2xpY2UodGhpcy5fbGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MgPSArK2k7XG4gICAgICAgICAgICAgIHRoaXMuX2tleSA9IHRoaXMuX2RlY29kZXIodGhpcy5fa2V5LCB0aGlzLl9lbmNvZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9lbmNvZGUgPSAwO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYnl0ZXNLZXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFxuICAgICAgICAgICAgICAgICAgJ2ZpZWxkJyxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSxcbiAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgeyBuYW1lVHJ1bmNhdGVkOiB0aGlzLl9rZXlUcnVuYyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUcnVuY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogdGhpcy5jaGFyc2V0LFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2tleSA9ICcnO1xuICAgICAgICAgICAgICB0aGlzLl92YWwgPSAnJztcbiAgICAgICAgICAgICAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsVHJ1bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fYnl0ZXNLZXkgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9ieXRlc1ZhbCA9IDA7XG4gICAgICAgICAgICAgIGlmICgrK3RoaXMuX2ZpZWxkcyA+PSB0aGlzLmZpZWxkc0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWVsZHNMaW1pdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSA0MzogLy8gJysnXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UG9zIDwgaSlcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXkgKz0gY2h1bmsubGF0aW4xU2xpY2UodGhpcy5fbGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIHRoaXMuX2tleSArPSAnICc7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM3OiAvLyAnJSdcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuY29kZSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGUgPSAxO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdFBvcyA8IGkpXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5ICs9IGNodW5rLmxhdGluMVNsaWNlKHRoaXMuX2xhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICB0aGlzLl9sYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgIHRoaXMuX2J5dGUgPSAtMTtcbiAgICAgICAgICAgICAgaSA9IHJlYWRQY3RFbmModGhpcywgY2h1bmssIGkgKyAxLCBsZW4pO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTWFsZm9ybWVkIHVybGVuY29kZWQgZm9ybScpKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICArK3RoaXMuX2J5dGVzS2V5O1xuICAgICAgICAgICAgICBpID0gc2tpcEtleUJ5dGVzKHRoaXMsIGNodW5rLCBpLCBsZW4pO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgICsrdGhpcy5fYnl0ZXNLZXk7XG4gICAgICAgICAgaSA9IHNraXBLZXlCeXRlcyh0aGlzLCBjaHVuaywgaSwgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFzdFBvcyA8IGkpXG4gICAgICAgICAgdGhpcy5fa2V5ICs9IGNodW5rLmxhdGluMVNsaWNlKHRoaXMuX2xhc3RQb3MsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFyc2luZyB2YWx1ZVxuXG4gICAgICAgIGkgPSBza2lwVmFsQnl0ZXModGhpcywgY2h1bmssIGksIGxlbik7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rW2ldKSB7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAnJidcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQb3MgPCBpKVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbCArPSBjaHVuay5sYXRpbjFTbGljZSh0aGlzLl9sYXN0UG9zLCBpKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFBvcyA9ICsraTtcbiAgICAgICAgICAgICAgdGhpcy5faW5LZXkgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLl92YWwgPSB0aGlzLl9kZWNvZGVyKHRoaXMuX3ZhbCwgdGhpcy5fZW5jb2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlID0gMDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2J5dGVzS2V5ID4gMCB8fCB0aGlzLl9ieXRlc1ZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgICAgICAgICAnZmllbGQnLFxuICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5LFxuICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsLFxuICAgICAgICAgICAgICAgICAgeyBuYW1lVHJ1bmNhdGVkOiB0aGlzLl9rZXlUcnVuYyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUcnVuY2F0ZWQ6IHRoaXMuX3ZhbFRydW5jLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogdGhpcy5jaGFyc2V0LFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2tleSA9ICcnO1xuICAgICAgICAgICAgICB0aGlzLl92YWwgPSAnJztcbiAgICAgICAgICAgICAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsVHJ1bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fYnl0ZXNLZXkgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9ieXRlc1ZhbCA9IDA7XG4gICAgICAgICAgICAgIGlmICgrK3RoaXMuX2ZpZWxkcyA+PSB0aGlzLmZpZWxkc0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWVsZHNMaW1pdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG1haW47XG4gICAgICAgICAgICBjYXNlIDQzOiAvLyAnKydcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQb3MgPCBpKVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbCArPSBjaHVuay5sYXRpbjFTbGljZSh0aGlzLl9sYXN0UG9zLCBpKTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsICs9ICcgJztcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vICclJ1xuICAgICAgICAgICAgICBpZiAodGhpcy5fZW5jb2RlID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZSA9IDE7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UG9zIDwgaSlcbiAgICAgICAgICAgICAgICB0aGlzLl92YWwgKz0gY2h1bmsubGF0aW4xU2xpY2UodGhpcy5fbGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgdGhpcy5fYnl0ZSA9IC0xO1xuICAgICAgICAgICAgICBpID0gcmVhZFBjdEVuYyh0aGlzLCBjaHVuaywgaSArIDEsIGxlbik7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdNYWxmb3JtZWQgdXJsZW5jb2RlZCBmb3JtJykpO1xuICAgICAgICAgICAgICBpZiAoaSA+PSBsZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICAgICsrdGhpcy5fYnl0ZXNWYWw7XG4gICAgICAgICAgICAgIGkgPSBza2lwVmFsQnl0ZXModGhpcywgY2h1bmssIGksIGxlbik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgKyt0aGlzLl9ieXRlc1ZhbDtcbiAgICAgICAgICBpID0gc2tpcFZhbEJ5dGVzKHRoaXMsIGNodW5rLCBpLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UG9zIDwgaSlcbiAgICAgICAgICB0aGlzLl92YWwgKz0gY2h1bmsubGF0aW4xU2xpY2UodGhpcy5fbGFzdFBvcywgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2IoKTtcbiAgfVxuXG4gIF9maW5hbChjYikge1xuICAgIGlmICh0aGlzLl9ieXRlICE9PSAtMilcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ01hbGZvcm1lZCB1cmxlbmNvZGVkIGZvcm0nKSk7XG4gICAgaWYgKCF0aGlzLl9pbktleSB8fCB0aGlzLl9ieXRlc0tleSA+IDAgfHwgdGhpcy5fYnl0ZXNWYWwgPiAwKSB7XG4gICAgICBpZiAodGhpcy5faW5LZXkpXG4gICAgICAgIHRoaXMuX2tleSA9IHRoaXMuX2RlY29kZXIodGhpcy5fa2V5LCB0aGlzLl9lbmNvZGUpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl92YWwgPSB0aGlzLl9kZWNvZGVyKHRoaXMuX3ZhbCwgdGhpcy5fZW5jb2RlKTtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgJ2ZpZWxkJyxcbiAgICAgICAgdGhpcy5fa2V5LFxuICAgICAgICB0aGlzLl92YWwsXG4gICAgICAgIHsgbmFtZVRydW5jYXRlZDogdGhpcy5fa2V5VHJ1bmMsXG4gICAgICAgICAgdmFsdWVUcnVuY2F0ZWQ6IHRoaXMuX3ZhbFRydW5jLFxuICAgICAgICAgIGVuY29kaW5nOiB0aGlzLmNoYXJzZXQsXG4gICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyB9XG4gICAgICApO1xuICAgIH1cbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRQY3RFbmMoc2VsZiwgY2h1bmssIHBvcywgbGVuKSB7XG4gIGlmIChwb3MgPj0gbGVuKVxuICAgIHJldHVybiBsZW47XG5cbiAgaWYgKHNlbGYuX2J5dGUgPT09IC0xKSB7XG4gICAgLy8gV2Ugc2F3IGEgJyUnIGJ1dCBubyBoZXggY2hhcmFjdGVycyB5ZXRcbiAgICBjb25zdCBoZXhVcHBlciA9IEhFWF9WQUxVRVNbY2h1bmtbcG9zKytdXTtcbiAgICBpZiAoaGV4VXBwZXIgPT09IC0xKVxuICAgICAgcmV0dXJuIC0xO1xuXG4gICAgaWYgKGhleFVwcGVyID49IDgpXG4gICAgICBzZWxmLl9lbmNvZGUgPSAyOyAvLyBJbmRpY2F0ZSBoaWdoIGJpdHMgZGV0ZWN0ZWRcblxuICAgIGlmIChwb3MgPCBsZW4pIHtcbiAgICAgIC8vIEJvdGggaGV4IGNoYXJhY3RlcnMgYXJlIGluIHRoaXMgY2h1bmtcbiAgICAgIGNvbnN0IGhleExvd2VyID0gSEVYX1ZBTFVFU1tjaHVua1twb3MrK11dO1xuICAgICAgaWYgKGhleExvd2VyID09PSAtMSlcbiAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICBpZiAoc2VsZi5faW5LZXkpXG4gICAgICAgIHNlbGYuX2tleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChoZXhVcHBlciA8PCA0KSArIGhleExvd2VyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5fdmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGhleFVwcGVyIDw8IDQpICsgaGV4TG93ZXIpO1xuXG4gICAgICBzZWxmLl9ieXRlID0gLTI7XG4gICAgICBzZWxmLl9sYXN0UG9zID0gcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IG9uZSBoZXggY2hhcmFjdGVyIHdhcyBhdmFpbGFibGUgaW4gdGhpcyBjaHVua1xuICAgICAgc2VsZi5fYnl0ZSA9IGhleFVwcGVyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBzYXcgb25seSBvbmUgaGV4IGNoYXJhY3RlciBzbyBmYXJcbiAgICBjb25zdCBoZXhMb3dlciA9IEhFWF9WQUxVRVNbY2h1bmtbcG9zKytdXTtcbiAgICBpZiAoaGV4TG93ZXIgPT09IC0xKVxuICAgICAgcmV0dXJuIC0xO1xuXG4gICAgaWYgKHNlbGYuX2luS2V5KVxuICAgICAgc2VsZi5fa2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHNlbGYuX2J5dGUgPDwgNCkgKyBoZXhMb3dlcik7XG4gICAgZWxzZVxuICAgICAgc2VsZi5fdmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHNlbGYuX2J5dGUgPDwgNCkgKyBoZXhMb3dlcik7XG5cbiAgICBzZWxmLl9ieXRlID0gLTI7XG4gICAgc2VsZi5fbGFzdFBvcyA9IHBvcztcbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIHNraXBLZXlCeXRlcyhzZWxmLCBjaHVuaywgcG9zLCBsZW4pIHtcbiAgLy8gU2tpcCBieXRlcyBpZiB3ZSd2ZSB0cnVuY2F0ZWRcbiAgaWYgKHNlbGYuX2J5dGVzS2V5ID4gc2VsZi5maWVsZE5hbWVTaXplTGltaXQpIHtcbiAgICBpZiAoIXNlbGYuX2tleVRydW5jKSB7XG4gICAgICBpZiAoc2VsZi5fbGFzdFBvcyA8IHBvcylcbiAgICAgICAgc2VsZi5fa2V5ICs9IGNodW5rLmxhdGluMVNsaWNlKHNlbGYuX2xhc3RQb3MsIHBvcyAtIDEpO1xuICAgIH1cbiAgICBzZWxmLl9rZXlUcnVuYyA9IHRydWU7XG4gICAgZm9yICg7IHBvcyA8IGxlbjsgKytwb3MpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaHVua1twb3NdO1xuICAgICAgaWYgKGNvZGUgPT09IDYxLyogJz0nICovIHx8IGNvZGUgPT09IDM4LyogJyYnICovKVxuICAgICAgICBicmVhaztcbiAgICAgICsrc2VsZi5fYnl0ZXNLZXk7XG4gICAgfVxuICAgIHNlbGYuX2xhc3RQb3MgPSBwb3M7XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBza2lwVmFsQnl0ZXMoc2VsZiwgY2h1bmssIHBvcywgbGVuKSB7XG4gIC8vIFNraXAgYnl0ZXMgaWYgd2UndmUgdHJ1bmNhdGVkXG4gIGlmIChzZWxmLl9ieXRlc1ZhbCA+IHNlbGYuZmllbGRTaXplTGltaXQpIHtcbiAgICBpZiAoIXNlbGYuX3ZhbFRydW5jKSB7XG4gICAgICBpZiAoc2VsZi5fbGFzdFBvcyA8IHBvcylcbiAgICAgICAgc2VsZi5fdmFsICs9IGNodW5rLmxhdGluMVNsaWNlKHNlbGYuX2xhc3RQb3MsIHBvcyAtIDEpO1xuICAgIH1cbiAgICBzZWxmLl92YWxUcnVuYyA9IHRydWU7XG4gICAgZm9yICg7IHBvcyA8IGxlbjsgKytwb3MpIHtcbiAgICAgIGlmIChjaHVua1twb3NdID09PSAzOC8qICcmJyAqLylcbiAgICAgICAgYnJlYWs7XG4gICAgICArK3NlbGYuX2J5dGVzVmFsO1xuICAgIH1cbiAgICBzZWxmLl9sYXN0UG9zID0gcG9zO1xuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzICovXG5jb25zdCBIRVhfVkFMVUVTID0gW1xuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbl07XG4vKiBlc2xpbnQtZW5hYmxlIG5vLW11bHRpLXNwYWNlcyAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTEVuY29kZWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js":
/*!***************************************************************************!*\
  !*** ../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js ***!
  \***************************************************************************/
/***/ (function(module) {

eval("\n\nfunction parseContentType(str) {\n  if (str.length === 0)\n    return;\n\n  const params = Object.create(null);\n  let i = 0;\n\n  // Parse type\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      if (code !== 47/* '/' */ || i === 0)\n        return;\n      break;\n    }\n  }\n  // Check for type without subtype\n  if (i === str.length)\n    return;\n\n  const type = str.slice(0, i).toLowerCase();\n\n  // Parse subtype\n  const subtypeStart = ++i;\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      // Make sure we have a subtype\n      if (i === subtypeStart)\n        return;\n\n      if (parseContentTypeParams(str, i, params) === undefined)\n        return;\n      break;\n    }\n  }\n  // Make sure we have a subtype\n  if (i === subtypeStart)\n    return;\n\n  const subtype = str.slice(subtypeStart, i).toLowerCase();\n\n  return { type, subtype, params };\n}\n\nfunction parseContentTypeParams(str, i, params) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace\n    if (i === str.length)\n      break;\n\n    // Check for malformed parameter\n    if (str.charCodeAt(i++) !== 59/* ';' */)\n      return;\n\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace (malformed)\n    if (i === str.length)\n      return;\n\n    let name;\n    const nameStart = i;\n    // Parse parameter name\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (TOKEN[code] !== 1) {\n        if (code !== 61/* '=' */)\n          return;\n        break;\n      }\n    }\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    name = str.slice(nameStart, i);\n    ++i; // Skip over '='\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    let value = '';\n    let valueStart;\n    if (str.charCodeAt(i) === 34/* '\"' */) {\n      valueStart = ++i;\n      let escaping = false;\n      // Parse quoted value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code === 92/* '\\\\' */) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n          } else {\n            value += str.slice(valueStart, i);\n            escaping = true;\n          }\n          continue;\n        }\n        if (code === 34/* '\"' */) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n            continue;\n          }\n          value += str.slice(valueStart, i);\n          break;\n        }\n        if (escaping) {\n          valueStart = i - 1;\n          escaping = false;\n        }\n        // Invalid unescaped quoted character (malformed)\n        if (QDTEXT[code] !== 1)\n          return;\n      }\n\n      // No end quote (malformed)\n      if (i === str.length)\n        return;\n\n      ++i; // Skip over double quote\n    } else {\n      valueStart = i;\n      // Parse unquoted value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (TOKEN[code] !== 1) {\n          // No value (malformed)\n          if (i === valueStart)\n            return;\n          break;\n        }\n      }\n      value = str.slice(valueStart, i);\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined)\n      params[name] = value;\n  }\n\n  return params;\n}\n\nfunction parseDisposition(str, defDecoder) {\n  if (str.length === 0)\n    return;\n\n  const params = Object.create(null);\n  let i = 0;\n\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      if (parseDispositionParams(str, i, params, defDecoder) === undefined)\n        return;\n      break;\n    }\n  }\n\n  const type = str.slice(0, i).toLowerCase();\n\n  return { type, params };\n}\n\nfunction parseDispositionParams(str, i, params, defDecoder) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace\n    if (i === str.length)\n      break;\n\n    // Check for malformed parameter\n    if (str.charCodeAt(i++) !== 59/* ';' */)\n      return;\n\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace (malformed)\n    if (i === str.length)\n      return;\n\n    let name;\n    const nameStart = i;\n    // Parse parameter name\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (TOKEN[code] !== 1) {\n        if (code === 61/* '=' */)\n          break;\n        return;\n      }\n    }\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    let value = '';\n    let valueStart;\n    let charset;\n    //~ let lang;\n    name = str.slice(nameStart, i);\n    if (name.charCodeAt(name.length - 1) === 42/* '*' */) {\n      // Extended value\n\n      const charsetStart = ++i;\n      // Parse charset name\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (CHARSET[code] !== 1) {\n          if (code !== 39/* '\\'' */)\n            return;\n          break;\n        }\n      }\n\n      // Incomplete charset (malformed)\n      if (i === str.length)\n        return;\n\n      charset = str.slice(charsetStart, i);\n      ++i; // Skip over the '\\''\n\n      //~ const langStart = ++i;\n      // Parse language name\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code === 39/* '\\'' */)\n          break;\n      }\n\n      // Incomplete language (malformed)\n      if (i === str.length)\n        return;\n\n      //~ lang = str.slice(langStart, i);\n      ++i; // Skip over the '\\''\n\n      // No value (malformed)\n      if (i === str.length)\n        return;\n\n      valueStart = i;\n\n      let encode = 0;\n      // Parse value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (EXTENDED_VALUE[code] !== 1) {\n          if (code === 37/* '%' */) {\n            let hexUpper;\n            let hexLower;\n            if (i + 2 < str.length\n                && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1\n                && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {\n              const byteVal = (hexUpper << 4) + hexLower;\n              value += str.slice(valueStart, i);\n              value += String.fromCharCode(byteVal);\n              i += 2;\n              valueStart = i + 1;\n              if (byteVal >= 128)\n                encode = 2;\n              else if (encode === 0)\n                encode = 1;\n              continue;\n            }\n            // '%' disallowed in non-percent encoded contexts (malformed)\n            return;\n          }\n          break;\n        }\n      }\n\n      value += str.slice(valueStart, i);\n      value = convertToUTF8(value, charset, encode);\n      if (value === undefined)\n        return;\n    } else {\n      // Non-extended value\n\n      ++i; // Skip over '='\n\n      // No value (malformed)\n      if (i === str.length)\n        return;\n\n      if (str.charCodeAt(i) === 34/* '\"' */) {\n        valueStart = ++i;\n        let escaping = false;\n        // Parse quoted value\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n          if (code === 92/* '\\\\' */) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n            } else {\n              value += str.slice(valueStart, i);\n              escaping = true;\n            }\n            continue;\n          }\n          if (code === 34/* '\"' */) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n              continue;\n            }\n            value += str.slice(valueStart, i);\n            break;\n          }\n          if (escaping) {\n            valueStart = i - 1;\n            escaping = false;\n          }\n          // Invalid unescaped quoted character (malformed)\n          if (QDTEXT[code] !== 1)\n            return;\n        }\n\n        // No end quote (malformed)\n        if (i === str.length)\n          return;\n\n        ++i; // Skip over double quote\n      } else {\n        valueStart = i;\n        // Parse unquoted value\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n          if (TOKEN[code] !== 1) {\n            // No value (malformed)\n            if (i === valueStart)\n              return;\n            break;\n          }\n        }\n        value = str.slice(valueStart, i);\n      }\n\n      value = defDecoder(value, 2);\n      if (value === undefined)\n        return;\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined)\n      params[name] = value;\n  }\n\n  return params;\n}\n\nfunction getDecoder(charset) {\n  let lc;\n  while (true) {\n    switch (charset) {\n      case 'utf-8':\n      case 'utf8':\n        return decoders.utf8;\n      case 'latin1':\n      case 'ascii': // TODO: Make these a separate, strict decoder?\n      case 'us-ascii':\n      case 'iso-8859-1':\n      case 'iso8859-1':\n      case 'iso88591':\n      case 'iso_8859-1':\n      case 'windows-1252':\n      case 'iso_8859-1:1987':\n      case 'cp1252':\n      case 'x-cp1252':\n        return decoders.latin1;\n      case 'utf16le':\n      case 'utf-16le':\n      case 'ucs2':\n      case 'ucs-2':\n        return decoders.utf16le;\n      case 'base64':\n        return decoders.base64;\n      default:\n        if (lc === undefined) {\n          lc = true;\n          charset = charset.toLowerCase();\n          continue;\n        }\n        return decoders.other.bind(charset);\n    }\n  }\n}\n\nconst decoders = {\n  utf8: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string') {\n      // If `data` never had any percent-encoded bytes or never had any that\n      // were outside of the ASCII range, then we can safely just return the\n      // input since UTF-8 is ASCII compatible\n      if (hint < 2)\n        return data;\n\n      data = Buffer.from(data, 'latin1');\n    }\n    return data.utf8Slice(0, data.length);\n  },\n\n  latin1: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      return data;\n    return data.latin1Slice(0, data.length);\n  },\n\n  utf16le: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    return data.ucs2Slice(0, data.length);\n  },\n\n  base64: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    return data.base64Slice(0, data.length);\n  },\n\n  other: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    try {\n      const decoder = new TextDecoder(this);\n      return decoder.decode(data);\n    } catch {}\n  },\n};\n\nfunction convertToUTF8(data, charset, hint) {\n  const decode = getDecoder(charset);\n  if (decode)\n    return decode(data, hint);\n}\n\nfunction basename(path) {\n  if (typeof path !== 'string')\n    return '';\n  for (let i = path.length - 1; i >= 0; --i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2F: // '/'\n      case 0x5C: // '\\'\n        path = path.slice(i + 1);\n        return (path === '..' || path === '.' ? '' : path);\n    }\n  }\n  return (path === '..' || path === '.' ? '' : path);\n}\n\nconst TOKEN = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst QDTEXT = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\nconst CHARSET = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst EXTENDED_VALUE = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\n/* eslint-disable no-multi-spaces */\nconst HEX_VALUES = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2J1c2JveUAxLjYuMC9ub2RlX21vZHVsZXMvYnVzYm95L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1gsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsUUFBUTtBQUNSO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wYXVsL3Byb2plY3RzL3BheWxvYWQvcGx1Z2luLWRldmVsb3BtZW50L2JldHRlci1maWVsZHMvZ2l0cm9vdC9ub2RlX21vZHVsZXMvLnBucG0vYnVzYm95QDEuNi4wL25vZGVfbW9kdWxlcy9idXNib3kvbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcGFyc2VDb250ZW50VHlwZShzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBpID0gMDtcblxuICAvLyBQYXJzZSB0eXBlXG4gIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChUT0tFTltjb2RlXSAhPT0gMSkge1xuICAgICAgaWYgKGNvZGUgIT09IDQ3LyogJy8nICovIHx8IGkgPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgdHlwZSB3aXRob3V0IHN1YnR5cGVcbiAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgcmV0dXJuO1xuXG4gIGNvbnN0IHR5cGUgPSBzdHIuc2xpY2UoMCwgaSkudG9Mb3dlckNhc2UoKTtcblxuICAvLyBQYXJzZSBzdWJ0eXBlXG4gIGNvbnN0IHN1YnR5cGVTdGFydCA9ICsraTtcbiAgZm9yICg7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKFRPS0VOW2NvZGVdICE9PSAxKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN1YnR5cGVcbiAgICAgIGlmIChpID09PSBzdWJ0eXBlU3RhcnQpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHBhcnNlQ29udGVudFR5cGVQYXJhbXMoc3RyLCBpLCBwYXJhbXMpID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN1YnR5cGVcbiAgaWYgKGkgPT09IHN1YnR5cGVTdGFydClcbiAgICByZXR1cm47XG5cbiAgY29uc3Qgc3VidHlwZSA9IHN0ci5zbGljZShzdWJ0eXBlU3RhcnQsIGkpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHsgdHlwZSwgc3VidHlwZSwgcGFyYW1zIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGVQYXJhbXMoc3RyLCBpLCBwYXJhbXMpIHtcbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgLy8gQ29uc3VtZSB3aGl0ZXNwYWNlXG4gICAgZm9yICg7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlICE9PSAzMi8qICcgJyAqLyAmJiBjb2RlICE9PSA5LyogJ1xcdCcgKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEVuZGVkIG9uIHdoaXRlc3BhY2VcbiAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBwYXJhbWV0ZXJcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSsrKSAhPT0gNTkvKiAnOycgKi8pXG4gICAgICByZXR1cm47XG5cbiAgICAvLyBDb25zdW1lIHdoaXRlc3BhY2VcbiAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgIT09IDMyLyogJyAnICovICYmIGNvZGUgIT09IDkvKiAnXFx0JyAqLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRW5kZWQgb24gd2hpdGVzcGFjZSAobWFsZm9ybWVkKVxuICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgbGV0IG5hbWU7XG4gICAgY29uc3QgbmFtZVN0YXJ0ID0gaTtcbiAgICAvLyBQYXJzZSBwYXJhbWV0ZXIgbmFtZVxuICAgIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoVE9LRU5bY29kZV0gIT09IDEpIHtcbiAgICAgICAgaWYgKGNvZGUgIT09IDYxLyogJz0nICovKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmFsdWUgKG1hbGZvcm1lZClcbiAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIG5hbWUgPSBzdHIuc2xpY2UobmFtZVN0YXJ0LCBpKTtcbiAgICArK2k7IC8vIFNraXAgb3ZlciAnPSdcblxuICAgIC8vIE5vIHZhbHVlIChtYWxmb3JtZWQpXG4gICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgdmFsdWVTdGFydDtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPT09IDM0LyogJ1wiJyAqLykge1xuICAgICAgdmFsdWVTdGFydCA9ICsraTtcbiAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgLy8gUGFyc2UgcXVvdGVkIHZhbHVlXG4gICAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA5Mi8qICdcXFxcJyAqLykge1xuICAgICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgICAgdmFsdWVTdGFydCA9IGk7XG4gICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgaSk7XG4gICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID09PSAzNC8qICdcIicgKi8pIHtcbiAgICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBpO1xuICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSArPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgdmFsdWVTdGFydCA9IGkgLSAxO1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZCB1bmVzY2FwZWQgcXVvdGVkIGNoYXJhY3RlciAobWFsZm9ybWVkKVxuICAgICAgICBpZiAoUURURVhUW2NvZGVdICE9PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gZW5kIHF1b3RlIChtYWxmb3JtZWQpXG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICArK2k7IC8vIFNraXAgb3ZlciBkb3VibGUgcXVvdGVcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVTdGFydCA9IGk7XG4gICAgICAvLyBQYXJzZSB1bnF1b3RlZCB2YWx1ZVxuICAgICAgZm9yICg7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoVE9LRU5bY29kZV0gIT09IDEpIHtcbiAgICAgICAgICAvLyBObyB2YWx1ZSAobWFsZm9ybWVkKVxuICAgICAgICAgIGlmIChpID09PSB2YWx1ZVN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHN0ci5zbGljZSh2YWx1ZVN0YXJ0LCBpKTtcbiAgICB9XG5cbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VEaXNwb3NpdGlvbihzdHIsIGRlZkRlY29kZXIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoVE9LRU5bY29kZV0gIT09IDEpIHtcbiAgICAgIGlmIChwYXJzZURpc3Bvc2l0aW9uUGFyYW1zKHN0ciwgaSwgcGFyYW1zLCBkZWZEZWNvZGVyKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCB0eXBlID0gc3RyLnNsaWNlKDAsIGkpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHsgdHlwZSwgcGFyYW1zIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGlzcG9zaXRpb25QYXJhbXMoc3RyLCBpLCBwYXJhbXMsIGRlZkRlY29kZXIpIHtcbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgLy8gQ29uc3VtZSB3aGl0ZXNwYWNlXG4gICAgZm9yICg7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlICE9PSAzMi8qICcgJyAqLyAmJiBjb2RlICE9PSA5LyogJ1xcdCcgKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEVuZGVkIG9uIHdoaXRlc3BhY2VcbiAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBwYXJhbWV0ZXJcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSsrKSAhPT0gNTkvKiAnOycgKi8pXG4gICAgICByZXR1cm47XG5cbiAgICAvLyBDb25zdW1lIHdoaXRlc3BhY2VcbiAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgIT09IDMyLyogJyAnICovICYmIGNvZGUgIT09IDkvKiAnXFx0JyAqLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRW5kZWQgb24gd2hpdGVzcGFjZSAobWFsZm9ybWVkKVxuICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgbGV0IG5hbWU7XG4gICAgY29uc3QgbmFtZVN0YXJ0ID0gaTtcbiAgICAvLyBQYXJzZSBwYXJhbWV0ZXIgbmFtZVxuICAgIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoVE9LRU5bY29kZV0gIT09IDEpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDYxLyogJz0nICovKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmFsdWUgKG1hbGZvcm1lZClcbiAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCB2YWx1ZVN0YXJ0O1xuICAgIGxldCBjaGFyc2V0O1xuICAgIC8vfiBsZXQgbGFuZztcbiAgICBuYW1lID0gc3RyLnNsaWNlKG5hbWVTdGFydCwgaSk7XG4gICAgaWYgKG5hbWUuY2hhckNvZGVBdChuYW1lLmxlbmd0aCAtIDEpID09PSA0Mi8qICcqJyAqLykge1xuICAgICAgLy8gRXh0ZW5kZWQgdmFsdWVcblxuICAgICAgY29uc3QgY2hhcnNldFN0YXJ0ID0gKytpO1xuICAgICAgLy8gUGFyc2UgY2hhcnNldCBuYW1lXG4gICAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChDSEFSU0VUW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgaWYgKGNvZGUgIT09IDM5LyogJ1xcJycgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5jb21wbGV0ZSBjaGFyc2V0IChtYWxmb3JtZWQpXG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjaGFyc2V0ID0gc3RyLnNsaWNlKGNoYXJzZXRTdGFydCwgaSk7XG4gICAgICArK2k7IC8vIFNraXAgb3ZlciB0aGUgJ1xcJydcblxuICAgICAgLy9+IGNvbnN0IGxhbmdTdGFydCA9ICsraTtcbiAgICAgIC8vIFBhcnNlIGxhbmd1YWdlIG5hbWVcbiAgICAgIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDM5LyogJ1xcJycgKi8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEluY29tcGxldGUgbGFuZ3VhZ2UgKG1hbGZvcm1lZClcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vfiBsYW5nID0gc3RyLnNsaWNlKGxhbmdTdGFydCwgaSk7XG4gICAgICArK2k7IC8vIFNraXAgb3ZlciB0aGUgJ1xcJydcblxuICAgICAgLy8gTm8gdmFsdWUgKG1hbGZvcm1lZClcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhbHVlU3RhcnQgPSBpO1xuXG4gICAgICBsZXQgZW5jb2RlID0gMDtcbiAgICAgIC8vIFBhcnNlIHZhbHVlXG4gICAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChFWFRFTkRFRF9WQUxVRVtjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIGlmIChjb2RlID09PSAzNy8qICclJyAqLykge1xuICAgICAgICAgICAgbGV0IGhleFVwcGVyO1xuICAgICAgICAgICAgbGV0IGhleExvd2VyO1xuICAgICAgICAgICAgaWYgKGkgKyAyIDwgc3RyLmxlbmd0aFxuICAgICAgICAgICAgICAgICYmIChoZXhVcHBlciA9IEhFWF9WQUxVRVNbc3RyLmNoYXJDb2RlQXQoaSArIDEpXSkgIT09IC0xXG4gICAgICAgICAgICAgICAgJiYgKGhleExvd2VyID0gSEVYX1ZBTFVFU1tzdHIuY2hhckNvZGVBdChpICsgMildKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgYnl0ZVZhbCA9IChoZXhVcHBlciA8PCA0KSArIGhleExvd2VyO1xuICAgICAgICAgICAgICB2YWx1ZSArPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgaSk7XG4gICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZVZhbCk7XG4gICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBpZiAoYnl0ZVZhbCA+PSAxMjgpXG4gICAgICAgICAgICAgICAgZW5jb2RlID0gMjtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZW5jb2RlID09PSAwKVxuICAgICAgICAgICAgICAgIGVuY29kZSA9IDE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJyUnIGRpc2FsbG93ZWQgaW4gbm9uLXBlcmNlbnQgZW5jb2RlZCBjb250ZXh0cyAobWFsZm9ybWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSArPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgaSk7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRUb1VURjgodmFsdWUsIGNoYXJzZXQsIGVuY29kZSk7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb24tZXh0ZW5kZWQgdmFsdWVcblxuICAgICAgKytpOyAvLyBTa2lwIG92ZXIgJz0nXG5cbiAgICAgIC8vIE5vIHZhbHVlIChtYWxmb3JtZWQpXG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPT09IDM0LyogJ1wiJyAqLykge1xuICAgICAgICB2YWx1ZVN0YXJ0ID0gKytpO1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gUGFyc2UgcXVvdGVkIHZhbHVlXG4gICAgICAgIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGlmIChjb2RlID09PSA5Mi8qICdcXFxcJyAqLykge1xuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgKz0gc3RyLnNsaWNlKHZhbHVlU3RhcnQsIGkpO1xuICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDM0LyogJ1wiJyAqLykge1xuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IHN0ci5zbGljZSh2YWx1ZVN0YXJ0LCBpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBpIC0gMTtcbiAgICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEludmFsaWQgdW5lc2NhcGVkIHF1b3RlZCBjaGFyYWN0ZXIgKG1hbGZvcm1lZClcbiAgICAgICAgICBpZiAoUURURVhUW2NvZGVdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gZW5kIHF1b3RlIChtYWxmb3JtZWQpXG4gICAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICArK2k7IC8vIFNraXAgb3ZlciBkb3VibGUgcXVvdGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlU3RhcnQgPSBpO1xuICAgICAgICAvLyBQYXJzZSB1bnF1b3RlZCB2YWx1ZVxuICAgICAgICBmb3IgKDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBpZiAoVE9LRU5bY29kZV0gIT09IDEpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbHVlIChtYWxmb3JtZWQpXG4gICAgICAgICAgICBpZiAoaSA9PT0gdmFsdWVTdGFydClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gc3RyLnNsaWNlKHZhbHVlU3RhcnQsIGkpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGRlZkRlY29kZXIodmFsdWUsIDIpO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVjb2RlcihjaGFyc2V0KSB7XG4gIGxldCBsYztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGNoYXJzZXQpIHtcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICByZXR1cm4gZGVjb2RlcnMudXRmODtcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdhc2NpaSc6IC8vIFRPRE86IE1ha2UgdGhlc2UgYSBzZXBhcmF0ZSwgc3RyaWN0IGRlY29kZXI/XG4gICAgICBjYXNlICd1cy1hc2NpaSc6XG4gICAgICBjYXNlICdpc28tODg1OS0xJzpcbiAgICAgIGNhc2UgJ2lzbzg4NTktMSc6XG4gICAgICBjYXNlICdpc284ODU5MSc6XG4gICAgICBjYXNlICdpc29fODg1OS0xJzpcbiAgICAgIGNhc2UgJ3dpbmRvd3MtMTI1Mic6XG4gICAgICBjYXNlICdpc29fODg1OS0xOjE5ODcnOlxuICAgICAgY2FzZSAnY3AxMjUyJzpcbiAgICAgIGNhc2UgJ3gtY3AxMjUyJzpcbiAgICAgICAgcmV0dXJuIGRlY29kZXJzLmxhdGluMTtcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIHJldHVybiBkZWNvZGVycy51dGYxNmxlO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGRlY29kZXJzLmJhc2U2NDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGMgPSB0cnVlO1xuICAgICAgICAgIGNoYXJzZXQgPSBjaGFyc2V0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZXJzLm90aGVyLmJpbmQoY2hhcnNldCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlY29kZXJzID0ge1xuICB1dGY4OiAoZGF0YSwgaGludCkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiBgZGF0YWAgbmV2ZXIgaGFkIGFueSBwZXJjZW50LWVuY29kZWQgYnl0ZXMgb3IgbmV2ZXIgaGFkIGFueSB0aGF0XG4gICAgICAvLyB3ZXJlIG91dHNpZGUgb2YgdGhlIEFTQ0lJIHJhbmdlLCB0aGVuIHdlIGNhbiBzYWZlbHkganVzdCByZXR1cm4gdGhlXG4gICAgICAvLyBpbnB1dCBzaW5jZSBVVEYtOCBpcyBBU0NJSSBjb21wYXRpYmxlXG4gICAgICBpZiAoaGludCA8IDIpXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2xhdGluMScpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS51dGY4U2xpY2UoMCwgZGF0YS5sZW5ndGgpO1xuICB9LFxuXG4gIGxhdGluMTogKGRhdGEsIGhpbnQpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIHJldHVybiBkYXRhLmxhdGluMVNsaWNlKDAsIGRhdGEubGVuZ3RoKTtcbiAgfSxcblxuICB1dGYxNmxlOiAoZGF0YSwgaGludCkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdsYXRpbjEnKTtcbiAgICByZXR1cm4gZGF0YS51Y3MyU2xpY2UoMCwgZGF0YS5sZW5ndGgpO1xuICB9LFxuXG4gIGJhc2U2NDogKGRhdGEsIGhpbnQpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAnbGF0aW4xJyk7XG4gICAgcmV0dXJuIGRhdGEuYmFzZTY0U2xpY2UoMCwgZGF0YS5sZW5ndGgpO1xuICB9LFxuXG4gIG90aGVyOiAoZGF0YSwgaGludCkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdsYXRpbjEnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2Rlcih0aGlzKTtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGNhdGNoIHt9XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9VVEY4KGRhdGEsIGNoYXJzZXQsIGhpbnQpIHtcbiAgY29uc3QgZGVjb2RlID0gZ2V0RGVjb2RlcihjaGFyc2V0KTtcbiAgaWYgKGRlY29kZSlcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEsIGhpbnQpO1xufVxuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuICcnO1xuICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHN3aXRjaCAocGF0aC5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIDB4MkY6IC8vICcvJ1xuICAgICAgY2FzZSAweDVDOiAvLyAnXFwnXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgcmV0dXJuIChwYXRoID09PSAnLi4nIHx8IHBhdGggPT09ICcuJyA/ICcnIDogcGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAocGF0aCA9PT0gJy4uJyB8fCBwYXRoID09PSAnLicgPyAnJyA6IHBhdGgpO1xufVxuXG5jb25zdCBUT0tFTiA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbl07XG5cbmNvbnN0IFFEVEVYVCA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMSwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbl07XG5cbmNvbnN0IENIQVJTRVQgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDAsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG5dO1xuXG5jb25zdCBFWFRFTkRFRF9WQUxVRSA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMSwgMSwgMCxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbl07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcyAqL1xuY29uc3QgSEVYX1ZBTFVFUyA9IFtcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG5dO1xuLyogZXNsaW50LWVuYWJsZSBuby1tdWx0aS1zcGFjZXMgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJhc2VuYW1lLFxuICBjb252ZXJ0VG9VVEY4LFxuICBnZXREZWNvZGVyLFxuICBwYXJzZUNvbnRlbnRUeXBlLFxuICBwYXJzZURpc3Bvc2l0aW9uLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js\n");

/***/ })

};
;