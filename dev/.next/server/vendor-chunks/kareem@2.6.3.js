"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kareem@2.6.3";
exports.ids = ["vendor-chunks/kareem@2.6.3"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Optional arguments or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPre = function(name, context, args, callback) {\n  if (arguments.length === 3) {\n    callback = args;\n    args = [];\n  }\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  const numAsyncPres = pres.numAsync || 0;\n  let currentPre = 0;\n  let asyncPresLeft = numAsyncPres;\n  let done = false;\n  const $args = args;\n  let shouldSkipWrappedFunction = null;\n\n  if (!numPres) {\n    return nextTick(function() {\n      callback(null);\n    });\n  }\n\n  function next() {\n    if (currentPre >= numPres) {\n      return;\n    }\n    const pre = pres[currentPre];\n\n    if (pre.isAsync) {\n      const args = [\n        decorateNextFn(_next),\n        decorateNextFn(function(error) {\n          if (error) {\n            if (done) {\n              return;\n            }\n            if (error instanceof Kareem.skipWrappedFunction) {\n              shouldSkipWrappedFunction = error;\n            } else {\n              done = true;\n              return callback(error);\n            }\n          }\n          if (--asyncPresLeft === 0 && currentPre >= numPres) {\n            return callback(shouldSkipWrappedFunction);\n          }\n        })\n      ];\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else if (pre.fn.length > 0) {\n      const args = [decorateNextFn(_next)];\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\n      for (let i = 1; i < _args.length; ++i) {\n        if (i === _args.length - 1 && typeof _args[i] === 'function') {\n          continue; // skip callbacks to avoid accidentally calling the callback from a hook\n        }\n        args.push(_args[i]);\n      }\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else {\n      let maybePromiseLike = null;\n      try {\n        maybePromiseLike = pre.fn.call(context);\n      } catch (err) {\n        if (err != null) {\n          return callback(err);\n        }\n      }\n\n      if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(() => _next(), err => _next(err));\n      } else {\n        if (++currentPre >= numPres) {\n          if (asyncPresLeft > 0) {\n            // Leave parallel hooks to run\n            return;\n          } else {\n            return nextTick(function() {\n              callback(shouldSkipWrappedFunction);\n            });\n          }\n        }\n        next();\n      }\n    }\n  }\n\n  next.apply(null, [null].concat(args));\n\n  function _next(error) {\n    if (error) {\n      if (done) {\n        return;\n      }\n      if (error instanceof Kareem.skipWrappedFunction) {\n        shouldSkipWrappedFunction = error;\n      } else {\n        done = true;\n        return callback(error);\n      }\n    }\n\n    if (++currentPre >= numPres) {\n      if (asyncPresLeft > 0) {\n        // Leave parallel hooks to run\n        return;\n      } else {\n        return callback(shouldSkipWrappedFunction);\n      }\n    }\n\n    next.apply(context, arguments);\n  }\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {void}\n */\nKareem.prototype.execPreSync = function(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n\n  for (let i = 0; i < numPres; ++i) {\n    pres[i].fn.apply(context, args || []);\n  }\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPost = function(name, context, args, options, callback) {\n  if (arguments.length < 5) {\n    callback = options;\n    options = null;\n  }\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let currentPost = 0;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    return nextTick(function() {\n      callback.apply(null, [firstError].concat(args));\n    });\n  }\n\n  function next() {\n    const post = posts[currentPost].fn;\n    let numArgs = 0;\n    const argLength = args.length;\n    const newArgs = [];\n    for (let i = 0; i < argLength; ++i) {\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n      if (!args[i] || !args[i]._kareemIgnore) {\n        newArgs.push(args[i]);\n      }\n    }\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        const _cb = decorateNextFn(function(error) {\n          if (error) {\n            if (error instanceof Kareem.overwriteResult) {\n              args = error.args;\n              if (++currentPost >= numPosts) {\n                return callback.call(null, firstError);\n              }\n              return next();\n            }\n            firstError = error;\n          }\n          if (++currentPost >= numPosts) {\n            return callback.call(null, firstError);\n          }\n          next();\n        });\n\n        callMiddlewareFunction(post, context,\n          [firstError].concat(newArgs).concat([_cb]), _cb);\n      } else {\n        if (++currentPost >= numPosts) {\n          return callback.call(null, firstError);\n        }\n        next();\n      }\n    } else {\n      const _cb = decorateNextFn(function(error) {\n        if (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            if (++currentPost >= numPosts) {\n              return callback.apply(null, [null].concat(args));\n            }\n            return next();\n          }\n          firstError = error;\n          return next();\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n\n        next();\n      });\n\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        // Skip error handlers if no error\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        return next();\n      }\n      if (post.length === numArgs + 1) {\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\n      } else {\n        let error;\n        let maybePromiseLike;\n        try {\n          maybePromiseLike = post.apply(context, newArgs);\n        } catch (err) {\n          error = err;\n          firstError = err;\n        }\n\n        if (isPromiseLike(maybePromiseLike)) {\n          return maybePromiseLike.then(\n            (res) => {\n              _cb(res instanceof Kareem.overwriteResult ? res : null);\n            },\n            err => _cb(err)\n          );\n        }\n\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\n          args = maybePromiseLike.args;\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [error].concat(args));\n        }\n\n        next();\n      }\n    }\n  }\n\n  next();\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    _this.execPreSync(name, this, arguments);\n\n    const toReturn = fn.apply(this, arguments);\n\n    const result = _this.execPostSync(name, this, [toReturn]);\n\n    return result[0];\n  };\n};\n\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n  if (options.useErrorHandlers) {\n    return instance.execPost(name, context, args, { error: error }, function(error) {\n      return typeof callback === 'function' && callback(error);\n    });\n  } else {\n    return typeof callback === 'function' && callback(error);\n  }\n}\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options]\n * @param {Boolean} [options.checkForPromise]\n * @returns {void}\n */\nKareem.prototype.wrap = function(name, fn, context, args, options) {\n  const lastArg = (args.length > 0 ? args[args.length - 1] : null);\n  const argsWithoutCb = Array.from(args);\n  typeof lastArg === 'function' && argsWithoutCb.pop();\n  const _this = this;\n\n  options = options || {};\n  const checkForPromise = options.checkForPromise;\n\n  this.execPre(name, context, args, function(error) {\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n      const numCallbackParams = options.numCallbackParams || 0;\n      const errorArgs = options.contextParameter ? [context] : [];\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\n        errorArgs.push(null);\n      }\n      return _handleWrapError(_this, error, name, context, errorArgs,\n        options, lastArg);\n    }\n\n    const numParameters = fn.length;\n    let ret;\n\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args[0];\n      return _cb(null, ...error.args);\n    } else {\n      try {\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\n      } catch (err) {\n        return _cb(err);\n      }\n    }\n\n    if (checkForPromise) {\n      if (isPromiseLike(ret)) {\n        // Thenable, use it\n        return ret.then(\n          res => _cb(null, res),\n          err => _cb(err)\n        );\n      }\n\n      // If `fn()` doesn't have a callback argument and doesn't return a\n      // promise, assume it is sync\n      if (numParameters < argsWithoutCb.length + 1) {\n        return _cb(null, ret);\n      }\n    }\n\n    function _cb() {\n      const argsWithoutError = Array.from(arguments);\n      argsWithoutError.shift();\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\n        argsWithoutError.push(null);\n      }\n      if (arguments[0]) {\n        // Assume error\n        return _handleWrapError(_this, arguments[0], name, context,\n          argsWithoutError, options, lastArg);\n      } else {\n        _this.execPost(name, context, argsWithoutError, function() {\n          if (lastArg === null) {\n            return;\n          }\n          arguments[0]\n            ? lastArg(arguments[0])\n            : lastArg.apply(context, arguments);\n        });\n      }\n    }\n  });\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the\n    // function wrapped in a nextTick()\n    return function() {\n      nextTick(() => fn.apply(this, arguments));\n    };\n  }\n  return function() {\n    const _context = context || this;\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Boolean} [isAsync]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\n  let options = {};\n  if (typeof isAsync === 'object' && isAsync !== null) {\n    options = isAsync;\n    isAsync = options.isAsync;\n  } else if (typeof arguments[1] !== 'boolean') {\n    fn = isAsync;\n    isAsync = false;\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (isAsync) {\n    pres.numAsync = pres.numAsync || 0;\n    ++pres.numAsync;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    clone.numAsync = this._pres.get(key).numAsync;\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    combined.numAsync = sourcePres.numAsync || 0;\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction callMiddlewareFunction(fn, context, args, next) {\n  let maybePromiseLike;\n  try {\n    maybePromiseLike = fn.apply(context, args);\n  } catch (error) {\n    return next(error);\n  }\n\n  if (isPromiseLike(maybePromiseLike)) {\n    maybePromiseLike.then(() => next(), err => next(err));\n  }\n}\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction decorateNextFn(fn) {\n  let called = false;\n  const _this = this;\n  return function() {\n    // Ensure this function can only be called once\n    if (called) {\n      return;\n    }\n    called = true;\n    // Make sure to clear the stack so try/catch doesn't catch errors\n    // in subsequent middleware\n    return nextTick(() => fn.apply(_this, arguments));\n  };\n}\n\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\n  setTimeout(cb, 0);\n};\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2thcmVlbUAyLjYuMy9ub2RlX21vZHVsZXMva2FyZWVtL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL3BhdWwvcHJvamVjdHMvcGF5bG9hZC9wbHVnaW4tZGV2ZWxvcG1lbnQvYmV0dGVyLWZpZWxkcy9naXRyb290L25vZGVfbW9kdWxlcy8ucG5wbS9rYXJlZW1AMi42LjMvbm9kZV9tb2R1bGVzL2thcmVlbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEthcmVlbSgpIHtcbiAgdGhpcy5fcHJlcyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5fcG9zdHMgPSBuZXcgTWFwKCk7XG59XG5cbkthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uID0gZnVuY3Rpb24gc2tpcFdyYXBwZWRGdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24oLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIHRoaXMuYXJncyA9IFsuLi5hcmd1bWVudHNdO1xufTtcblxuS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCA9IGZ1bmN0aW9uIG92ZXJ3cml0ZVJlc3VsdCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICB0aGlzLmFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwcmVcIiBob29rcyBmb3IgXCJuYW1lXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBhcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBvciBkaXJlY3RseSB0aGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBleGVjdXRpbmcgYWxsIGhvb2tzIGFyZSBmaW5pc2hlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1ByZSA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgY2FsbGJhY2sgPSBhcmdzO1xuICAgIGFyZ3MgPSBbXTtcbiAgfVxuICBjb25zdCBwcmVzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVByZXMgPSBwcmVzLmxlbmd0aDtcbiAgY29uc3QgbnVtQXN5bmNQcmVzID0gcHJlcy5udW1Bc3luYyB8fCAwO1xuICBsZXQgY3VycmVudFByZSA9IDA7XG4gIGxldCBhc3luY1ByZXNMZWZ0ID0gbnVtQXN5bmNQcmVzO1xuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBjb25zdCAkYXJncyA9IGFyZ3M7XG4gIGxldCBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gbnVsbDtcblxuICBpZiAoIW51bVByZXMpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGN1cnJlbnRQcmUgPj0gbnVtUHJlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmUgPSBwcmVzW2N1cnJlbnRQcmVdO1xuXG4gICAgaWYgKHByZS5pc0FzeW5jKSB7XG4gICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICBkZWNvcmF0ZU5leHRGbihfbmV4dCksXG4gICAgICAgIGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICAgICAgICBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gZXJyb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC0tYXN5bmNQcmVzTGVmdCA9PT0gMCAmJiBjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdO1xuXG4gICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHByZS5mbiwgY29udGV4dCwgYXJncywgYXJnc1swXSk7XG4gICAgfSBlbHNlIGlmIChwcmUuZm4ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYXJncyA9IFtkZWNvcmF0ZU5leHRGbihfbmV4dCldO1xuICAgICAgY29uc3QgX2FyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHMgOiBbbnVsbF0uY29uY2F0KCRhcmdzKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IF9hcmdzLmxlbmd0aCAtIDEgJiYgdHlwZW9mIF9hcmdzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIHNraXAgY2FsbGJhY2tzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmcm9tIGEgaG9va1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChfYXJnc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24ocHJlLmZuLCBjb250ZXh0LCBhcmdzLCBhcmdzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heWJlUHJvbWlzZUxpa2UgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWF5YmVQcm9taXNlTGlrZSA9IHByZS5mbi5jYWxsKGNvbnRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Byb21pc2VMaWtlKG1heWJlUHJvbWlzZUxpa2UpKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZUxpa2UudGhlbigoKSA9PiBfbmV4dCgpLCBlcnIgPT4gX25leHQoZXJyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKytjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgICAgICBpZiAoYXN5bmNQcmVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgIC8vIExlYXZlIHBhcmFsbGVsIGhvb2tzIHRvIHJ1blxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0LmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuXG4gIGZ1bmN0aW9uIF9uZXh0KGVycm9yKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKytjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgIGlmIChhc3luY1ByZXNMZWZ0ID4gMCkge1xuICAgICAgICAvLyBMZWF2ZSBwYXJhbGxlbCBob29rcyB0byBydW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHQuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFsbCBcInByZVwiIGhvb2tzIGZvciBcIm5hbWVcIiBzeW5jaHJvbm91c2x5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmV4ZWNQcmVTeW5jID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncykge1xuICBjb25zdCBwcmVzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVByZXMgPSBwcmVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVByZXM7ICsraSkge1xuICAgIHByZXNbaV0uZm4uYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwb3N0XCIgaG9va3MgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gYXJncyBBcHBseSBjdXN0b20gYXJndW1lbnRzIHRvIHRoZSBob29rXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvciBkaXJlY3RseSB0aGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBleGVjdXRpbmcgYWxsIGhvb2tzIGFyZSBmaW5pc2hlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1Bvc3QgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBhcmdzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDUpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgY29uc3QgcG9zdHMgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVBvc3RzID0gcG9zdHMubGVuZ3RoO1xuICBsZXQgY3VycmVudFBvc3QgPSAwO1xuXG4gIGxldCBmaXJzdEVycm9yID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lcnJvcikge1xuICAgIGZpcnN0RXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICB9XG5cbiAgaWYgKCFudW1Qb3N0cykge1xuICAgIHJldHVybiBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtmaXJzdEVycm9yXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjb25zdCBwb3N0ID0gcG9zdHNbY3VycmVudFBvc3RdLmZuO1xuICAgIGxldCBudW1BcmdzID0gMDtcbiAgICBjb25zdCBhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBjb25zdCBuZXdBcmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdMZW5ndGg7ICsraSkge1xuICAgICAgbnVtQXJncyArPSBhcmdzW2ldICYmIGFyZ3NbaV0uX2thcmVlbUlnbm9yZSA/IDAgOiAxO1xuICAgICAgaWYgKCFhcmdzW2ldIHx8ICFhcmdzW2ldLl9rYXJlZW1JZ25vcmUpIHtcbiAgICAgICAgbmV3QXJncy5wdXNoKGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdEVycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZShwb3N0c1tjdXJyZW50UG9zdF0sIG51bUFyZ3MpKSB7XG4gICAgICAgIGNvbnN0IF9jYiA9IGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBlcnJvci5hcmdzO1xuICAgICAgICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKG51bGwsIGZpcnN0RXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChudWxsLCBmaXJzdEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHBvc3QsIGNvbnRleHQsXG4gICAgICAgICAgW2ZpcnN0RXJyb3JdLmNvbmNhdChuZXdBcmdzKS5jb25jYXQoW19jYl0pLCBfY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChudWxsLCBmaXJzdEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IF9jYiA9IGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBlcnJvci5hcmdzO1xuICAgICAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZShwb3N0c1tjdXJyZW50UG9zdF0sIG51bUFyZ3MpKSB7XG4gICAgICAgIC8vIFNraXAgZXJyb3IgaGFuZGxlcnMgaWYgbm8gZXJyb3JcbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Lmxlbmd0aCA9PT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihwb3N0LCBjb250ZXh0LCBuZXdBcmdzLmNvbmNhdChbX2NiXSksIF9jYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBtYXliZVByb21pc2VMaWtlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1heWJlUHJvbWlzZUxpa2UgPSBwb3N0LmFwcGx5KGNvbnRleHQsIG5ld0FyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UobWF5YmVQcm9taXNlTGlrZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlTGlrZS50aGVuKFxuICAgICAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgICAgICBfY2IocmVzIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCA/IHJlcyA6IG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVyciA9PiBfY2IoZXJyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF5YmVQcm9taXNlTGlrZSBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgICAgICBhcmdzID0gbWF5YmVQcm9taXNlTGlrZS5hcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW2Vycm9yXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwb3N0XCIgaG9va3MgZm9yIFwibmFtZVwiIHN5bmNocm9ub3VzbHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBhcmdzIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHVzZWQgYXJndW1lbnRzXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1Bvc3RTeW5jID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncykge1xuICBjb25zdCBwb3N0cyA9IHRoaXMuX3Bvc3RzLmdldChuYW1lKSB8fCBbXTtcbiAgY29uc3QgbnVtUG9zdHMgPSBwb3N0cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb3N0czsgKytpKSB7XG4gICAgY29uc3QgcmVzID0gcG9zdHNbaV0uZm4uYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG4gICAgaWYgKHJlcyBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgIGFyZ3MgPSByZXMuYXJncztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJncztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc3luY2hyb25vdXMgd3JhcHBlciBmb3IgXCJmblwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5jcmVhdGVXcmFwcGVyU3luYyA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uIHN5bmNXcmFwcGVyKCkge1xuICAgIF90aGlzLmV4ZWNQcmVTeW5jKG5hbWUsIHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCB0b1JldHVybiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBfdGhpcy5leGVjUG9zdFN5bmMobmFtZSwgdGhpcywgW3RvUmV0dXJuXSk7XG5cbiAgICByZXR1cm4gcmVzdWx0WzBdO1xuICB9O1xufTtcblxuZnVuY3Rpb24gX2hhbmRsZVdyYXBFcnJvcihpbnN0YW5jZSwgZXJyb3IsIG5hbWUsIGNvbnRleHQsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChvcHRpb25zLnVzZUVycm9ySGFuZGxlcnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhlY1Bvc3QobmFtZSwgY29udGV4dCwgYXJncywgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2soZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgcHJlIGhvb2tzLCBmb2xsb3dlZCBieSB0aGUgd3JhcHBlZCBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgcG9zdCBob29rcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gZm9yIHRoZSBob29rXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXBwbHkgY3VzdG9tIGFyZ3VtZW50cyB0byB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaGVja0ZvclByb21pc2VdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24obmFtZSwgZm4sIGNvbnRleHQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgbGFzdEFyZyA9IChhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiBudWxsKTtcbiAgY29uc3QgYXJnc1dpdGhvdXRDYiA9IEFycmF5LmZyb20oYXJncyk7XG4gIHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nICYmIGFyZ3NXaXRob3V0Q2IucG9wKCk7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2hlY2tGb3JQcm9taXNlID0gb3B0aW9ucy5jaGVja0ZvclByb21pc2U7XG5cbiAgdGhpcy5leGVjUHJlKG5hbWUsIGNvbnRleHQsIGFyZ3MsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikpIHtcbiAgICAgIGNvbnN0IG51bUNhbGxiYWNrUGFyYW1zID0gb3B0aW9ucy5udW1DYWxsYmFja1BhcmFtcyB8fCAwO1xuICAgICAgY29uc3QgZXJyb3JBcmdzID0gb3B0aW9ucy5jb250ZXh0UGFyYW1ldGVyID8gW2NvbnRleHRdIDogW107XG4gICAgICBmb3IgKGxldCBpID0gZXJyb3JBcmdzLmxlbmd0aDsgaSA8IG51bUNhbGxiYWNrUGFyYW1zOyArK2kpIHtcbiAgICAgICAgZXJyb3JBcmdzLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2hhbmRsZVdyYXBFcnJvcihfdGhpcywgZXJyb3IsIG5hbWUsIGNvbnRleHQsIGVycm9yQXJncyxcbiAgICAgICAgb3B0aW9ucywgbGFzdEFyZyk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtUGFyYW1ldGVycyA9IGZuLmxlbmd0aDtcbiAgICBsZXQgcmV0O1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgIHJldCA9IGVycm9yLmFyZ3NbMF07XG4gICAgICByZXR1cm4gX2NiKG51bGwsIC4uLmVycm9yLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzV2l0aG91dENiLmNvbmNhdChfY2IpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gX2NiKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrRm9yUHJvbWlzZSkge1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmV0KSkge1xuICAgICAgICAvLyBUaGVuYWJsZSwgdXNlIGl0XG4gICAgICAgIHJldHVybiByZXQudGhlbihcbiAgICAgICAgICByZXMgPT4gX2NiKG51bGwsIHJlcyksXG4gICAgICAgICAgZXJyID0+IF9jYihlcnIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGBmbigpYCBkb2Vzbid0IGhhdmUgYSBjYWxsYmFjayBhcmd1bWVudCBhbmQgZG9lc24ndCByZXR1cm4gYVxuICAgICAgLy8gcHJvbWlzZSwgYXNzdW1lIGl0IGlzIHN5bmNcbiAgICAgIGlmIChudW1QYXJhbWV0ZXJzIDwgYXJnc1dpdGhvdXRDYi5sZW5ndGggKyAxKSB7XG4gICAgICAgIHJldHVybiBfY2IobnVsbCwgcmV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2IoKSB7XG4gICAgICBjb25zdCBhcmdzV2l0aG91dEVycm9yID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgYXJnc1dpdGhvdXRFcnJvci5zaGlmdCgpO1xuICAgICAgaWYgKG9wdGlvbnMubnVsbFJlc3VsdEJ5RGVmYXVsdCAmJiBhcmdzV2l0aG91dEVycm9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcmdzV2l0aG91dEVycm9yLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlcnJvclxuICAgICAgICByZXR1cm4gX2hhbmRsZVdyYXBFcnJvcihfdGhpcywgYXJndW1lbnRzWzBdLCBuYW1lLCBjb250ZXh0LFxuICAgICAgICAgIGFyZ3NXaXRob3V0RXJyb3IsIG9wdGlvbnMsIGxhc3RBcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZXhlY1Bvc3QobmFtZSwgY29udGV4dCwgYXJnc1dpdGhvdXRFcnJvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGxhc3RBcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA/IGxhc3RBcmcoYXJndW1lbnRzWzBdKVxuICAgICAgICAgICAgOiBsYXN0QXJnLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEZpbHRlciBjdXJyZW50IGluc3RhbmNlIGZvciBzb21ldGhpbmcgc3BlY2lmaWMgYW5kIHJldHVybiB0aGUgZmlsdGVyZWQgY2xvbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtLYXJlZW19IFRoZSBjbG9uZWQgYW5kIGZpbHRlcmVkIGluc3RhbmNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG5cbiAgY29uc3QgcHJlcyA9IEFycmF5LmZyb20oY2xvbmUuX3ByZXMua2V5cygpKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHByZXMpIHtcbiAgICBjb25zdCBob29rcyA9IHRoaXMuX3ByZXMuZ2V0KG5hbWUpLlxuICAgICAgbWFwKGggPT4gT2JqZWN0LmFzc2lnbih7fSwgaCwgeyBuYW1lOiBuYW1lIH0pKS5cbiAgICAgIGZpbHRlcihmbik7XG5cbiAgICBpZiAoaG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBjbG9uZS5fcHJlcy5kZWxldGUobmFtZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBob29rcy5udW1Bc3luYyA9IGhvb2tzLmZpbHRlcihoID0+IGguaXNBc3luYykubGVuZ3RoO1xuXG4gICAgY2xvbmUuX3ByZXMuc2V0KG5hbWUsIGhvb2tzKTtcbiAgfVxuXG4gIGNvbnN0IHBvc3RzID0gQXJyYXkuZnJvbShjbG9uZS5fcG9zdHMua2V5cygpKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHBvc3RzKSB7XG4gICAgY29uc3QgaG9va3MgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkuXG4gICAgICBtYXAoaCA9PiBPYmplY3QuYXNzaWduKHt9LCBoLCB7IG5hbWU6IG5hbWUgfSkpLlxuICAgICAgZmlsdGVyKGZuKTtcblxuICAgIGlmIChob29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNsb25lLl9wb3N0cy5kZWxldGUobmFtZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjbG9uZS5fcG9zdHMuc2V0KG5hbWUsIGhvb2tzKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgZm9yIGEgXCJuYW1lXCIgdG8gZXhpc3QgZWl0aGVyIGluIHByZSBvciBwb3N0IGhvb2tzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHJldHVybnMge0Jvb2xlYW59IFwidHJ1ZVwiIGlmIGZvdW5kLCBcImZhbHNlXCIgb3RoZXJ3aXNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuaGFzSG9va3MgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wcmVzLmhhcyhuYW1lKSB8fCB0aGlzLl9wb3N0cy5oYXMobmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIFdyYXBwZXIgZm9yIFwiZm5cIiBvbiBcIm5hbWVcIiBhbmQgcmV0dXJuIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvblxuICovXG5LYXJlZW0ucHJvdG90eXBlLmNyZWF0ZVdyYXBwZXIgPSBmdW5jdGlvbihuYW1lLCBmbiwgY29udGV4dCwgb3B0aW9ucykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghdGhpcy5oYXNIb29rcyhuYW1lKSkge1xuICAgIC8vIEZhc3QgcGF0aDogaWYgdGhlcmUncyBubyBob29rcyBmb3IgdGhpcyBmdW5jdGlvbiwganVzdCByZXR1cm4gdGhlXG4gICAgLy8gZnVuY3Rpb24gd3JhcHBlZCBpbiBhIG5leHRUaWNrKClcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0VGljaygoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBfY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICBfdGhpcy53cmFwKG5hbWUsIGZuLCBfY29udGV4dCwgQXJyYXkuZnJvbShhcmd1bWVudHMpLCBvcHRpb25zKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgaG9vayBmb3IgXCJwcmVcIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXN5bmNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge25ldmVyfSBlcnJvciBVbnVzZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Vuc2hpZnRdIFdoZXRlciB0byBcInB1c2hcIiBvciB0byBcInVuc2hpZnRcIiB0aGUgbmV3IGhvb2tcbiAqIEByZXR1cm5zIHtLYXJlZW19XG4gKi9cbkthcmVlbS5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24obmFtZSwgaXNBc3luYywgZm4sIGVycm9yLCB1bnNoaWZ0KSB7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGlmICh0eXBlb2YgaXNBc3luYyA9PT0gJ29iamVjdCcgJiYgaXNBc3luYyAhPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBpc0FzeW5jO1xuICAgIGlzQXN5bmMgPSBvcHRpb25zLmlzQXN5bmM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZm4gPSBpc0FzeW5jO1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByZXMgPSB0aGlzLl9wcmVzLmdldChuYW1lKSB8fCBbXTtcbiAgdGhpcy5fcHJlcy5zZXQobmFtZSwgcHJlcyk7XG5cbiAgaWYgKGlzQXN5bmMpIHtcbiAgICBwcmVzLm51bUFzeW5jID0gcHJlcy5udW1Bc3luYyB8fCAwO1xuICAgICsrcHJlcy5udW1Bc3luYztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZSgpIHJlcXVpcmVzIGEgZnVuY3Rpb24sIGdvdCBcIicgKyB0eXBlb2YgZm4gKyAnXCInKTtcbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSB7XG4gICAgcHJlcy51bnNoaWZ0KE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZm46IGZuLCBpc0FzeW5jOiBpc0FzeW5jIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4sIGlzQXN5bmM6IGlzQXN5bmMgfSkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IGhvb2sgZm9yIFwicG9zdFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGZvciBcIm5hbWVcIlxuICogQHBhcmFtIHtCb29sZWFufSBbdW5zaGlmdF0gV2hldGVyIHRvIFwicHVzaFwiIG9yIHRvIFwidW5zaGlmdFwiIHRoZSBuZXcgaG9va1xuICogQHJldHVybnMge0thcmVlbX1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgZm4sIHVuc2hpZnQpIHtcbiAgY29uc3QgcG9zdHMgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkgfHwgW107XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdW5zaGlmdCA9ICEhZm47XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc3QoKSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBnb3QgXCInICsgdHlwZW9mIGZuICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodW5zaGlmdCkge1xuICAgIHBvc3RzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4gfSkpO1xuICB9IGVsc2Uge1xuICAgIHBvc3RzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4gfSkpO1xuICB9XG4gIHRoaXMuX3Bvc3RzLnNldChuYW1lLCBwb3N0cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBpbnN0YW5jZVxuICogQHJldHVybnMge0thcmVlbX0gVGhlIGNsb25lZCBpbnN0YW5jZVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG4gPSBuZXcgS2FyZWVtKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fcHJlcy5rZXlzKCkpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX3ByZXMuZ2V0KGtleSkuc2xpY2UoKTtcbiAgICBjbG9uZS5udW1Bc3luYyA9IHRoaXMuX3ByZXMuZ2V0KGtleSkubnVtQXN5bmM7XG4gICAgbi5fcHJlcy5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fcG9zdHMua2V5cygpKSB7XG4gICAgbi5fcG9zdHMuc2V0KGtleSwgdGhpcy5fcG9zdHMuZ2V0KGtleSkuc2xpY2UoKSk7XG4gIH1cblxuICByZXR1cm4gbjtcbn07XG5cbi8qKlxuICogTWVyZ2UgXCJvdGhlclwiIGludG8gc2VsZiBvciBcImNsb25lXCJcbiAqIEBwYXJhbSB7S2FyZWVtfSBvdGhlciBUaGUgaW5zdGFuY2UgdG8gbWVyZ2Ugd2l0aFxuICogQHBhcmFtIHtLYXJlZW19IFtjbG9uZV0gVGhlIGluc3RhbmNlIHRvIG1lcmdlIG9udG8gKGlmIG5vdCBkZWZpbmVkLCB1c2luZyBcInRoaXNcIilcbiAqIEByZXR1cm5zIHtLYXJlZW19IFRoZSBtZXJnZWQgaW5zdGFuY2VcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyLCBjbG9uZSkge1xuICBjbG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0cnVlIDogY2xvbmU7XG4gIGNvbnN0IHJldCA9IGNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICBmb3IgKGNvbnN0IGtleSBvZiBvdGhlci5fcHJlcy5rZXlzKCkpIHtcbiAgICBjb25zdCBzb3VyY2VQcmVzID0gcmV0Ll9wcmVzLmdldChrZXkpIHx8IFtdO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZCA9IG90aGVyLl9wcmVzLmdldChrZXkpLlxuICAgICAgLy8gRGVkdXBsaWNhdGUgYmFzZWQgb24gYGZuYFxuICAgICAgZmlsdGVyKHAgPT4gc291cmNlUHJlcy5tYXAoX3AgPT4gX3AuZm4pLmluZGV4T2YocC5mbikgPT09IC0xKTtcbiAgICBjb25zdCBjb21iaW5lZCA9IHNvdXJjZVByZXMuY29uY2F0KGRlZHVwbGljYXRlZCk7XG4gICAgY29tYmluZWQubnVtQXN5bmMgPSBzb3VyY2VQcmVzLm51bUFzeW5jIHx8IDA7XG4gICAgY29tYmluZWQubnVtQXN5bmMgKz0gZGVkdXBsaWNhdGVkLmZpbHRlcihwID0+IHAuaXNBc3luYykubGVuZ3RoO1xuICAgIHJldC5fcHJlcy5zZXQoa2V5LCBjb21iaW5lZCk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Ygb3RoZXIuX3Bvc3RzLmtleXMoKSkge1xuICAgIGNvbnN0IHNvdXJjZVBvc3RzID0gcmV0Ll9wb3N0cy5nZXQoa2V5KSB8fCBbXTtcbiAgICBjb25zdCBkZWR1cGxpY2F0ZWQgPSBvdGhlci5fcG9zdHMuZ2V0KGtleSkuXG4gICAgICBmaWx0ZXIocCA9PiBzb3VyY2VQb3N0cy5pbmRleE9mKHApID09PSAtMSk7XG4gICAgcmV0Ll9wb3N0cy5zZXQoa2V5LCBzb3VyY2VQb3N0cy5jb25jYXQoZGVkdXBsaWNhdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihmbiwgY29udGV4dCwgYXJncywgbmV4dCkge1xuICBsZXQgbWF5YmVQcm9taXNlTGlrZTtcbiAgdHJ5IHtcbiAgICBtYXliZVByb21pc2VMaWtlID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICB9XG5cbiAgaWYgKGlzUHJvbWlzZUxpa2UobWF5YmVQcm9taXNlTGlrZSkpIHtcbiAgICBtYXliZVByb21pc2VMaWtlLnRoZW4oKCkgPT4gbmV4dCgpLCBlcnIgPT4gbmV4dChlcnIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHYpIHtcbiAgcmV0dXJuICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB0eXBlb2Ygdi50aGVuID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVOZXh0Rm4oZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBFbnN1cmUgdGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZVxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyBNYWtlIHN1cmUgdG8gY2xlYXIgdGhlIHN0YWNrIHNvIHRyeS9jYXRjaCBkb2Vzbid0IGNhdGNoIGVycm9yc1xuICAgIC8vIGluIHN1YnNlcXVlbnQgbWlkZGxld2FyZVxuICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmNvbnN0IG5leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgIT09IG51bGwgJiYgcHJvY2Vzcy5uZXh0VGljayB8fCBmdW5jdGlvbiBuZXh0VGljayhjYikge1xuICBzZXRUaW1lb3V0KGNiLCAwKTtcbn07XG5cbmZ1bmN0aW9uIGlzRXJyb3JIYW5kbGluZ01pZGRsZXdhcmUocG9zdCwgbnVtQXJncykge1xuICBpZiAocG9zdC5lcnJvckhhbmRsZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcG9zdC5mbi5sZW5ndGggPT09IG51bUFyZ3MgKyAyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEthcmVlbTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js\n");

/***/ })

};
;