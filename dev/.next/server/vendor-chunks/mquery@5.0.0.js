"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery@5.0.0";
exports.ids = ["vendor-chunks/mquery@5.0.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js ***!
  \*******************************************************************************************/
/***/ ((module, exports) => {

eval("\n\n/**\n * methods a collection must implement\n */\n\nconst methods = [\n  'find',\n  'findOne',\n  'updateMany',\n  'updateOne',\n  'replaceOne',\n  'count',\n  'distinct',\n  'findOneAndDelete',\n  'findOneAndUpdate',\n  'aggregate',\n  'findCursor',\n  'deleteOne',\n  'deleteMany'\n];\n\n/**\n * Collection base class from which implementations inherit\n */\n\nfunction Collection() {}\n\nfor (let i = 0, len = methods.length; i < len; ++i) {\n  const method = methods[i];\n  Collection.prototype[method] = notImplemented(method);\n}\n\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n\n/**\n * creates a function which throws an implementation error\n */\n\nfunction notImplemented(method) {\n  return function() {\n    throw new Error('collection.' + method + ' not implemented');\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3BhdWwvcHJvamVjdHMvcGF5bG9hZC9wbHVnaW4tZGV2ZWxvcG1lbnQvYmV0dGVyLWZpZWxkcy9naXRyb290L25vZGVfbW9kdWxlcy8ucG5wbS9tcXVlcnlANS4wLjAvbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvY29sbGVjdGlvbi9jb2xsZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBtZXRob2RzIGEgY29sbGVjdGlvbiBtdXN0IGltcGxlbWVudFxuICovXG5cbmNvbnN0IG1ldGhvZHMgPSBbXG4gICdmaW5kJyxcbiAgJ2ZpbmRPbmUnLFxuICAndXBkYXRlTWFueScsXG4gICd1cGRhdGVPbmUnLFxuICAncmVwbGFjZU9uZScsXG4gICdjb3VudCcsXG4gICdkaXN0aW5jdCcsXG4gICdmaW5kT25lQW5kRGVsZXRlJyxcbiAgJ2ZpbmRPbmVBbmRVcGRhdGUnLFxuICAnYWdncmVnYXRlJyxcbiAgJ2ZpbmRDdXJzb3InLFxuICAnZGVsZXRlT25lJyxcbiAgJ2RlbGV0ZU1hbnknXG5dO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gYmFzZSBjbGFzcyBmcm9tIHdoaWNoIGltcGxlbWVudGF0aW9ucyBpbmhlcml0XG4gKi9cblxuZnVuY3Rpb24gQ29sbGVjdGlvbigpIHt9XG5cbmZvciAobGV0IGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBub3RJbXBsZW1lbnRlZChtZXRob2QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5tZXRob2RzID0gbWV0aG9kcztcblxuLyoqXG4gKiBjcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGltcGxlbWVudGF0aW9uIGVycm9yXG4gKi9cblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGxlY3Rpb24uJyArIG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkJyk7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst env = __webpack_require__(/*! ../env */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\");\n\nif ('unknown' == env.type) {\n  throw new Error('Unknown environment');\n}\n\nmodule.exports =\n  env.isNode ? __webpack_require__(/*! ./node */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js\") :\n    env.isMongo ? __webpack_require__(/*! ./collection */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\") :\n      __webpack_require__(/*! ./collection */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx1RkFBUTs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG1HQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLCtHQUFjO0FBQ3hDLE1BQU0sbUJBQU8sQ0FBQywrR0FBYyIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZW52ID0gcmVxdWlyZSgnLi4vZW52Jyk7XG5cbmlmICgndW5rbm93bicgPT0gZW52LnR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVudmlyb25tZW50Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbiAgZW52LmlzTm9kZSA/IHJlcXVpcmUoJy4vbm9kZScpIDpcbiAgICBlbnYuaXNNb25nbyA/IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpIDpcbiAgICAgIHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/**\n * Module dependencies\n */\n\nconst Collection = __webpack_require__(/*! ./collection */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\n\nclass NodeCollection extends Collection {\n  constructor(col) {\n    super();\n\n    this.collection = col;\n    this.collectionName = col.collectionName;\n  }\n\n  /**\n   * find(match, options)\n   */\n  async find(match, options) {\n    const cursor = this.collection.find(match, options);\n\n    return cursor.toArray();\n  }\n\n  /**\n   * findOne(match, options)\n   */\n  async findOne(match, options) {\n    return this.collection.findOne(match, options);\n  }\n\n  /**\n   * count(match, options)\n   */\n  async count(match, options) {\n    return this.collection.count(match, options);\n  }\n\n  /**\n   * distinct(prop, match, options)\n   */\n  async distinct(prop, match, options) {\n    return this.collection.distinct(prop, match, options);\n  }\n\n  /**\n   * updateMany(match, update, options)\n   */\n  async updateMany(match, update, options) {\n    return this.collection.updateMany(match, update, options);\n  }\n\n  /**\n   * updateOne(match, update, options)\n   */\n  async updateOne(match, update, options) {\n    return this.collection.updateOne(match, update, options);\n  }\n\n  /**\n   * replaceOne(match, update, options)\n   */\n  async replaceOne(match, update, options) {\n    return this.collection.replaceOne(match, update, options);\n  }\n\n  /**\n   * deleteOne(match, options)\n   */\n  async deleteOne(match, options) {\n    return this.collection.deleteOne(match, options);\n  }\n\n  /**\n   * deleteMany(match, options)\n   */\n  async deleteMany(match, options) {\n    return this.collection.deleteMany(match, options);\n  }\n\n  /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */\n  async findOneAndDelete(match, options) {\n    return this.collection.findOneAndDelete(match, options);\n  }\n\n  /**\n   * findOneAndUpdate(match, update, options)\n   */\n  async findOneAndUpdate(match, update, options) {\n    return this.collection.findOneAndUpdate(match, update, options);\n  }\n\n  /**\n   * var cursor = findCursor(match, options)\n   */\n  findCursor(match, options) {\n    return this.collection.find(match, options);\n  }\n\n  /**\n   * aggregation(operators...)\n   * TODO\n   */\n}\n\n\n/**\n * Expose\n */\n\nmodule.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLCtHQUFjOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbmNsYXNzIE5vZGVDb2xsZWN0aW9uIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2w7XG4gICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbC5jb2xsZWN0aW9uTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZChtYXRjaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY29sbGVjdGlvbi5maW5kKG1hdGNoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBjdXJzb3IudG9BcnJheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kT25lKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb3VudChtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGNvdW50KG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5jb3VudChtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGlzdGluY3QocHJvcCwgbWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGlzdGluY3QocHJvcCwgbWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZU1hbnkobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIHVwZGF0ZU1hbnkobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24udXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIHVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi51cGRhdGVPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogcmVwbGFjZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgcmVwbGFjZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5yZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZU9uZShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRlbGV0ZU9uZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlTWFueShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGVsZXRlTWFueShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyWywgcmVzdWx0XSlcbiAgICovXG4gIGFzeW5jIGZpbmRPbmVBbmREZWxldGUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmVBbmREZWxldGUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmRPbmVBbmRVcGRhdGUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmRPbmVBbmRVcGRhdGUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2YXIgY3Vyc29yID0gZmluZEN1cnNvcihtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGZpbmRDdXJzb3IobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmQobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFnZ3JlZ2F0aW9uKG9wZXJhdG9ycy4uLilcbiAgICogVE9ET1xuICAgKi9cbn1cblxuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE5vZGVDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js":
/*!*************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.isNode = 'undefined' != typeof process\n           && 'object' == \"object\"\n           && 'object' == typeof global\n           && 'function' == typeof Buffer\n           && process.argv;\n\nexports.isMongo = !exports.isNode\n           && 'function' == typeof printjson\n           && 'function' == typeof ObjectId\n           && 'function' == typeof rs\n           && 'function' == typeof sh;\n\nexports.isBrowser = !exports.isNode\n                 && !exports.isMongo\n                 && 'undefined' != typeof window;\n\nexports.type = exports.isNode ? 'node'\n  : exports.isMongo ? 'mongo'\n    : exports.isBrowser ? 'browser'\n      : 'unknown';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYztBQUNkLDBCQUEwQixRQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzTm9kZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBwcm9jZXNzXG4gICAgICAgICAgICYmICdvYmplY3QnID09IHR5cGVvZiBtb2R1bGVcbiAgICAgICAgICAgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGdsb2JhbFxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBCdWZmZXJcbiAgICAgICAgICAgJiYgcHJvY2Vzcy5hcmd2O1xuXG5leHBvcnRzLmlzTW9uZ28gPSAhZXhwb3J0cy5pc05vZGVcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgcHJpbnRqc29uXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIE9iamVjdElkXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHJzXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHNoO1xuXG5leHBvcnRzLmlzQnJvd3NlciA9ICFleHBvcnRzLmlzTm9kZVxuICAgICAgICAgICAgICAgICAmJiAhZXhwb3J0cy5pc01vbmdvXG4gICAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiB3aW5kb3c7XG5cbmV4cG9ydHMudHlwZSA9IGV4cG9ydHMuaXNOb2RlID8gJ25vZGUnXG4gIDogZXhwb3J0cy5pc01vbmdvID8gJ21vbmdvJ1xuICAgIDogZXhwb3J0cy5pc0Jyb3dzZXIgPyAnYnJvd3NlcidcbiAgICAgIDogJ3Vua25vd24nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js":
/*!****************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/**\n * Dependencies\n */\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js\")('mquery');\n\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */\n\nfunction Query(criteria, options) {\n  if (!(this instanceof Query))\n    return new Query(criteria, options);\n\n  const proto = this.constructor.prototype;\n\n  this.op = proto.op || undefined;\n\n  this.options = Object.assign({}, proto.options);\n\n  this._conditions = proto._conditions\n    ? utils.clone(proto._conditions)\n    : {};\n\n  this._fields = proto._fields\n    ? utils.clone(proto._fields)\n    : undefined;\n\n  this._updateDoc = proto._updateDoc\n    ? utils.clone(proto._updateDoc)\n    : undefined;\n\n  this._path = proto._path || undefined;\n  this._distinctDoc = proto._distinctDoc || undefined;\n  this._collection = proto._collection || undefined;\n  this._traceFunction = proto._traceFunction || undefined;\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (criteria) {\n    this.find(criteria);\n  }\n}\n\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */\n\nlet $withinCmd = '$geoWithin';\nObject.defineProperty(Query, 'use$geoWithin', {\n  get: function() { return $withinCmd == '$geoWithin'; },\n  set: function(v) {\n    if (true === v) {\n      // mongodb >= 2.4\n      $withinCmd = '$geoWithin';\n    } else {\n      $withinCmd = '$within';\n    }\n  }\n});\n\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  function CustomQuery(criteria, options) {\n    if (!(this instanceof CustomQuery))\n      return new CustomQuery(criteria, options);\n    Query.call(this, criteria, options);\n  }\n\n  utils.inherits(CustomQuery, Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions);\n  p._fields = utils.clone(this._fields);\n  p._updateDoc = utils.clone(this._updateDoc);\n  p._path = this._path;\n  p._distinctDoc = this._distinctDoc;\n  p._collection = this._collection;\n  p._traceFunction = this._traceFunction;\n\n  return CustomQuery;\n};\n\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function(options) {\n  if (!(options && utils.isObject(options)))\n    return this;\n\n  // set arbitrary options\n  const methods = utils.keys(options);\n  let method;\n\n  for (let i = 0; i < methods.length; ++i) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      const args = Array.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args);\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */\n\nQuery.prototype.collection = function collection(coll) {\n  this._collection = new Query.Collection(coll);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\nQuery.prototype.$where = function(js) {\n  this._conditions.$where = js;\n  return this;\n};\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.where = function() {\n  if (!arguments.length) return this;\n  if (!this.op) this.op = 'find';\n\n  const type = typeof arguments[0];\n\n  if ('string' == type) {\n    this._path = arguments[0];\n\n    if (2 === arguments.length) {\n      this._conditions[this._path] = arguments[1];\n    }\n\n    return this;\n  }\n\n  if ('object' == type && !Array.isArray(arguments[0])) {\n    return this.merge(arguments[0]);\n  }\n\n  throw new TypeError('path must be a string or object');\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.equals = function equals(val) {\n  this._ensurePath('equals');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.eq = function eq(val) {\n  this._ensurePath('eq');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.or = function or(array) {\n  const or = this._conditions.$or || (this._conditions.$or = []);\n  if (!Array.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.nor = function nor(array) {\n  const nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!Array.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.and = function and(array) {\n  const and = this._conditions.$and || (this._conditions.$and = []);\n  if (!Array.isArray(array)) array = [array];\n  and.push.apply(and, array);\n  return this;\n};\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */\n\n'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function($conditional) {\n  Query.prototype[$conditional] = function() {\n    let path, val;\n\n    if (1 === arguments.length) {\n      this._ensurePath($conditional);\n      val = arguments[0];\n      path = this._path;\n    } else {\n      val = arguments[1];\n      path = arguments[0];\n    }\n\n    const conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?\n      this._conditions[path] :\n      (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});\n\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (3 === arguments.length) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.exists = function() {\n  let path, val;\n\n  if (0 === arguments.length) {\n    this._ensurePath('exists');\n    path = this._path;\n    val = true;\n  } else if (1 === arguments.length) {\n    if ('boolean' === typeof arguments[0]) {\n      this._ensurePath('exists');\n      path = this._path;\n      val = arguments[0];\n    } else {\n      path = arguments[0];\n      val = true;\n    }\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$exists = val;\n  return this;\n};\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.elemMatch = function() {\n  if (null == arguments[0])\n    throw new TypeError('Invalid argument');\n\n  let fn, path, criteria;\n\n  if ('function' === typeof arguments[0]) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    fn = arguments[0];\n  } else if (utils.isObject(arguments[0])) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    criteria = arguments[0];\n  } else if ('function' === typeof arguments[1]) {\n    path = arguments[0];\n    fn = arguments[1];\n  } else if (arguments[1] && utils.isObject(arguments[1])) {\n    path = arguments[0];\n    criteria = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (fn) {\n    criteria = new Query;\n    fn(criteria);\n    criteria = criteria._conditions;\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$elemMatch = criteria;\n  return this;\n};\n\n// Spatial queries\n\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.within = function within() {\n  // opinionated, must be used after where\n  this._ensurePath('within');\n  this._geoComparison = $withinCmd;\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  if (2 === arguments.length) {\n    return this.box.apply(this, arguments);\n  } else if (2 < arguments.length) {\n    return this.polygon.apply(this, arguments);\n  }\n\n  const area = arguments[0];\n\n  if (!area)\n    throw new TypeError('Invalid argument');\n\n  if (area.center)\n    return this.circle(area);\n\n  if (area.box)\n    return this.box.apply(this, area.box);\n\n  if (area.polygon)\n    return this.polygon.apply(this, area.polygon);\n\n  if (area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.box = function() {\n  let path, box;\n\n  if (3 === arguments.length) {\n    // box('loc', [], [])\n    path = arguments[0];\n    box = [arguments[1], arguments[2]];\n  } else if (2 === arguments.length) {\n    // box([], [])\n    this._ensurePath('box');\n    path = this._path;\n    box = [arguments[0], arguments[1]];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $box: box };\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.polygon = function() {\n  let val, path;\n\n  if ('string' == typeof arguments[0]) {\n    // polygon('loc', [],[],[])\n    val = Array.from(arguments);\n    path = val.shift();\n  } else {\n    // polygon([],[],[])\n    this._ensurePath('polygon');\n    path = this._path;\n    val = Array.from(arguments);\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $polygon: val };\n  return this;\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.circle = function() {\n  let path, val;\n\n  if (1 === arguments.length) {\n    this._ensurePath('circle');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!('radius' in val && val.center))\n    throw new Error('center and radius are required');\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$centerSphere'\n    : '$center';\n\n  const wKey = this._geoComparison || $withinCmd;\n  conds[wKey] = {};\n  conds[wKey][type] = [val.center, val.radius];\n\n  if ('unique' in val)\n    conds[wKey].$uniqueDocs = !!val.unique;\n\n  return this;\n};\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.near = function near() {\n  let path, val;\n\n  this._geoComparison = '$near';\n\n  if (0 === arguments.length) {\n    return this;\n  } else if (1 === arguments.length) {\n    this._ensurePath('near');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!val.center) {\n    throw new Error('center is required');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$nearSphere'\n    : '$near';\n\n  // center could be a GeoJSON object or an Array\n  if (Array.isArray(val.center)) {\n    conds[type] = val.center;\n\n    const radius = 'maxDistance' in val\n      ? val.maxDistance\n      : null;\n\n    if (null != radius) {\n      conds.$maxDistance = radius;\n    }\n    if (null != val.minDistance) {\n      conds.$minDistance = val.minDistance;\n    }\n  } else {\n    // GeoJSON?\n    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {\n      throw new Error(util.format('Invalid GeoJSON specified for %s', type));\n    }\n    conds[type] = { $geometry: val.center };\n\n    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n    if ('maxDistance' in val) {\n      conds[type]['$maxDistance'] = val.maxDistance;\n    }\n    if ('minDistance' in val) {\n      conds[type]['$minDistance'] = val.minDistance;\n    }\n  }\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.intersects = function intersects() {\n  // opinionated, must be used after where\n  this._ensurePath('intersects');\n\n  this._geoComparison = '$geoIntersects';\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  const area = arguments[0];\n\n  if (null != area && area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */\n\nQuery.prototype.geometry = function geometry() {\n  if (!('$within' == this._geoComparison ||\n        '$geoWithin' == this._geoComparison ||\n        '$near' == this._geoComparison ||\n        '$geoIntersects' == this._geoComparison)) {\n    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');\n  }\n\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('geometry');\n    path = this._path;\n    val = arguments[0];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!(val.type && Array.isArray(val.coordinates))) {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison] = { $geometry: val };\n\n  return this;\n};\n\n// end spatial\n\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const type = typeof arg;\n  let i, len;\n\n  if (('string' == type || utils.isArgumentsObject(arg)) &&\n    'number' == typeof arg.length || Array.isArray(arg)) {\n    if ('string' == type)\n      arg = arg.split(/\\s+/);\n\n    for (i = 0, len = arg.length; i < len; ++i) {\n      let field = arg[i];\n      if (!field) continue;\n      const include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    }\n\n    return this;\n  }\n\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      fields[keys[i]] = arg[keys[i]];\n    }\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (0 === arguments.length)\n    return this;\n\n  this._validate('slice');\n\n  let path, val;\n\n  if (1 === arguments.length) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (3 === arguments.length) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const myFields = this._fields || (this._fields = {});\n  myFields[path] = { $slice: val };\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (!arg) return this;\n  let i, len, field;\n\n  this._validate('sort');\n\n  const type = typeof arg;\n\n  // .sort([['field', 1], ['test', -1]])\n  if (Array.isArray(arg)) {\n    len = arg.length;\n    for (i = 0; i < arg.length; ++i) {\n      if (!Array.isArray(arg[i])) {\n        throw new Error('Invalid sort() argument, must be array of arrays');\n      }\n      _pushArr(this.options, arg[i][0], arg[i][1]);\n    }\n    return this;\n  }\n\n  // .sort('field -test')\n  if (1 === arguments.length && 'string' == type) {\n    arg = arg.split(/\\s+/);\n    len = arg.length;\n    for (i = 0; i < len; ++i) {\n      field = arg[i];\n      if (!field) continue;\n      const ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(this.options, field, ascend);\n    }\n\n    return this;\n  }\n\n  // .sort({ field: 1, test: -1 })\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      field = keys[i];\n      push(this.options, field, arg[field]);\n    }\n\n    return this;\n  }\n\n  if (typeof Map !== 'undefined' && arg instanceof Map) {\n    _pushMap(this.options, arg);\n    return this;\n  }\n  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');\n};\n\n/*!\n * @ignore\n */\n\nconst _validSortValue = {\n  1: 1,\n  '-1': -1,\n  asc: 1,\n  ascending: 1,\n  desc: -1,\n  descending: -1\n};\n\nfunction push(opts, field, value) {\n  if (Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let s;\n  if (value && value.$meta) {\n    s = opts.sort || (opts.sort = {});\n    s[field] = { $meta: value.$meta };\n    return;\n  }\n\n  s = opts.sort || (opts.sort = {});\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: { ' + field + ': ' + value + ' }');\n\n  s[field] = val;\n}\n\nfunction _pushArr(opts, field, value) {\n  opts.sort = opts.sort || [];\n  if (!Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: [ ' + field + ', ' + value + ' ]');\n\n  opts.sort.push([field, val]);\n}\n\nfunction _pushMap(opts, map) {\n  opts.sort = opts.sort || new Map();\n  if (!(opts.sort instanceof Map)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or ' +\n      'object or map consistently');\n  }\n  map.forEach(function(value, key) {\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError('Invalid sort value: < ' + key + ': ' + value + ' >');\n\n    opts.sort.set(key, val);\n  });\n}\n\n\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */\n\n/*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */\n\n['limit', 'skip', 'batchSize', 'comment'].forEach(function(method) {\n  Query.prototype[method] = function(v) {\n    this._validate(method);\n    this.options[method] = v;\n    return this;\n  };\n});\n\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */\n\nQuery.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n  this._validate('maxTime');\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */\n\nQuery.prototype.hint = function() {\n  if (0 === arguments.length) return this;\n\n  this._validate('hint');\n\n  const arg = arguments[0];\n  if (utils.isObject(arg)) {\n    const hint = this.options.hint || (this.options.hint = {});\n\n    // must keep object keys in order so don't use Object.keys()\n    for (const k in arg) {\n      hint[k] = arg[k];\n    }\n\n    return this;\n  }\n  if (typeof arg === 'string') {\n    this.options.hint = arg;\n    return this;\n  }\n\n  throw new TypeError('Invalid hint. ' + arg);\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  this.options.j = val;\n  return this;\n};\n\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slaveOk = function(v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = Query.prototype.setReadPreference = function(pref) {\n  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n    console.error('Deprecation warning: \\'tags\\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.');\n    Query.prototype.read.deprecationWarningIssued = true;\n  }\n  this.options.readPreference = utils.readPref(pref);\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.readConcern = Query.prototype.r = function(level) {\n  this.options.readConcern = utils.readConcern(level);\n  return this;\n};\n\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */\n\nQuery.prototype.tailable = function() {\n  this._validate('tailable');\n\n  this.options.tailable = arguments.length\n    ? !!arguments[0]\n    : true;\n\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n  if ('object' === typeof concern) {\n    if ('undefined' !== typeof concern.j) this.options.j = concern.j;\n    if ('undefined' !== typeof concern.w) this.options.w = concern.w;\n    if ('undefined' !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n  } else {\n    this.options.w = 'm' === concern ? 'majority' : concern;\n  }\n  return this;\n};\n\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n  this.options.wtimeout = ms;\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source)\n    return this;\n\n  if (!Query.canMerge(source))\n    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options);\n    }\n\n    if (source._updateDoc) {\n      this._updateDoc || (this._updateDoc = {});\n      utils.mergeClone(this._updateDoc, source._updateDoc);\n    }\n\n    if (source._distinctDoc) {\n      this._distinctDoc = source._distinctDoc;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source);\n\n  return this;\n};\n\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(criteria) {\n  this.op = 'find';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `find` Query\n * @returns the result\n */\nQuery.prototype._find = async function _find() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('_find', this._collection.collectionName, conds, options);\n\n  return this._collection.find(conds, options);\n};\n\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(criteria) {\n  if (this.op) {\n    if (this.op !== 'find') {\n      throw new TypeError('.cursor only support .find method');\n    }\n  } else {\n    this.find(criteria);\n  }\n\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findCursor', this._collection.collectionName, conds, options);\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOne = function(criteria) {\n  this.op = 'findOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `findOne` Query\n * @returns the results\n */\nQuery.prototype._findOne = async function _findOne() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findOne', this._collection.collectionName, conds, options);\n\n  return this._collection.findOne(conds, options);\n};\n\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */\n\nQuery.prototype.count = function(criteria) {\n  this.op = 'count';\n  this._validate();\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `count` Query\n * @returns the results\n */\nQuery.prototype._count = async function _count() {\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('count', this._collection.collectionName, conds, options);\n\n  return this._collection.count(conds, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */\n\nQuery.prototype.distinct = function(criteria, field) {\n  this.op = 'distinct';\n  this._validate();\n\n  if (!field && typeof criteria === 'string') {\n    field = criteria;\n    criteria = undefined;\n  }\n\n  if ('string' == typeof field) {\n    this._distinctDoc = field;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `distinct` Query\n * @returns the results\n */\nQuery.prototype._distinct = async function _distinct() {\n  if (!this._distinctDoc) {\n    throw new Error('No value for `distinct` has been declared');\n  }\n\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('distinct', this._collection.collectionName, conds, options);\n\n  return this._collection.distinct(this._distinctDoc, conds, options);\n};\n\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateMany = function updateMany(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateMany', criteria, doc, options);\n};\n\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */\nQuery.prototype._updateMany = async function() {\n  return _updateExec(this, 'updateMany');\n};\n\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateOne = function updateOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateOne', criteria, doc, options);\n};\n\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */\nQuery.prototype._updateOne = async function() {\n  return _updateExec(this, 'updateOne');\n};\n\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', criteria, doc, options);\n};\n\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */\nQuery.prototype._replaceOne = async function() {\n  return _updateExec(this, 'replaceOne');\n};\n\n/*!\n * Internal helper for updateMany, updateOne\n */\n\nfunction _update(query, op, criteria, doc, options) {\n  query.op = op;\n\n  if (Query.canMerge(criteria)) {\n    query.merge(criteria);\n  }\n\n  if (doc) {\n    query._mergeUpdate(doc);\n  }\n\n  if (utils.isObject(options)) {\n    // { overwrite: true }\n    query.setOptions(options);\n  }\n\n  return query;\n}\n\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */\nasync function _updateExec(query, op) {\n  const options = query._optionsForExec();\n\n  const criteria = query._conditions;\n  const doc = query._updateForExec();\n\n  debug('update', query._collection.collectionName, criteria, doc, options);\n\n  return query._collection[op](criteria, doc, options);\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteOne = function(criteria) {\n  this.op = 'deleteOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */\nQuery.prototype._deleteOne = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteOne(conds, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteMany = function(criteria) {\n  this.op = 'deleteMany';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */\nQuery.prototype._deleteMany = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteMany(conds, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */\nQuery.prototype._findOneAndUpdate = async function() {\n  const conds = this._conditions;\n  const update = this._updateForExec();\n  const options = this._optionsForExec();\n\n  return this._collection.findOneAndUpdate(conds, update, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  // apply conditions\n  if (Query.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */\nQuery.prototype._findOneAndRemove = async function() {\n  const options = this._optionsForExec();\n  const conds = this._conditions;\n\n  return this._collection.findOneAndDelete(conds, options);\n};\n\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */\nQuery.prototype.setTraceFunction = function(traceFunction) {\n  this._traceFunction = traceFunction;\n  return this;\n};\n\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  assert.ok(this.op, 'Missing query type: (find, etc)');\n\n  const fnName = '_' + this.op;\n\n  // better error, because default would list it as \"this[fnName] is not a function\"\n  if (typeof this[fnName] !== 'function') {\n    throw new TypeError(`this[${fnName}] is not a function`);\n  }\n\n  return this[fnName]();\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = async function(res, rej) {\n  return this.exec().then(res, rej);\n};\n\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */\n\nQuery.prototype.cursor = function() {\n  if ('find' != this.op)\n    throw new Error('cursor() is only available for find');\n\n  const conds = this._conditions;\n\n  const options = this._optionsForExec();\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('cursor', this._collection.collectionName, conds, options);\n\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selected = function selected() {\n  return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return false;\n    if (this._fields[key] &&\n        typeof this._fields[key] === 'object' &&\n        this._fields[key].$meta) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return true;\n  }\n\n  return false;\n};\n\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._updateDoc) this._updateDoc = {};\n  if (doc instanceof Query) {\n    if (doc._updateDoc) {\n      utils.mergeClone(this._updateDoc, doc._updateDoc);\n    }\n  } else {\n    utils.mergeClone(this._updateDoc, doc);\n  }\n};\n\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._optionsForExec = function() {\n  const options = utils.clone(this.options);\n  return options;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._fieldsForExec = function() {\n  return utils.clone(this._fields);\n};\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = utils.clone(this._updateDoc);\n  const ops = utils.keys(update);\n  const ret = {};\n\n  for (const op of ops) {\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  this._compiledUpdate = ret;\n  return ret;\n};\n\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */\n\nQuery.prototype._ensurePath = function(method) {\n  if (!this._path) {\n    const msg = method + '() must be used after where() '\n                     + 'when called with these arguments';\n    throw new Error(msg);\n  }\n};\n\n/*!\n * Permissions\n */\n\nQuery.permissions = __webpack_require__(/*! ./permissions */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js\");\n\nQuery._isPermitted = function(a, b) {\n  const denied = Query.permissions[b];\n  if (!denied) return true;\n  return true !== denied[a];\n};\n\nQuery.prototype._validate = function(action) {\n  let fail;\n  let validator;\n\n  if (undefined === action) {\n\n    validator = Query.permissions[this.op];\n    if ('function' != typeof validator) return true;\n\n    fail = validator(this);\n\n  } else if (!Query._isPermitted(action, this.op)) {\n    fail = action;\n  }\n\n  if (fail) {\n    throw new Error(fail + ' cannot be used with ' + this.op);\n  }\n};\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */\n\nQuery.canMerge = function(conds) {\n  return conds instanceof Query || utils.isObject(conds);\n};\n\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */\nQuery.setGlobalTraceFunction = function(traceFunction) {\n  Query.traceFunction = traceFunction;\n};\n\n/*!\n * Exports.\n */\n\nQuery.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query;\n\n// TODO\n// test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLDBGQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxzRkFBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQywwQkFBMEIsbURBQW1EO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzRkFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQywwR0FBYztBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywwSEFBeUI7QUFDeEQ7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtcXVlcnknKTtcblxuLyoqXG4gKiBRdWVyeSBjb25zdHJ1Y3RvciB1c2VkIGZvciBidWlsZGluZyBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHsgbmFtZTogJ21xdWVyeScgfSk7XG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGNvbGxlY3Rpb246IG1vZHVsZUNvbGxlY3Rpb24gfSlcbiAqICAgICBhd2FpdCBxdWVyeS53aGVyZSgnYWdlJykuZ3RlKDIxKS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gY3JpdGVyaWEgZm9yIHRoZSBxdWVyeSBPUiB0aGUgY29sbGVjdGlvbiBpbnN0YW5jZSB0byB1c2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFF1ZXJ5KSlcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcblxuICBjb25zdCBwcm90byA9IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIHRoaXMub3AgPSBwcm90by5vcCB8fCB1bmRlZmluZWQ7XG5cbiAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8ub3B0aW9ucyk7XG5cbiAgdGhpcy5fY29uZGl0aW9ucyA9IHByb3RvLl9jb25kaXRpb25zXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fY29uZGl0aW9ucylcbiAgICA6IHt9O1xuXG4gIHRoaXMuX2ZpZWxkcyA9IHByb3RvLl9maWVsZHNcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl9maWVsZHMpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5fdXBkYXRlRG9jID0gcHJvdG8uX3VwZGF0ZURvY1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX3VwZGF0ZURvYylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB0aGlzLl9wYXRoID0gcHJvdG8uX3BhdGggfHwgdW5kZWZpbmVkO1xuICB0aGlzLl9kaXN0aW5jdERvYyA9IHByb3RvLl9kaXN0aW5jdERvYyB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX2NvbGxlY3Rpb24gPSBwcm90by5fY29sbGVjdGlvbiB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX3RyYWNlRnVuY3Rpb24gPSBwcm90by5fdHJhY2VGdW5jdGlvbiB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY3JpdGVyaWEpIHtcbiAgICB0aGlzLmZpbmQoY3JpdGVyaWEpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHBhcmFtZXRlciB0aGF0IHRoZSB1c2VyIGNhbiBzZXQgd2hpY2ggZGV0ZXJtaW5lcyBpZiBtcXVlcnlcbiAqIHVzZXMgJHdpdGhpbiBvciAkZ2VvV2l0aGluIGZvciBxdWVyaWVzLiBJdCBkZWZhdWx0cyB0byB0cnVlIHdoaWNoXG4gKiBtZWFucyAkZ2VvV2l0aGluIHdpbGwgYmUgdXNlZC4gSWYgdXNpbmcgTW9uZ29EQiA8IDIuNCB5b3Ugc2hvdWxkXG4gKiBzZXQgdGhpcyB0byBmYWxzZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVzZSRnZW9XaXRoaW5cbiAqL1xuXG5sZXQgJHdpdGhpbkNtZCA9ICckZ2VvV2l0aGluJztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeSwgJ3VzZSRnZW9XaXRoaW4nLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAkd2l0aGluQ21kID09ICckZ2VvV2l0aGluJzsgfSxcbiAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHRydWUgPT09IHYpIHtcbiAgICAgIC8vIG1vbmdvZGIgPj0gMi40XG4gICAgICAkd2l0aGluQ21kID0gJyRnZW9XaXRoaW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd2l0aGluQ21kID0gJyR3aXRoaW4nO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBxdWVyeSB0byBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggYWxsIGFyZ3VtZW50cyBhbmQgb3B0aW9ucyByZXRhaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENyZWF0ZSBhIHF1ZXJ5IHRoYXQgd2lsbCByZWFkIGRvY3VtZW50cyB3aXRoIGEgXCJ2aWRlb1wiIGNhdGVnb3J5IGZyb21cbiAqICAgICAvLyBgYUNvbGxlY3Rpb25gIG9uIHRoZSBwcmltYXJ5IG5vZGUgaW4gdGhlIHJlcGxpY2Etc2V0IHVubGVzcyBpdCBpcyBkb3duLFxuICogICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UnbGwgcmVhZCBmcm9tIGEgc2Vjb25kYXJ5IG5vZGUuXG4gKiAgICAgdmFyIHF1ZXJ5ID0gbXF1ZXJ5KHsgY2F0ZWdvcnk6ICd2aWRlbycgfSlcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgY29sbGVjdGlvbjogYUNvbGxlY3Rpb24sIHJlYWQ6ICdwcmltYXJ5UHJlZmVycmVkJyB9KTtcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGEgY29uc3RydWN0b3IgYmFzZWQgb2ZmIHRoZXNlIHNldHRpbmdzXG4gKiAgICAgdmFyIFZpZGVvID0gcXVlcnkudG9Db25zdHJ1Y3RvcigpO1xuICpcbiAqICAgICAvLyBWaWRlbyBpcyBub3cgYSBzdWJjbGFzcyBvZiBtcXVlcnkoKSBhbmQgd29ya3MgdGhlIHNhbWUgd2F5IGJ1dCB3aXRoIHRoZVxuICogICAgIC8vIGRlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyBhbmQgb3B0aW9ucyBzZXQuXG4gKlxuICogICAgIC8vIHJ1biBhIHF1ZXJ5IHdpdGggdGhlIHByZXZpb3VzIHNldHRpbmdzIGJ1dCBmaWx0ZXIgZm9yIG1vdmllcyB3aXRoIG5hbWVzXG4gKiAgICAgLy8gdGhhdCBzdGFydCB3aXRoIFwiTGlmZVwiLlxuICogICAgIFZpZGVvKCkud2hlcmUoeyBuYW1lOiAvXkxpZmUvIH0pLmV4ZWMoY2IpO1xuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBuZXcgUXVlcnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRvQ29uc3RydWN0b3IgPSBmdW5jdGlvbiB0b0NvbnN0cnVjdG9yKCkge1xuICBmdW5jdGlvbiBDdXN0b21RdWVyeShjcml0ZXJpYSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21RdWVyeSkpXG4gICAgICByZXR1cm4gbmV3IEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgICBRdWVyeS5jYWxsKHRoaXMsIGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgfVxuXG4gIHV0aWxzLmluaGVyaXRzKEN1c3RvbVF1ZXJ5LCBRdWVyeSk7XG5cbiAgLy8gc2V0IGluaGVyaXRlZCBkZWZhdWx0c1xuICBjb25zdCBwID0gQ3VzdG9tUXVlcnkucHJvdG90eXBlO1xuXG4gIHAub3B0aW9ucyA9IHt9O1xuICBwLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcblxuICBwLm9wID0gdGhpcy5vcDtcbiAgcC5fY29uZGl0aW9ucyA9IHV0aWxzLmNsb25lKHRoaXMuX2NvbmRpdGlvbnMpO1xuICBwLl9maWVsZHMgPSB1dGlscy5jbG9uZSh0aGlzLl9maWVsZHMpO1xuICBwLl91cGRhdGVEb2MgPSB1dGlscy5jbG9uZSh0aGlzLl91cGRhdGVEb2MpO1xuICBwLl9wYXRoID0gdGhpcy5fcGF0aDtcbiAgcC5fZGlzdGluY3REb2MgPSB0aGlzLl9kaXN0aW5jdERvYztcbiAgcC5fY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gIHAuX3RyYWNlRnVuY3Rpb24gPSB0aGlzLl90cmFjZUZ1bmN0aW9uO1xuXG4gIHJldHVybiBDdXN0b21RdWVyeTtcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBvcHRpb25zLlxuICpcbiAqICMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIFt0YWlsYWJsZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvVGFpbGFibGUrQ3Vyc29ycykgKlxuICogLSBbc29ydF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc29ydChcXCklN0QlN0QpICpcbiAqIC0gW2xpbWl0XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JsaW1pdCUyOCUyOSU3RCU3RCkgKlxuICogLSBbc2tpcF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc2tpcCUyOCUyOSU3RCU3RCkgKlxuICogLSBbbWF4VGltZV0oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8jb3AuX1NfbWF4VGltZU1TKSAqXG4gKiAtIFtiYXRjaFNpemVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmJhdGNoU2l6ZSUyOCUyOSU3RCU3RCkgKlxuICogLSBbY29tbWVudF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0Y29tbWVudCkgKlxuICogLSBbaGludF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0aGludCkgKlxuICogLSBbc2xhdmVPa10oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlKSAqXG4gKiAtIFtzYWZlXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9nZXRMYXN0RXJyb3IrQ29tbWFuZClcbiAqIC0gY29sbGVjdGlvbiB0aGUgY29sbGVjdGlvbiB0byBxdWVyeSBhZ2FpbnN0XG4gKlxuICogXyogZGVub3RlcyBhIHF1ZXJ5IGhlbHBlciBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGVfXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghKG9wdGlvbnMgJiYgdXRpbHMuaXNPYmplY3Qob3B0aW9ucykpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIHNldCBhcmJpdHJhcnkgb3B0aW9uc1xuICBjb25zdCBtZXRob2RzID0gdXRpbHMua2V5cyhvcHRpb25zKTtcbiAgbGV0IG1ldGhvZDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBtZXRob2QgPSBtZXRob2RzW2ldO1xuXG4gICAgLy8gdXNlIG1ldGhvZHMgaWYgZXhpc3QgKHNhZmVyIG9wdGlvbiBtYW5pcHVsYXRpb24pXG4gICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHRoaXNbbWV0aG9kXSkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LmlzQXJyYXkob3B0aW9uc1ttZXRob2RdKVxuICAgICAgICA/IG9wdGlvbnNbbWV0aG9kXVxuICAgICAgICA6IFtvcHRpb25zW21ldGhvZF1dO1xuICAgICAgdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnNbbWV0aG9kXSA9IG9wdGlvbnNbbWV0aG9kXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGlzIFF1ZXJ5cyBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3Rpb24oY29sbCkge1xuICB0aGlzLl9jb2xsZWN0aW9uID0gbmV3IFF1ZXJ5LkNvbGxlY3Rpb24oY29sbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb2xsYXRpb24gdG8gdGhpcyBvcCAoTW9uZ29EQiAzLjQgYW5kIHVwKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpLmNvbGxhdGlvbih7IGxvY2FsZTogXCJlbl9VU1wiLCBzdHJlbmd0aDogMSB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuY29sbGF0aW9uLyNjdXJzb3IuY29sbGF0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb2xsYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHdoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBVc2UgYCR3aGVyZWAgd2hlbiB5b3UgbmVlZCB0byBzZWxlY3QgZG9jdW1lbnRzIHVzaW5nIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuJHdoZXJlKCd0aGlzLmNvbW1lbnRzLmxlbmd0aCA+IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPiA1JylcbiAqXG4gKiAgICAgcXVlcnkuJHdoZXJlKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnRzLmxlbmd0aCA+IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPiA1O1xuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGpzIGphdmFzY3JpcHQgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAbWV0aG9kICR3aGVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuJHdoZXJlID0gZnVuY3Rpb24oanMpIHtcbiAgdGhpcy5fY29uZGl0aW9ucy4kd2hlcmUgPSBqcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGBwYXRoYCBmb3IgdXNlIHdpdGggY2hhaW5pbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBpbnN0ZWFkIG9mIHdyaXRpbmc6XG4gKiAgICAgYXdhaXQgVXNlci5maW5kKHthZ2U6IHskZ3RlOiAyMSwgJGx0ZTogNjV9fSk7XG4gKlxuICogICAgIC8vIHdlIGNhbiBpbnN0ZWFkIHdyaXRlOlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KTtcbiAqXG4gKiAgICAgLy8gcGFzc2luZyBxdWVyeSBjb25kaXRpb25zIGlzIHBlcm1pdHRlZFxuICogICAgIFVzZXIuZmluZCgpLndoZXJlKHsgbmFtZTogJ3ZvbmRlcmZ1bCcgfSlcbiAqXG4gKiAgICAgLy8gY2hhaW5pbmdcbiAqICAgICBhd2FpdCBVc2VyXG4gKiAgICAgICAud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KVxuICogICAgICAgLndoZXJlKCduYW1lJywgL152b25kZXJmdWwvaSlcbiAqICAgICAgIC53aGVyZSgnZnJpZW5kcycpLnNsaWNlKDEwKVxuICogICAgICAgLmV4ZWMoKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gIGlmICghdGhpcy5vcCkgdGhpcy5vcCA9ICdmaW5kJztcblxuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZ3VtZW50c1swXTtcblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZSkge1xuICAgIHRoaXMuX3BhdGggPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY29uZGl0aW9uc1t0aGlzLl9wYXRoXSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICgnb2JqZWN0JyA9PSB0eXBlICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXJnZShhcmd1bWVudHNbMF0pO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbXBsZW1lbnRhcnkgY29tcGFyaXNvbiB2YWx1ZSBmb3IgcGF0aHMgc3BlY2lmaWVkIHdpdGggYHdoZXJlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5lcXVhbHMoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnLCA0OSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyh2YWwpIHtcbiAgdGhpcy5fZW5zdXJlUGF0aCgnZXF1YWxzJyk7XG4gIGNvbnN0IHBhdGggPSB0aGlzLl9wYXRoO1xuICB0aGlzLl9jb25kaXRpb25zW3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICogVGhpcyBpcyBhbGlhcyBvZiBgZXF1YWxzYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXEoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLnNoZXJlKCdhZ2UnKS5lcXVhbHMoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnLCA0OSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEodmFsKSB7XG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2VxJyk7XG4gIGNvbnN0IHBhdGggPSB0aGlzLl9wYXRoO1xuICB0aGlzLl9jb25kaXRpb25zW3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYW4gYCRvcmAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkub3IoW3sgY29sb3I6ICdyZWQnIH0sIHsgc3RhdHVzOiAnZW1lcmdlbmN5JyB9XSlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihhcnJheSkge1xuICBjb25zdCBvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yIHx8ICh0aGlzLl9jb25kaXRpb25zLiRvciA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBvci5wdXNoLmFwcGx5KG9yLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkbm9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5ub3IoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5vciA9IGZ1bmN0aW9uIG5vcihhcnJheSkge1xuICBjb25zdCBub3IgPSB0aGlzLl9jb25kaXRpb25zLiRub3IgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJG5vciA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBub3IucHVzaC5hcHBseShub3IsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRhbmRgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmFuZChbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAc2VlICRhbmQgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hbmQvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKGFycmF5KSB7XG4gIGNvbnN0IGFuZCA9IHRoaXMuX2NvbmRpdGlvbnMuJGFuZCB8fCAodGhpcy5fY29uZGl0aW9ucy4kYW5kID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIGFuZC5wdXNoLmFwcGx5KGFuZCwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGd0IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVGhpbmcuZmluZCgpLndoZXJlKCdhZ2UnKS5ndCgyMSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBUaGluZy5maW5kKCkuZ3QoJ2FnZScsIDIxKVxuICpcbiAqIEBtZXRob2QgZ3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRndGUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBndGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRsdCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbHRlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbHRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbmUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBuZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRpbiBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJG5pbiBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG5pblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRhbGwgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBhbGxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRzaXplIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2Qgc2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHJlZ2V4IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgcmVnZXhcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbWF4RGlzdGFuY2UgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBtYXhEaXN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qIVxuICogZ3QsIGd0ZSwgbHQsIGx0ZSwgbmUsIGluLCBuaW4sIGFsbCwgcmVnZXgsIHNpemUsIG1heERpc3RhbmNlXG4gKlxuICogICAgIFRoaW5nLndoZXJlKCd0eXBlJykubmluKGFycmF5KVxuICovXG5cbidndCBndGUgbHQgbHRlIG5lIGluIG5pbiBhbGwgcmVnZXggc2l6ZSBtYXhEaXN0YW5jZSBtaW5EaXN0YW5jZScuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCRjb25kaXRpb25hbCkge1xuICBRdWVyeS5wcm90b3R5cGVbJGNvbmRpdGlvbmFsXSA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBwYXRoLCB2YWw7XG5cbiAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgkY29uZGl0aW9uYWwpO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLl9jb25kaXRpb25zW3BhdGhdID09PSAnb2JqZWN0JyA/XG4gICAgICB0aGlzLl9jb25kaXRpb25zW3BhdGhdIDpcbiAgICAgICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICAgIGNvbmRzWyckJyArICRjb25kaXRpb25hbF0gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG1vZGAgY29uZGl0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJG1vZCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGV4aXN0c2AgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogdHJ1ZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKClcbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyh0cnVlKVxuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnKVxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogZmFsc2UgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyhmYWxzZSk7XG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScsIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdleGlzdHMnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCdleGlzdHMnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kZXhpc3RzID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZWxlbU1hdGNoYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaCh7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ2F1dGhvcicpLmVxdWFscygnYXV0b2JvdCcpO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoeyBhdXRob3I6ICdhdXRvYm90JyB9KTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEZ1bmN0aW9ufSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gY3JpdGVyaWFcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lbGVtTWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKG51bGwgPT0gYXJndW1lbnRzWzBdKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcblxuICBsZXQgZm4sIHBhdGgsIGNyaXRlcmlhO1xuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZWxlbU1hdGNoJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgZm4gPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzBdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2VsZW1NYXRjaCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGNyaXRlcmlhID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMV0pIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZuID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSAmJiB1dGlscy5pc09iamVjdChhcmd1bWVudHNbMV0pKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBjcml0ZXJpYSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoZm4pIHtcbiAgICBjcml0ZXJpYSA9IG5ldyBRdWVyeTtcbiAgICBmbihjcml0ZXJpYSk7XG4gICAgY3JpdGVyaWEgPSBjcml0ZXJpYS5fY29uZGl0aW9ucztcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJGVsZW1NYXRjaCA9IGNyaXRlcmlhO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNwYXRpYWwgcXVlcmllc1xuXG4vKipcbiAqIFN1Z2FyIGZvciBnZW8tc3BhdGlhbCBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2l0aGluKCkuYm94KClcbiAqICAgICBxdWVyeS53aXRoaW4oKS5jaXJjbGUoKVxuICogICAgIHF1ZXJ5LndpdGhpbigpLmdlb21ldHJ5KClcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGNlbnRlcjogWzUwLDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGJveDogW1s0MC43MywgLTczLjldLCBbNDAuNywgLTczLjk4OF1dIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBwb2x5Z29uOiBbW10sW10sW10sW11dIH0pO1xuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSwgW10pIC8vIHBvbHlnb25cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSkgLy8gYm94XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IFsuLi5dIH0pOyAvLyBnZW9tZXRyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBNdXN0IGJlIHVzZWQgYWZ0ZXIgYHdoZXJlKClgLlxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIHdpdGhpbigpIHtcbiAgLy8gb3BpbmlvbmF0ZWQsIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZVxuICB0aGlzLl9lbnN1cmVQYXRoKCd3aXRoaW4nKTtcbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICR3aXRoaW5DbWQ7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSBpZiAoMiA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2x5Z29uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjb25zdCBhcmVhID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmICghYXJlYSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG5cbiAgaWYgKGFyZWEuY2VudGVyKVxuICAgIHJldHVybiB0aGlzLmNpcmNsZShhcmVhKTtcblxuICBpZiAoYXJlYS5ib3gpXG4gICAgcmV0dXJuIHRoaXMuYm94LmFwcGx5KHRoaXMsIGFyZWEuYm94KTtcblxuICBpZiAoYXJlYS5wb2x5Z29uKVxuICAgIHJldHVybiB0aGlzLnBvbHlnb24uYXBwbHkodGhpcywgYXJlYS5wb2x5Z29uKTtcblxuICBpZiAoYXJlYS50eXBlICYmIGFyZWEuY29vcmRpbmF0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkoYXJlYSk7XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkYm94IGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIGxvd2VyTGVmdCA9IFs0MC43MzA4MywgLTczLjk5NzU2XVxuICogICAgIHZhciB1cHBlclJpZ2h0PSBbNDAuNzQxNDA0LCAgLTczLjk4ODEzNV1cbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmJveChsb3dlckxlZnQsIHVwcGVyUmlnaHQpXG4gKiAgICAgcXVlcnkuYm94KCdsb2MnLCBsb3dlckxlZnQsIHVwcGVyUmlnaHQgKVxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQHNlZSBRdWVyeSN3aXRoaW4gI3F1ZXJ5X1F1ZXJ5LXdpdGhpblxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIGJveDtcblxuICBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIGJveCgnbG9jJywgW10sIFtdKVxuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgYm94ID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgLy8gYm94KFtdLCBbXSlcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdib3gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBib3ggPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kXSA9IHsgJGJveDogYm94IH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkcG9seWdvbiBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5wb2x5Z29uKFsxMCwyMF0sIFsxMywgMjVdLCBbNywxNV0pXG4gKiAgICAgcXVlcnkucG9seWdvbignbG9jJywgWzEwLDIwXSwgWzEzLCAyNV0sIFs3LDE1XSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gW3ZhbF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnBvbHlnb24gPSBmdW5jdGlvbigpIHtcbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgIC8vIHBvbHlnb24oJ2xvYycsIFtdLFtdLFtdKVxuICAgIHZhbCA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICBwYXRoID0gdmFsLnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcG9seWdvbihbXSxbXSxbXSlcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdwb2x5Z29uJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWRdID0geyAkcG9seWdvbjogdmFsIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkY2VudGVyIG9yICRjZW50ZXJTcGhlcmUgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSB9XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNpcmNsZShhcmVhKVxuICogICAgIHF1ZXJ5LmNlbnRlcignbG9jJywgYXJlYSk7XG4gKlxuICogICAgIC8vIGZvciBzcGhlcmljYWwgY2FsY3VsYXRpb25zXG4gKiAgICAgdmFyIGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgcXVlcnkuY2VudGVyKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdjaXJjbGUnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghKCdyYWRpdXMnIGluIHZhbCAmJiB2YWwuY2VudGVyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NlbnRlciBhbmQgcmFkaXVzIGFyZSByZXF1aXJlZCcpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcblxuICBjb25zdCB0eXBlID0gdmFsLnNwaGVyaWNhbFxuICAgID8gJyRjZW50ZXJTcGhlcmUnXG4gICAgOiAnJGNlbnRlcic7XG5cbiAgY29uc3Qgd0tleSA9IHRoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZDtcbiAgY29uZHNbd0tleV0gPSB7fTtcbiAgY29uZHNbd0tleV1bdHlwZV0gPSBbdmFsLmNlbnRlciwgdmFsLnJhZGl1c107XG5cbiAgaWYgKCd1bmlxdWUnIGluIHZhbClcbiAgICBjb25kc1t3S2V5XS4kdW5pcXVlRG9jcyA9ICEhdmFsLnVuaXF1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRuZWFyYCBvciBgJG5lYXJTcGhlcmVgIGNvbmRpdGlvblxuICpcbiAqIFRoZXNlIG9wZXJhdG9ycyByZXR1cm4gZG9jdW1lbnRzIHNvcnRlZCBieSBkaXN0YW5jZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1IH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUsIHNwaGVyaWNhbDogdHJ1ZSB9KTtcbiAqICAgICBxdWVyeS5uZWFyKCdsb2MnLCB7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1IH0pO1xuICogICAgIHF1ZXJ5Lm5lYXIoeyBjZW50ZXI6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFsuLl0gfX0pXG4gKiAgICAgcXVlcnkubmVhcigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFsuLl0gfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5uZWFyID0gZnVuY3Rpb24gbmVhcigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJyRuZWFyJztcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCduZWFyJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoIXZhbC5jZW50ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NlbnRlciBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuXG4gIGNvbnN0IHR5cGUgPSB2YWwuc3BoZXJpY2FsXG4gICAgPyAnJG5lYXJTcGhlcmUnXG4gICAgOiAnJG5lYXInO1xuXG4gIC8vIGNlbnRlciBjb3VsZCBiZSBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIEFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbC5jZW50ZXIpKSB7XG4gICAgY29uZHNbdHlwZV0gPSB2YWwuY2VudGVyO1xuXG4gICAgY29uc3QgcmFkaXVzID0gJ21heERpc3RhbmNlJyBpbiB2YWxcbiAgICAgID8gdmFsLm1heERpc3RhbmNlXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAobnVsbCAhPSByYWRpdXMpIHtcbiAgICAgIGNvbmRzLiRtYXhEaXN0YW5jZSA9IHJhZGl1cztcbiAgICB9XG4gICAgaWYgKG51bGwgIT0gdmFsLm1pbkRpc3RhbmNlKSB7XG4gICAgICBjb25kcy4kbWluRGlzdGFuY2UgPSB2YWwubWluRGlzdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEdlb0pTT04/XG4gICAgaWYgKHZhbC5jZW50ZXIudHlwZSAhPSAnUG9pbnQnIHx8ICFBcnJheS5pc0FycmF5KHZhbC5jZW50ZXIuY29vcmRpbmF0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ0ludmFsaWQgR2VvSlNPTiBzcGVjaWZpZWQgZm9yICVzJywgdHlwZSkpO1xuICAgIH1cbiAgICBjb25kc1t0eXBlXSA9IHsgJGdlb21ldHJ5OiB2YWwuY2VudGVyIH07XG5cbiAgICAvLyBNb25nb0RCIDIuNiBpbnNpc3RzIG9uIG1heERpc3RhbmNlIGJlaW5nIGluICRuZWFyIC8gJG5lYXJTcGhlcmVcbiAgICBpZiAoJ21heERpc3RhbmNlJyBpbiB2YWwpIHtcbiAgICAgIGNvbmRzW3R5cGVdWyckbWF4RGlzdGFuY2UnXSA9IHZhbC5tYXhEaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKCdtaW5EaXN0YW5jZScgaW4gdmFsKSB7XG4gICAgICBjb25kc1t0eXBlXVsnJG1pbkRpc3RhbmNlJ10gPSB2YWwubWluRGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGludGVyc2VjdHMgcXVlcnkgZm9yIGBnZW9tZXRyeSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHtcbiAqICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnXG4gKiAgICAgICAsIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgncGF0aCcpLmludGVyc2VjdHMoe1xuICogICAgICAgICB0eXBlOiAnTGluZVN0cmluZydcbiAqICAgICAgICwgY29vcmRpbmF0ZXM6IFtbMTgwLjAsIDExLjBdLCBbMTgwLCA5LjBdXVxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthcmddXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMoKSB7XG4gIC8vIG9waW5pb25hdGVkLCBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmVcbiAgdGhpcy5fZW5zdXJlUGF0aCgnaW50ZXJzZWN0cycpO1xuXG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAnJGdlb0ludGVyc2VjdHMnO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBhcmVhID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmIChudWxsICE9IGFyZWEgJiYgYXJlYS50eXBlICYmIGFyZWEuY29vcmRpbmF0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkoYXJlYSk7XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGdlb21ldHJ5YCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBwb2x5QSA9IFtbWyAxMCwgMjAgXSwgWyAxMCwgNDAgXSwgWyAzMCwgNDAgXSwgWyAzMCwgMjAgXV1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogcG9seUEgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICB2YXIgcG9seUIgPSBbWyAwLCAwIF0sIFsgMSwgMSBdXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IHBvbHlCIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgdmFyIHBvbHlDID0gWyAwLCAwIF1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcG9seUMgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBnZW9tZXRyeSgpYCAqKm11c3QqKiBjb21lIGFmdGVyIGVpdGhlciBgaW50ZXJzZWN0cygpYCBvciBgd2l0aGluKClgLlxuICpcbiAqIFRoZSBgb2JqZWN0YCBhcmd1bWVudCBtdXN0IGNvbnRhaW4gYHR5cGVgIGFuZCBgY29vcmRpbmF0ZXNgIHByb3BlcnRpZXMuXG4gKiAtIHR5cGUge1N0cmluZ31cbiAqIC0gY29vcmRpbmF0ZXMge0FycmF5fVxuICpcbiAqIFRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE11c3QgY29udGFpbiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBpcyBhIFN0cmluZyBhbmQgYSBgY29vcmRpbmF0ZXNgIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5LiBTZWUgdGhlIGV4YW1wbGVzLlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlbGVhc2Utbm90ZXMvMi40LyNuZXctZ2Vvc3BhdGlhbC1pbmRleGVzLXdpdGgtZ2VvanNvbi1hbmQtaW1wcm92ZWQtc3BoZXJpY2FsLWdlb21ldHJ5XG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBzZWUgJGdlb21ldHJ5IGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uIGdlb21ldHJ5KCkge1xuICBpZiAoISgnJHdpdGhpbicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJGdlb1dpdGhpbicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJG5lYXInID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRnZW9JbnRlcnNlY3RzJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2VvbWV0cnkoKSBtdXN0IGNvbWUgYWZ0ZXIgYHdpdGhpbigpYCwgYGludGVyc2VjdHMoKWAsIG9yIGBuZWFyKCknKTtcbiAgfVxuXG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdnZW9tZXRyeScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoISh2YWwudHlwZSAmJiBBcnJheS5pc0FycmF5KHZhbC5jb29yZGluYXRlcykpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uXSA9IHsgJGdlb21ldHJ5OiB2YWwgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVuZCBzcGF0aWFsXG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaWNoIGRvY3VtZW50IGZpZWxkcyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGVcbiAqXG4gKiAjIyMjIFN0cmluZyBzeW50YXhcbiAqXG4gKiBXaGVuIHBhc3NpbmcgYSBzdHJpbmcsIHByZWZpeGluZyBhIHBhdGggd2l0aCBgLWAgd2lsbCBmbGFnIHRoYXQgcGF0aCBhcyBleGNsdWRlZC4gV2hlbiBhIHBhdGggZG9lcyBub3QgaGF2ZSB0aGUgYC1gIHByZWZpeCwgaXQgaXMgaW5jbHVkZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBpbmNsdWRlIGEgYW5kIGIsIGV4Y2x1ZGUgY1xuICogICAgIHF1ZXJ5LnNlbGVjdCgnYSBiIC1jJyk7XG4gKlxuICogICAgIC8vIG9yIHlvdSBtYXkgdXNlIG9iamVjdCBub3RhdGlvbiwgdXNlZnVsIHdoZW5cbiAqICAgICAvLyB5b3UgaGF2ZSBrZXlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCBhIFwiLVwiXG4gKiAgICAgcXVlcnkuc2VsZWN0KHthOiAxLCBiOiAxLCBjOiAwfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdDogc2VsZWN0IG9ubHkgdGFrZXMgMSBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NlbGVjdCcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgbGV0IGksIGxlbjtcblxuICBpZiAoKCdzdHJpbmcnID09IHR5cGUgfHwgdXRpbHMuaXNBcmd1bWVudHNPYmplY3QoYXJnKSkgJiZcbiAgICAnbnVtYmVyJyA9PSB0eXBlb2YgYXJnLmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBpZiAoJ3N0cmluZycgPT0gdHlwZSlcbiAgICAgIGFyZyA9IGFyZy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYXJnLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsZXQgZmllbGQgPSBhcmdbaV07XG4gICAgICBpZiAoIWZpZWxkKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSAnLScgPT0gZmllbGRbMF0gPyAwIDogMTtcbiAgICAgIGlmIChpbmNsdWRlID09PSAwKSBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBpbmNsdWRlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBrZXlzID0gdXRpbHMua2V5cyhhcmcpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBmaWVsZHNba2V5c1tpXV0gPSBhcmdba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZWxlY3QoKSBhcmd1bWVudC4gTXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkc2xpY2UgY29uZGl0aW9uIGZvciBhIGBwYXRoYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgNSlcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCAtNSlcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCBbMTAsIDVdKVxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKDUpXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoWy0xMCwgNV0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBudW1iZXIvcmFuZ2Ugb2YgZWxlbWVudHMgdG8gc2xpY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvUmV0cmlldmluZythK1N1YnNldCtvZitGaWVsZHMjUmV0cmlldmluZ2FTdWJzZXRvZkZpZWxkcy1SZXRyaWV2aW5nYVN1YnJhbmdlb2ZBcnJheUVsZW1lbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcztcblxuICB0aGlzLl92YWxpZGF0ZSgnc2xpY2UnKTtcblxuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICAgIHRoaXMuc2xpY2Uoa2V5c1tpXSwgYXJnW2tleXNbaV1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdzbGljZScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCdzbGljZScpO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICB2YWwgPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgfSBlbHNlIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICB9XG5cbiAgY29uc3QgbXlGaWVsZHMgPSB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgbXlGaWVsZHNbcGF0aF0gPSB7ICRzbGljZTogdmFsIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzb3J0IG9yZGVyXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlICdhc2MnLCAnZGVzYycsICdhc2NlbmRpbmcnLCAnZGVzY2VuZGluZycsIDEsIGFuZCAtMS5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIGl0IG11c3QgYmUgYSBzcGFjZSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXRoIG5hbWVzLiBUaGUgc29ydCBvcmRlciBvZiBlYWNoIHBhdGggaXMgYXNjZW5kaW5nIHVubGVzcyB0aGUgcGF0aCBuYW1lIGlzIHByZWZpeGVkIHdpdGggYC1gIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBkZXNjZW5kaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gdGhlc2UgYXJlIGVxdWl2YWxlbnRcbiAqICAgICBxdWVyeS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqICAgICBxdWVyeS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICogICAgIHF1ZXJ5LnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICAtIFRoZSBhcnJheSBzeW50YXggYC5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pYCBjYW4gb25seSBiZSB1c2VkIHdpdGggW21vbmdvZGIgZHJpdmVyID49IDIuMC40Nl0oaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGIvbm9kZS1tb25nb2RiLW5hdGl2ZS9ibG9iLzIuMS9ISVNUT1JZLm1kIzIwNDYtMjAxNS0xMC0xNSkuXG4gKiAgLSBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xBcnJheX0gYXJnXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGFyZykge1xuICBpZiAoIWFyZykgcmV0dXJuIHRoaXM7XG4gIGxldCBpLCBsZW4sIGZpZWxkO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzb3J0Jyk7XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG5cbiAgLy8gLnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSlcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ1tpXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudCwgbXVzdCBiZSBhcnJheSBvZiBhcnJheXMnKTtcbiAgICAgIH1cbiAgICAgIF9wdXNoQXJyKHRoaXMub3B0aW9ucywgYXJnW2ldWzBdLCBhcmdbaV1bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIC5zb3J0KCdmaWVsZCAtdGVzdCcpXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoICYmICdzdHJpbmcnID09IHR5cGUpIHtcbiAgICBhcmcgPSBhcmcuc3BsaXQoL1xccysvKTtcbiAgICBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgZmllbGQgPSBhcmdbaV07XG4gICAgICBpZiAoIWZpZWxkKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGFzY2VuZCA9ICctJyA9PSBmaWVsZFswXSA/IC0xIDogMTtcbiAgICAgIGlmIChhc2NlbmQgPT09IC0xKSBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIHB1c2godGhpcy5vcHRpb25zLCBmaWVsZCwgYXNjZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pXG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3Qga2V5cyA9IHV0aWxzLmtleXMoYXJnKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgZmllbGQgPSBrZXlzW2ldO1xuICAgICAgcHVzaCh0aGlzLm9wdGlvbnMsIGZpZWxkLCBhcmdbZmllbGRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJiBhcmcgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBfcHVzaE1hcCh0aGlzLm9wdGlvbnMsIGFyZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQuIE11c3QgYmUgYSBzdHJpbmcsIG9iamVjdCwgb3IgYXJyYXkuJyk7XG59O1xuXG4vKiFcbiAqIEBpZ25vcmVcbiAqL1xuXG5jb25zdCBfdmFsaWRTb3J0VmFsdWUgPSB7XG4gIDE6IDEsXG4gICctMSc6IC0xLFxuICBhc2M6IDEsXG4gIGFzY2VuZGluZzogMSxcbiAgZGVzYzogLTEsXG4gIGRlc2NlbmRpbmc6IC0xXG59O1xuXG5mdW5jdGlvbiBwdXNoKG9wdHMsIGZpZWxkLCB2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnNvcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciBvYmplY3Q6JyArXG4gICAgICAnXFxuLSBgLnNvcnQoW1tcXCdmaWVsZFxcJywgMV0sIFtcXCd0ZXN0XFwnLCAtMV1dKWAnICtcbiAgICAgICdcXG4tIGAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KWAnKTtcbiAgfVxuXG4gIGxldCBzO1xuICBpZiAodmFsdWUgJiYgdmFsdWUuJG1ldGEpIHtcbiAgICBzID0gb3B0cy5zb3J0IHx8IChvcHRzLnNvcnQgPSB7fSk7XG4gICAgc1tmaWVsZF0gPSB7ICRtZXRhOiB2YWx1ZS4kbWV0YSB9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHMgPSBvcHRzLnNvcnQgfHwgKG9wdHMuc29ydCA9IHt9KTtcbiAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogeyAnICsgZmllbGQgKyAnOiAnICsgdmFsdWUgKyAnIH0nKTtcblxuICBzW2ZpZWxkXSA9IHZhbDtcbn1cblxuZnVuY3Rpb24gX3B1c2hBcnIob3B0cywgZmllbGQsIHZhbHVlKSB7XG4gIG9wdHMuc29ydCA9IG9wdHMuc29ydCB8fCBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMuc29ydCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yIG9iamVjdDonICtcbiAgICAgICdcXG4tIGAuc29ydChbW1xcJ2ZpZWxkXFwnLCAxXSwgW1xcJ3Rlc3RcXCcsIC0xXV0pYCcgK1xuICAgICAgJ1xcbi0gYC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pYCcpO1xuICB9XG5cbiAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogWyAnICsgZmllbGQgKyAnLCAnICsgdmFsdWUgKyAnIF0nKTtcblxuICBvcHRzLnNvcnQucHVzaChbZmllbGQsIHZhbF0pO1xufVxuXG5mdW5jdGlvbiBfcHVzaE1hcChvcHRzLCBtYXApIHtcbiAgb3B0cy5zb3J0ID0gb3B0cy5zb3J0IHx8IG5ldyBNYXAoKTtcbiAgaWYgKCEob3B0cy5zb3J0IGluc3RhbmNlb2YgTWFwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3IgJyArXG4gICAgICAnb2JqZWN0IG9yIG1hcCBjb25zaXN0ZW50bHknKTtcbiAgfVxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgbGV0IHZhbCA9IFN0cmluZyh2YWx1ZSB8fCAxKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IDwgJyArIGtleSArICc6ICcgKyB2YWx1ZSArICcgPicpO1xuXG4gICAgb3B0cy5zb3J0LnNldChrZXksIHZhbCk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBsaW1pdCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5saW1pdCgyMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGxpbWl0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JsaW1pdCUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIHNraXAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2tpcCgxMDApLmxpbWl0KDIwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2Qgc2tpcFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCc2tpcCUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGJhdGNoU2l6ZSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5iYXRjaFNpemUoMTAwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgYmF0Y2hTaXplXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JiYXRjaFNpemUlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgY29tbWVudGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnbG9naW4gcXVlcnknKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgY29tbWVudFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0Y29tbWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIGxpbWl0LCBza2lwLCBiYXRjaFNpemUsIGNvbW1lbnRcbiAqXG4gKiBTZXRzIHRoZXNlIGFzc29jaWF0ZWQgb3B0aW9ucy5cbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnZmVlZCBxdWVyeScpO1xuICovXG5cblsnbGltaXQnLCAnc2tpcCcsICdiYXRjaFNpemUnLCAnY29tbWVudCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odikge1xuICAgIHRoaXMuX3ZhbGlkYXRlKG1ldGhvZCk7XG4gICAgdGhpcy5vcHRpb25zW21ldGhvZF0gPSB2O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBtYXhUaW1lTVMgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubWF4VGltZSgxMDApXG4gKiAgICAgcXVlcnkubWF4VGltZU1TKDEwMClcbiAqXG4gKiBAbWV0aG9kIG1heFRpbWVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8jb3AuX1NfbWF4VGltZU1TXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tYXhUaW1lID0gUXVlcnkucHJvdG90eXBlLm1heFRpbWVNUyA9IGZ1bmN0aW9uKG1zKSB7XG4gIHRoaXMuX3ZhbGlkYXRlKCdtYXhUaW1lJyk7XG4gIHRoaXMub3B0aW9ucy5tYXhUaW1lTVMgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgcXVlcnkgaGludHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5oaW50KHsgaW5kZXhBOiAxLCBpbmRleEI6IC0xfSk7XG4gKiAgICAgcXVlcnkuaGludCgnaW5kZXhBXzFfaW5kZXhCXzEnKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHZhbCBhIGhpbnQgb2JqZWN0IG9yIHRoZSBpbmRleCBuYW1lXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGhpbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdoaW50Jyk7XG5cbiAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdO1xuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGhpbnQgPSB0aGlzLm9wdGlvbnMuaGludCB8fCAodGhpcy5vcHRpb25zLmhpbnQgPSB7fSk7XG5cbiAgICAvLyBtdXN0IGtlZXAgb2JqZWN0IGtleXMgaW4gb3JkZXIgc28gZG9uJ3QgdXNlIE9iamVjdC5rZXlzKClcbiAgICBmb3IgKGNvbnN0IGsgaW4gYXJnKSB7XG4gICAgICBoaW50W2tdID0gYXJnW2tdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMub3B0aW9ucy5oaW50ID0gYXJnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoaW50LiAnICsgYXJnKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREInc1xuICogb24tZGlzayBqb3VybmFsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBgamAgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VybiBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53KDIpLmoodHJ1ZSkud3RpbWVvdXQoMjAwMCk7XG4gKlxuICogQG1ldGhvZCBqXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmogPSBmdW5jdGlvbiBqKHZhbCkge1xuICB0aGlzLm9wdGlvbnMuaiA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNsYXZlT2sgb3B0aW9uLiBfRGVwcmVjYXRlZF8gaW4gTW9uZ29EQiAyLjIgaW4gZmF2b3Igb2YgcmVhZCBwcmVmZXJlbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNsYXZlT2soKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2xhdmVPayh0cnVlKVxuICogICAgIHF1ZXJ5LnNsYXZlT2soZmFsc2UpXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIHJlYWQoKSBwcmVmZXJlbmNlcyBpbnN0ZWFkIGlmIG9uIG1vbmdvZGIgPj0gMi4yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHYgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICogQHNlZSByZWFkKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zbGF2ZU9rID0gZnVuY3Rpb24odikge1xuICB0aGlzLm9wdGlvbnMuc2xhdmVPayA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIXYgOiB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZFByZWZlcmVuY2Ugb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwJykgIC8vIHNhbWUgYXMgcHJpbWFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcCcpIC8vIHNhbWUgYXMgcHJpbWFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnKSAgLy8gc2FtZSBhcyBzZWNvbmRhcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzcCcpIC8vIHNhbWUgYXMgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ25lYXJlc3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ24nKSAgLy8gc2FtZSBhcyBuZWFyZXN0XG4gKlxuICogICAgIC8vIHlvdSBjYW4gYWxzbyB1c2UgbW9uZ29kYi5SZWFkUHJlZmVyZW5jZSBjbGFzcyB0byBhbHNvIHNwZWNpZnkgdGFnc1xuICogICAgIG5ldyBRdWVyeSgpLnJlYWQobW9uZ29kYi5SZWFkUHJlZmVyZW5jZSgnc2Vjb25kYXJ5JywgW3sgZGM6J3NmJywgczogMSB9LHsgZGM6J21hJywgczogMiB9XSkpXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnNldFJlYWRQcmVmZXJlbmNlKCdwcmltYXJ5JykgLy8gYWxpYXMgb2YgLnJlYWQoKVxuICpcbiAqICMjIyMgUHJlZmVyZW5jZXM6XG4gKlxuICogICAgIHByaW1hcnkgLSAoZGVmYXVsdCkgIFJlYWQgZnJvbSBwcmltYXJ5IG9ubHkuIE9wZXJhdGlvbnMgd2lsbCBwcm9kdWNlIGFuIGVycm9yIGlmIHByaW1hcnkgaXMgdW5hdmFpbGFibGUuIENhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRhZ3MuXG4gKiAgICAgc2Vjb25kYXJ5ICAgICAgICAgICAgUmVhZCBmcm9tIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBlcnJvci5cbiAqICAgICBwcmltYXJ5UHJlZmVycmVkICAgICBSZWFkIGZyb20gcHJpbWFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBhIHNlY29uZGFyeS5cbiAqICAgICBzZWNvbmRhcnlQcmVmZXJyZWQgICBSZWFkIGZyb20gYSBzZWNvbmRhcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgcmVhZCBmcm9tIHRoZSBwcmltYXJ5LlxuICogICAgIG5lYXJlc3QgICAgICAgICAgICAgIEFsbCBvcGVyYXRpb25zIHJlYWQgZnJvbSBhbW9uZyB0aGUgbmVhcmVzdCBjYW5kaWRhdGVzLCBidXQgdW5saWtlIG90aGVyIG1vZGVzLCB0aGlzIG9wdGlvbiB3aWxsIGluY2x1ZGUgYm90aCB0aGUgcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGluIHRoZSByYW5kb20gc2VsZWN0aW9uLlxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiAgICAgcCAgIHByaW1hcnlcbiAqICAgICBwcCAgcHJpbWFyeVByZWZlcnJlZFxuICogICAgIHMgICBzZWNvbmRhcnlcbiAqICAgICBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiAgICAgbiAgIG5lYXJlc3RcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIHByZWZlcmVuY2VzIFtoZXJlXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpIGFuZCBbaGVyZV0oaHR0cDovL21vbmdvZGIuZ2l0aHViLmNvbS9ub2RlLW1vbmdvZGItbmF0aXZlL2RyaXZlci1hcnRpY2xlcy9hbmludHJvZHVjdGlvbnRvMV8xYW5kMl8yLmh0bWwjcmVhZC1wcmVmZXJlbmNlcykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVhZFByZWZlcmVuY2V9IHByZWYgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEBzZWUgZHJpdmVyIGh0dHA6Ly9tb25nb2RiLmdpdGh1Yi5jb20vbm9kZS1tb25nb2RiLW5hdGl2ZS9kcml2ZXItYXJ0aWNsZXMvYW5pbnRyb2R1Y3Rpb250bzFfMWFuZDJfMi5odG1sI3JlYWQtcHJlZmVyZW5jZXNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkID0gUXVlcnkucHJvdG90eXBlLnNldFJlYWRQcmVmZXJlbmNlID0gZnVuY3Rpb24ocHJlZikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgIVF1ZXJ5LnByb3RvdHlwZS5yZWFkLmRlcHJlY2F0aW9uV2FybmluZ0lzc3VlZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IFxcJ3RhZ3NcXCcgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCBhbnltb3JlIGluIFF1ZXJ5LnJlYWQoKSBtZXRob2QuIFBsZWFzZSB1c2UgbW9uZ29kYi5SZWFkUHJlZmVyZW5jZSBvYmplY3QgaW5zdGVhZC4nKTtcbiAgICBRdWVyeS5wcm90b3R5cGUucmVhZC5kZXByZWNhdGlvbldhcm5pbmdJc3N1ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHV0aWxzLnJlYWRQcmVmKHByZWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZENvbmNlcm4gb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbG9jYWwnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsJykgIC8vIHNhbWUgYXMgbG9jYWxcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2F2YWlsYWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2EnKSAgLy8gc2FtZSBhcyBhdmFpbGFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbScpICAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsaW5lYXJpemFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdseicpIC8vIHNhbWUgYXMgbGluZWFyaXphYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzbmFwc2hvdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3MnKSAgLy8gc2FtZSBhcyBzbmFwc2hvdFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yKCdzJykgLy8gciBpcyBhbGlhcyBvZiByZWFkQ29uY2VyblxuICpcbiAqXG4gKiAjIyMjIFJlYWQgQ29uY2VybiBMZXZlbDpcbiAqXG4gKiAgICAgbG9jYWwgICAgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiAgICAgYXZhaWxhYmxlICAgICBNb25nb0RCIDMuNisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiAgICAgbWFqb3JpdHkgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycy4gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBieSB0aGUgcmVhZCBvcGVyYXRpb24gYXJlIGR1cmFibGUsIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGZhaWx1cmUuXG4gKiAgICAgbGluZWFyaXphYmxlICBNb25nb0RCIDMuNCsgVGhlIHF1ZXJ5IHJldHVybnMgZGF0YSB0aGF0IHJlZmxlY3RzIGFsbCBzdWNjZXNzZnVsIG1ham9yaXR5LWFja25vd2xlZGdlZCB3cml0ZXMgdGhhdCBjb21wbGV0ZWQgcHJpb3IgdG8gdGhlIHN0YXJ0IG9mIHRoZSByZWFkIG9wZXJhdGlvbi4gVGhlIHF1ZXJ5IG1heSB3YWl0IGZvciBjb25jdXJyZW50bHkgZXhlY3V0aW5nIHdyaXRlcyB0byBwcm9wYWdhdGUgdG8gYSBtYWpvcml0eSBvZiByZXBsaWNhIHNldCBtZW1iZXJzIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cy5cbiAqICAgICBzbmFwc2hvdCAgICAgIE1vbmdvREIgNC4wKyBPbmx5IGF2YWlsYWJsZSBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gbXVsdGktZG9jdW1lbnQgdHJhbnNhY3Rpb25zLiBVcG9uIHRyYW5zYWN0aW9uIGNvbW1pdCB3aXRoIHdyaXRlIGNvbmNlcm4gXCJtYWpvcml0eVwiLCB0aGUgdHJhbnNhY3Rpb24gb3BlcmF0aW9ucyBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlYWQgZnJvbSBhIHNuYXBzaG90IG9mIG1ham9yaXR5LWNvbW1pdHRlZCBkYXRhLlxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiAgICAgbCAgIGxvY2FsXG4gKiAgICAgYSAgIGF2YWlsYWJsZVxuICogICAgIG0gICBtYWpvcml0eVxuICogICAgIGx6ICBsaW5lYXJpemFibGVcbiAqICAgICBzICAgc25hcHNob3RcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIGNvbmNlcm4gW2hlcmVdKGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi8pLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbCBvbmUgb2YgdGhlIGxpc3RlZCByZWFkIGNvbmNlcm4gbGV2ZWwgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi9cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkQ29uY2VybiA9IFF1ZXJ5LnByb3RvdHlwZS5yID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgdGhpcy5vcHRpb25zLnJlYWRDb25jZXJuID0gdXRpbHMucmVhZENvbmNlcm4obGV2ZWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0YWlsYWJsZSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS50YWlsYWJsZSgpIDw9PSB0cnVlXG4gKiAgICAgcXVlcnkudGFpbGFibGUodHJ1ZSlcbiAqICAgICBxdWVyeS50YWlsYWJsZShmYWxzZSlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHYgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1RhaWxhYmxlK0N1cnNvcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3ZhbGlkYXRlKCd0YWlsYWJsZScpO1xuXG4gIHRoaXMub3B0aW9ucy50YWlsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICA/ICEhYXJndW1lbnRzWzBdXG4gICAgOiB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGBtb25nb2RgIHNlcnZlcnMsIG9yIHRhZyBzZXQgb2YgYG1vbmdvZGAgc2VydmVycyxcbiAqIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgYHdgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm4gb3B0aW9uc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKDApXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKDEpXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKHsgdzogMSwgajogdHJ1ZSwgd3RpbWVvdXQ6IDIwMDAgfSlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ20nKSAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCd0YWdTZXROYW1lJykgLy8gaWYgdGhlIHRhZyBzZXQgaXMgJ20nLCB1c2UgLndyaXRlQ29uY2Vybih7IHc6ICdtJyB9KSBpbnN0ZWFkXG4gKiAgICAgbXF1ZXJ5KCkudygxKSAvLyB3IGlzIGFsaWFzIG9mIHdyaXRlQ29uY2VyblxuICpcbiAqIEBtZXRob2Qgd3JpdGVDb25jZXJuXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfG9iamVjdH0gY29uY2VybiAwIGZvciBmaXJlLWFuZC1mb3JnZXQsIDEgZm9yIGFja25vd2xlZGdlZCBieSBvbmUgc2VydmVyLCAnbWFqb3JpdHknIGZvciBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQsIG9yIFthbnkgb2YgdGhlIG1vcmUgYWR2YW5jZWQgb3B0aW9uc10oaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLlxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3JpdGVDb25jZXJuID0gUXVlcnkucHJvdG90eXBlLncgPSBmdW5jdGlvbiB3cml0ZUNvbmNlcm4oY29uY2Vybikge1xuICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBjb25jZXJuKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi5qKSB0aGlzLm9wdGlvbnMuaiA9IGNvbmNlcm4uajtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLncpIHRoaXMub3B0aW9ucy53ID0gY29uY2Vybi53O1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4ud3RpbWVvdXQpIHRoaXMub3B0aW9ucy53dGltZW91dCA9IGNvbmNlcm4ud3RpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLncgPSAnbScgPT09IGNvbmNlcm4gPyAnbWFqb3JpdHknIDogY29uY2VybjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgdGltZSBsaW1pdCwgaW4gbWlsbGlzZWNvbmRzLCBmb3IgdGhlIHdyaXRlIGNvbmNlcm4uXG4gKiBJZiBgbXMgPiAxYCwgaXQgaXMgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGlzIHdyaXRlXG4gKiB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgcmVwbGljYSBzZXQgYmVmb3JlIHRoaXMgb3BlcmF0aW9uIGZhaWxzLlxuICogVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byBgd3RpbWVvdXRgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLncoMikuaih0cnVlKS53dGltZW91dCgyMDAwKVxuICpcbiAqIEBtZXRob2Qgd3RpbWVvdXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53dGltZW91dCA9IFF1ZXJ5LnByb3RvdHlwZS53VGltZW91dCA9IGZ1bmN0aW9uIHd0aW1lb3V0KG1zKSB7XG4gIHRoaXMub3B0aW9ucy53dGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWVyZ2VzIGFub3RoZXIgUXVlcnkgb3IgY29uZGl0aW9ucyBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBXaGVuIGEgUXVlcnkgaXMgcGFzc2VkLCBjb25kaXRpb25zLCBmaWVsZCBzZWxlY3Rpb24gYW5kIG9wdGlvbnMgYXJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fE9iamVjdH0gc291cmNlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAoIXNvdXJjZSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAoIVF1ZXJ5LmNhbk1lcmdlKHNvdXJjZSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudC4gRXhwZWN0ZWQgaW5zdGFuY2VvZiBtcXVlcnkgb3IgcGxhaW4gb2JqZWN0Jyk7XG5cbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgLy8gaWYgc291cmNlIGhhcyBhIGZlYXR1cmUsIGFwcGx5IGl0IHRvIG91cnNlbHZlc1xuXG4gICAgaWYgKHNvdXJjZS5fY29uZGl0aW9ucykge1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlLl9jb25kaXRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9maWVsZHMpIHtcbiAgICAgIHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fZmllbGRzLCBzb3VyY2UuX2ZpZWxkcyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5vcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMub3B0aW9ucywgc291cmNlLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX3VwZGF0ZURvYykge1xuICAgICAgdGhpcy5fdXBkYXRlRG9jIHx8ICh0aGlzLl91cGRhdGVEb2MgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgc291cmNlLl91cGRhdGVEb2MpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX2Rpc3RpbmN0RG9jKSB7XG4gICAgICB0aGlzLl9kaXN0aW5jdERvYyA9IHNvdXJjZS5fZGlzdGluY3REb2M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBwbGFpbiBvYmplY3RcbiAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluZHMgZG9jdW1lbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCh7IG5hbWU6ICdCdXJuaW5nIExpZ2h0cycgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZmluZCc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZCA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ19maW5kJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmQoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBxdWVyeSBjdXJzb3JcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBxdWVyeS5maW5kKCkuY3Vyc29yKCk7XG4gKiAgICAgcXVlcnkuY3Vyc29yKHsgbmFtZTogJ0J1cm5pbmcgTGlnaHRzJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnNvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24gY3Vyc29yKGNyaXRlcmlhKSB7XG4gIGlmICh0aGlzLm9wKSB7XG4gICAgaWYgKHRoaXMub3AgIT09ICdmaW5kJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmN1cnNvciBvbmx5IHN1cHBvcnQgLmZpbmQgbWV0aG9kJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluZChjcml0ZXJpYSk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2ZpbmRDdXJzb3InLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRDdXJzb3IoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYXMgYSBmaW5kT25lKCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZE9uZSgpLndoZXJlKCduYW1lJywgL15CdXJuaW5nLyk7XG4gKlxuICogICAgIHF1ZXJ5LmZpbmRPbmUoeyBuYW1lOiAvXkJ1cm5pbmcvIH0pXG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmUoeyBuYW1lOiAvXkJ1cm5pbmcvIH0pOyAvLyBleGVjdXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2ZpbmRPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN0dWVzIHRoZSBxdWVyeSBhcyBhIGNvdW50KCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY291bnQoKS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5leGVjKCk7XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50KHsgY29sb3I6ICdibGFjaycgfSlcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuY291bnQoeyBjb2xvcjogJ2JsYWNrJyB9KTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgcXVlcnkud2hlcmUoJ2NvbG9yJywgJ2JsYWNrJykuY291bnQoKTtcbiAqICAgICBjb25zb2xlLmxvZygndGhlcmUgYXJlICVkIGtpdHRlbnMnLCBjb3VudCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZ2dyZWdhdGlvbiNBZ2dyZWdhdGlvbi1Db3VudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2NvdW50JztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgY291bnRgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2NvdW50ID0gYXN5bmMgZnVuY3Rpb24gX2NvdW50KCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnMsXG4gICAgICBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBkZWJ1ZygnY291bnQnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uY291bnQoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBvciBleGVjdXRlcyBhIGRpc3RpbmN0KCkgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoY3JpdGVyaWEsIGZpZWxkKVxuICogICAgIGRpc3RpbmN0KGNyaXRlcmlhLCBmaWVsZClcbiAqICAgICBhd2FpdCBkaXN0aW5jdChmaWVsZClcbiAqICAgICBkaXN0aW5jdChmaWVsZClcbiAqICAgICBhd2FpdCBkaXN0aW5jdCgpXG4gKiAgICAgZGlzdGluY3QoKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpZWxkXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZ2dyZWdhdGlvbiNBZ2dyZWdhdGlvbi1EaXN0aW5jdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbihjcml0ZXJpYSwgZmllbGQpIHtcbiAgdGhpcy5vcCA9ICdkaXN0aW5jdCc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKCFmaWVsZCAmJiB0eXBlb2YgY3JpdGVyaWEgPT09ICdzdHJpbmcnKSB7XG4gICAgZmllbGQgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZmllbGQpIHtcbiAgICB0aGlzLl9kaXN0aW5jdERvYyA9IGZpZWxkO1xuICB9XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRpc3RpbmN0YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kaXN0aW5jdCA9IGFzeW5jIGZ1bmN0aW9uIF9kaXN0aW5jdCgpIHtcbiAgaWYgKCF0aGlzLl9kaXN0aW5jdERvYykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgZm9yIGBkaXN0aW5jdGAgaGFzIGJlZW4gZGVjbGFyZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGRlYnVnKCdkaXN0aW5jdCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kaXN0aW5jdCh0aGlzLl9kaXN0aW5jdERvYywgY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHVwZGF0ZU1hbnkoKWAgb3BlcmF0aW9uLiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIF9hbGxfIGRvY3VtZW50cyB0aGF0IG1hdGNoXG4gKiBgY3JpdGVyaWFgLCByYXRoZXIgdGhhbiBqdXN0IHRoZSBmaXJzdCBvbmUuXG4gKlxuICogX0FsbCBwYXRocyBwYXNzZWQgdGhhdCBhcmUgbm90ICRhdG9taWMgb3BlcmF0aW9ucyB3aWxsIGJlY29tZSAkc2V0IG9wcy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVcGRhdGUgZXZlcnkgZG9jdW1lbnQgd2hvc2UgYHRpdGxlYCBjb250YWlucyAndGVzdCdcbiAqICAgICBtcXVlcnkoKS51cGRhdGVNYW55KHsgdGl0bGU6IC90ZXN0LyB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnVwZGF0ZU1hbnkgPSBmdW5jdGlvbiB1cGRhdGVNYW55KGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlTWFueScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGB1cGRhdGVNYW55YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVNYW55ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAndXBkYXRlTWFueScpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHVwZGF0ZU9uZSgpYCBvcGVyYXRpb24uIFRoaXMgZnVuY3Rpb24gd2lsbCBfYWx3YXlzXyB1cGRhdGUganVzdCBvbmUgZG9jdW1lbnQsXG4gKiByZWdhcmRsZXNzIG9mIHRoZSBgbXVsdGlgIG9wdGlvbi5cbiAqXG4gKiBfQWxsIHBhdGhzIHBhc3NlZCB0aGF0IGFyZSBub3QgJGF0b21pYyBvcGVyYXRpb25zIHdpbGwgYmVjb21lICRzZXQgb3BzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgd2hvc2UgYHRpdGxlYCBjb250YWlucyAndGVzdCdcbiAqICAgICBtcXVlcnkoKS51cGRhdGVNYW55KHsgdGl0bGU6IC90ZXN0LyB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGB1cGRhdGVPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3VwZGF0ZU9uZScpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYW4gYHJlcGxhY2VPbmUoKWAgb3BlcmF0aW9uLiBTaW1pbGFyXG4gKiB0byBgdXBkYXRlT25lKClgLCBleGNlcHQgYHJlcGxhY2VPbmUoKWAgaXMgbm90IGFsbG93ZWQgdG8gdXNlIGF0b21pY1xuICogbW9kaWZpZXJzIChgJHNldGAsIGAkcHVzaGAsIGV0Yy4pLiBDYWxsaW5nIGByZXBsYWNlT25lKClgIHdpbGwgYWx3YXlzXG4gKiByZXBsYWNlIHRoZSBleGlzdGluZyBkb2MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBSZXBsYWNlIHRoZSBkb2N1bWVudCB3aXRoIGBfaWRgIDEgd2l0aCBgeyBfaWQ6IDEsIHllYXI6IDIwMTcgfWBcbiAqICAgICBtcXVlcnkoKS5yZXBsYWNlT25lKHsgX2lkOiAxIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVwbGFjZU9uZSA9IGZ1bmN0aW9uIHJlcGxhY2VPbmUoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyh7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgcmVwbGFjZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fcmVwbGFjZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3JlcGxhY2VPbmUnKTtcbn07XG5cbi8qIVxuICogSW50ZXJuYWwgaGVscGVyIGZvciB1cGRhdGVNYW55LCB1cGRhdGVPbmVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlKHF1ZXJ5LCBvcCwgY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBxdWVyeS5vcCA9IG9wO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICBxdWVyeS5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICBpZiAoZG9jKSB7XG4gICAgcXVlcnkuX21lcmdlVXBkYXRlKGRvYyk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAvLyB7IG92ZXJ3cml0ZTogdHJ1ZSB9XG4gICAgcXVlcnkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGRlLWR1cGxpY2F0aW5nIFwidXBkYXRlKlwiIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtRdWVyeX0gcXVlcnkgVGhlIFF1ZXJ5IE9iamVjdCAocmVwbGFjZW1lbnQgZm9yIFwidGhpc1wiKVxuICogQHBhcmFtIHtTdHJpbmd9IG9wIFRoZSBPcGVyYXRpb24gdG8gYmUgZG9uZVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZUV4ZWMocXVlcnksIG9wKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBxdWVyeS5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBjb25zdCBjcml0ZXJpYSA9IHF1ZXJ5Ll9jb25kaXRpb25zO1xuICBjb25zdCBkb2MgPSBxdWVyeS5fdXBkYXRlRm9yRXhlYygpO1xuXG4gIGRlYnVnKCd1cGRhdGUnLCBxdWVyeS5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHF1ZXJ5Ll9jb2xsZWN0aW9uW29wXShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlT25lKClgIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1xdWVyeShjb2xsZWN0aW9uKS5kZWxldGVPbmUoeyBhcnRpc3Q6ICdBbm5lIE11cnJheScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlT25lID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdkZWxldGVPbmUnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkZWxldGVPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgZGVsZXRlIG9wdGlvbnMuanVzdE9uZTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgZGVidWcoJ2RlbGV0ZU9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kZWxldGVPbmUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlTWFueSgpYCBvcGVyYXRpb24uIEFsd2F5cyBkZWxldGVzXG4gKiBfZXZlcnlfIGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgY3JpdGVyaWFgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgbXF1ZXJ5KGNvbGxlY3Rpb24pLmRlbGV0ZU1hbnkoeyBhcnRpc3Q6ICdBbm5lIE11cnJheScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZGVsZXRlTWFueSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRlbGV0ZU1hbnlgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGRlbGV0ZSBvcHRpb25zLmp1c3RPbmU7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGRlYnVnKCdkZWxldGVPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGVsZXRlTWFueShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgW2ZpbmRBbmRNb2RpZnldKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZCkgdXBkYXRlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZywgcGFzc2luZyBhbnkgYG9wdGlvbnNgLCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYG5ld2A6IGJvb2wgLSB0cnVlIHRvIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsLiBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIGB1cHNlcnRgOiBib29sIC0gY3JlYXRlcyB0aGUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUpIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSh1cGRhdGUpICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbcXVlcnldXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlID0gZnVuY3Rpb24oY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRVcGRhdGUnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgLy8gYXBwbHkgZG9jXG4gIGlmIChkb2MpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgb3B0aW9ucyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVBbmRVcGRhdGVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmRVcGRhdGUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGVGb3JFeGVjKCk7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmVBbmRVcGRhdGUoY29uZHMsIHVwZGF0ZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgW2ZpbmRBbmRNb2RpZnldKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZCkgcmVtb3ZlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgcmV0dXJuaW5nIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucywgb3B0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zLCBvcHRpb25zKSAgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zKSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoKSAgIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKCkgICAgICAgICAgIC8vIGFsaWFzIG9mIC5maW5kT25lQW5kUmVtb3ZlKClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlbW92ZSA9IFF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRSZW1vdmUnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIC8vIGFwcGx5IGNvbmRpdGlvbnNcbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcbiAgfVxuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgb3B0aW9ucyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVBbmRSZW1vdmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmRSZW1vdmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQWRkIHRyYWNlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcXVlcnkgaXMgZXhlY3V0ZWQuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCAobWV0aG9kLCBxdWVyeUluZm8sIHF1ZXJ5KSBhbmRcbiAqIHNob3VsZCByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZFxuICogd2l0aCAoZXJyLCByZXN1bHQsIG1pbGxpcykgd2hlbiB0aGUgcXVlcnkgaXMgY29tcGxldGUuXG4gKlxuICogcXVlcnlJbmZvIGlzIGFuIG9iamVjdCBjb250YWluaW5nOiB7XG4gKiAgIGNvbGxlY3Rpb25OYW1lOiA8bmFtZSBvZiB0aGUgY29sbGVjdGlvbj4sXG4gKiAgIGNvbmRpdGlvbnM6IDxxdWVyeSBjcml0ZXJpYT4sXG4gKiAgIG9wdGlvbnM6IDxjb21tZW50LCBmaWVsZHMsIHJlYWRQcmVmZXJlbmNlLCBldGM+LFxuICogICBkb2M6IFtkb2N1bWVudCB0byB1cGRhdGUsIGlmIGFwcGxpY2FibGVdXG4gKiB9XG4gKlxuICogTk9URTogRG9lcyBub3QgdHJhY2Ugc3RyZWFtIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhY2VGdW5jdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zZXRUcmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24odHJhY2VGdW5jdGlvbikge1xuICB0aGlzLl90cmFjZUZ1bmN0aW9uID0gdHJhY2VGdW5jdGlvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIHF1ZXJ5LmV4ZWMoKTtcbiAqICAgICBhd2FpdCBxdWVyeS5leGVjKCk7XG4gKiAgICAgcXVlcnkuZXhlYygndXBkYXRlJyk7XG4gKiAgICAgYXdhaXQgcXVlcnkuZXhlYygnZmluZCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3BlcmF0aW9uXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGV4ZWMob3ApIHtcbiAgaWYgKHR5cGVvZiBvcCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLm9wID0gb3A7XG4gIH1cblxuICBhc3NlcnQub2sodGhpcy5vcCwgJ01pc3NpbmcgcXVlcnkgdHlwZTogKGZpbmQsIGV0YyknKTtcblxuICBjb25zdCBmbk5hbWUgPSAnXycgKyB0aGlzLm9wO1xuXG4gIC8vIGJldHRlciBlcnJvciwgYmVjYXVzZSBkZWZhdWx0IHdvdWxkIGxpc3QgaXQgYXMgXCJ0aGlzW2ZuTmFtZV0gaXMgbm90IGEgZnVuY3Rpb25cIlxuICBpZiAodHlwZW9mIHRoaXNbZm5OYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRoaXNbJHtmbk5hbWV9XSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXNbZm5OYW1lXSgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRoZW4gPSBhc3luYyBmdW5jdGlvbihyZXMsIHJlaikge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihyZXMsIHJlaik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiBgZmluZGAgcXVlcnkuXG4gKlxuICogQHRocm93cyBFcnJvciBpZiBvcGVyYXRpb24gaXMgbm90IGEgZmluZFxuICogQHJldHVybnMge0N1cnNvcn0gTW9uZ29EQiBkcml2ZXIgY3Vyc29yXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoJ2ZpbmQnICE9IHRoaXMub3ApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJzb3IoKSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgZmluZCcpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnY3Vyc29yJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRDdXJzb3IoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICByZXR1cm4gISEodGhpcy5fZmllbGRzICYmIE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcykubGVuZ3RoID4gMCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgaW5jbHVzaXZlIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJ25hbWUnKVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRJbmNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkSW5jbHVzaXZlbHkoKSB7XG4gIGlmICghdGhpcy5fZmllbGRzKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcyk7XG4gIGlmICgwID09PSBrZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKDAgPT09IHRoaXMuX2ZpZWxkc1trZXldKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2ZpZWxkc1trZXldICYmXG4gICAgICAgIHR5cGVvZiB0aGlzLl9maWVsZHNba2V5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdGhpcy5fZmllbGRzW2tleV0uJG1ldGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBleGNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIGZhbHNlXG4gKiAgICAgcXVlcnkuc2VsZWN0KCctbmFtZScpXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyBmYWxzZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZEV4Y2x1c2l2ZWx5ID0gZnVuY3Rpb24gc2VsZWN0ZWRFeGNsdXNpdmVseSgpIHtcbiAgaWYgKCF0aGlzLl9maWVsZHMpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZmllbGRzKTtcbiAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoMCA9PT0gdGhpcy5fZmllbGRzW2tleV0pIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGRvY2Agd2l0aCB0aGUgY3VycmVudCB1cGRhdGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX21lcmdlVXBkYXRlID0gZnVuY3Rpb24oZG9jKSB7XG4gIGlmICghdGhpcy5fdXBkYXRlRG9jKSB0aGlzLl91cGRhdGVEb2MgPSB7fTtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgaWYgKGRvYy5fdXBkYXRlRG9jKSB7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgZG9jLl91cGRhdGVEb2MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZURvYywgZG9jKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX29wdGlvbnNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB1dGlscy5jbG9uZSh0aGlzLm9wdGlvbnMpO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyBmaWVsZHMgc2VsZWN0aW9uIGZvciB0aGlzIHF1ZXJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmllbGRzRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXRpbHMuY2xvbmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIHVwZGF0ZSBkb2N1bWVudCB3aXRoIGNvcnJlY3RlZCAkc2V0IG9wZXJhdGlvbnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl91cGRhdGVGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IHV0aWxzLmNsb25lKHRoaXMuX3VwZGF0ZURvYyk7XG4gIGNvbnN0IG9wcyA9IHV0aWxzLmtleXModXBkYXRlKTtcbiAgY29uc3QgcmV0ID0ge307XG5cbiAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoJyQnICE9PSBvcFswXSkge1xuICAgICAgLy8gZml4IHVwICRzZXQgc3VnYXJcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS4kc2V0KSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB1cGRhdGUuJHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQuJHNldCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXQuJHNldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgaWYgKCF+b3BzLmluZGV4T2YoJyRzZXQnKSkgb3BzLnB1c2goJyRzZXQnKTtcbiAgICB9IGVsc2UgaWYgKCckc2V0JyA9PT0gb3ApIHtcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NvbXBpbGVkVXBkYXRlID0gcmV0O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgX3BhdGggaXMgc2V0LlxuICpcbiAqIEBwYXJtYW0ge1N0cmluZ30gbWV0aG9kXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9lbnN1cmVQYXRoID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghdGhpcy5fcGF0aCkge1xuICAgIGNvbnN0IG1zZyA9IG1ldGhvZCArICcoKSBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmUoKSAnXG4gICAgICAgICAgICAgICAgICAgICArICd3aGVuIGNhbGxlZCB3aXRoIHRoZXNlIGFyZ3VtZW50cyc7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn07XG5cbi8qIVxuICogUGVybWlzc2lvbnNcbiAqL1xuXG5RdWVyeS5wZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4vcGVybWlzc2lvbnMnKTtcblxuUXVlcnkuX2lzUGVybWl0dGVkID0gZnVuY3Rpb24oYSwgYikge1xuICBjb25zdCBkZW5pZWQgPSBRdWVyeS5wZXJtaXNzaW9uc1tiXTtcbiAgaWYgKCFkZW5pZWQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHJ1ZSAhPT0gZGVuaWVkW2FdO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICBsZXQgZmFpbDtcbiAgbGV0IHZhbGlkYXRvcjtcblxuICBpZiAodW5kZWZpbmVkID09PSBhY3Rpb24pIHtcblxuICAgIHZhbGlkYXRvciA9IFF1ZXJ5LnBlcm1pc3Npb25zW3RoaXMub3BdO1xuICAgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiB2YWxpZGF0b3IpIHJldHVybiB0cnVlO1xuXG4gICAgZmFpbCA9IHZhbGlkYXRvcih0aGlzKTtcblxuICB9IGVsc2UgaWYgKCFRdWVyeS5faXNQZXJtaXR0ZWQoYWN0aW9uLCB0aGlzLm9wKSkge1xuICAgIGZhaWwgPSBhY3Rpb247XG4gIH1cblxuICBpZiAoZmFpbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmYWlsICsgJyBjYW5ub3QgYmUgdXNlZCB3aXRoICcgKyB0aGlzLm9wKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBjb25kc2AgY2FuIGJlIG1lcmdlZCB1c2luZyBgbXF1ZXJ5KCkubWVyZ2UoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkuY2FuTWVyZ2UgPSBmdW5jdGlvbihjb25kcykge1xuICByZXR1cm4gY29uZHMgaW5zdGFuY2VvZiBRdWVyeSB8fCB1dGlscy5pc09iamVjdChjb25kcyk7XG59O1xuXG4vKipcbiAqIFNldCBhIHRyYWNlIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW5ldmVyIGFcbiAqIHF1ZXJ5IGlzIGV4ZWN1dGVkLlxuICpcbiAqIFNlZSBgc2V0VHJhY2VGdW5jdGlvbigpYCBmb3IgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblF1ZXJ5LnNldEdsb2JhbFRyYWNlRnVuY3Rpb24gPSBmdW5jdGlvbih0cmFjZUZ1bmN0aW9uKSB7XG4gIFF1ZXJ5LnRyYWNlRnVuY3Rpb24gPSB0cmFjZUZ1bmN0aW9uO1xufTtcblxuLyohXG4gKiBFeHBvcnRzLlxuICovXG5cblF1ZXJ5LnV0aWxzID0gdXRpbHM7XG5RdWVyeS5lbnYgPSByZXF1aXJlKCcuL2VudicpO1xuUXVlcnkuQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuUXVlcnkuQmFzZUNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24vY29sbGVjdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gUXVlcnk7XG5cbi8vIFRPRE9cbi8vIHRlc3QgdXRpbHNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst denied = exports;\n\ndenied.distinct = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.distinct);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.distinct.select =\ndenied.distinct.slice =\ndenied.distinct.sort =\ndenied.distinct.limit =\ndenied.distinct.skip =\ndenied.distinct.batchSize =\ndenied.distinct.hint =\ndenied.distinct.tailable = true;\n\n\n// aggregation integration\n\n\ndenied.findOneAndUpdate =\ndenied.findOneAndRemove = function(self) {\n  const keys = Object.keys(denied.findOneAndUpdate);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.findOneAndUpdate.limit =\ndenied.findOneAndUpdate.skip =\ndenied.findOneAndUpdate.batchSize =\ndenied.findOneAndUpdate.tailable = true;\n\n\ndenied.count = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.count);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\n\ndenied.count.slice =\ndenied.count.batchSize =\ndenied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wYXVsL3Byb2plY3RzL3BheWxvYWQvcGx1Z2luLWRldmVsb3BtZW50L2JldHRlci1maWVsZHMvZ2l0cm9vdC9ub2RlX21vZHVsZXMvLnBucG0vbXF1ZXJ5QDUuMC4wL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3Blcm1pc3Npb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVuaWVkID0gZXhwb3J0cztcblxuZGVuaWVkLmRpc3RpbmN0ID0gZnVuY3Rpb24oc2VsZikge1xuICBpZiAoc2VsZi5fZmllbGRzICYmIE9iamVjdC5rZXlzKHNlbGYuX2ZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnZmllbGQgc2VsZWN0aW9uIGFuZCBzbGljZSc7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmRpc3RpbmN0KTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5kZW5pZWQuZGlzdGluY3Quc2VsZWN0ID1cbmRlbmllZC5kaXN0aW5jdC5zbGljZSA9XG5kZW5pZWQuZGlzdGluY3Quc29ydCA9XG5kZW5pZWQuZGlzdGluY3QubGltaXQgPVxuZGVuaWVkLmRpc3RpbmN0LnNraXAgPVxuZGVuaWVkLmRpc3RpbmN0LmJhdGNoU2l6ZSA9XG5kZW5pZWQuZGlzdGluY3QuaGludCA9XG5kZW5pZWQuZGlzdGluY3QudGFpbGFibGUgPSB0cnVlO1xuXG5cbi8vIGFnZ3JlZ2F0aW9uIGludGVncmF0aW9uXG5cblxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUgPVxuZGVuaWVkLmZpbmRPbmVBbmRSZW1vdmUgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuZmluZE9uZUFuZFVwZGF0ZSk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUubGltaXQgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUuc2tpcCA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5iYXRjaFNpemUgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUudGFpbGFibGUgPSB0cnVlO1xuXG5cbmRlbmllZC5jb3VudCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgaWYgKHNlbGYuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyhzZWxmLl9maWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ2ZpZWxkIHNlbGVjdGlvbiBhbmQgc2xpY2UnO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5jb3VudCk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG5kZW5pZWQuY291bnQuc2xpY2UgPVxuZGVuaWVkLmNvdW50LmJhdGNoU2l6ZSA9XG5kZW5pZWQuY291bnQudGFpbGFibGUgPSB0cnVlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js":
/*!***************************************************************************!*\
  !*** ../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst specialProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nconst clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return new RegExp(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return Buffer.from(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  const minimize = options && options.minimize,\n      ret = {},\n      keys = Object.keys(obj),\n      len = keys.length;\n  let hasKeys = false,\n      val,\n      k = '',\n      i = 0;\n\n  for (i = 0; i < len; ++i) {\n    k = keys[i];\n    // Not technically prototype pollution because this wouldn't merge properties\n    // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n    if (specialProperties.indexOf(k) !== -1) {\n      continue;\n    }\n\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  const ret = [],\n      l = arr.length;\n  let i = 0;\n  for (; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nconst _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nconst isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys;\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() { }\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21xdWVyeUA1LjAuMC9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxZQUFZO0FBQ1o7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wYXVsL3Byb2plY3RzL3BheWxvYWQvcGx1Z2luLWRldmVsb3BtZW50L2JldHRlci1maWVsZHMvZ2l0cm9vdC9ub2RlX21vZHVsZXMvLnBucG0vbXF1ZXJ5QDUuMC4wL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG5cbi8qKlxuICogQ2xvbmVzIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjbG9uZWQgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBjbG9uZSA9IGV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmosIG9wdGlvbnMpIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gb2JqO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgcmV0dXJuIGV4cG9ydHMuY2xvbmVBcnJheShvYmosIG9wdGlvbnMpO1xuXG4gIGlmIChvYmouY29uc3RydWN0b3IpIHtcbiAgICBpZiAoL09iamVjdElbZERdJC8udGVzdChvYmouY29uc3RydWN0b3IubmFtZSkpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmouY2xvbmVcbiAgICAgICAgPyBvYmouY2xvbmUoKVxuICAgICAgICA6IG5ldyBvYmouY29uc3RydWN0b3Iob2JqLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdSZWFkUHJlZmVyZW5jZScpIHtcbiAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai5tb2RlLCBjbG9uZShvYmoudGFncywgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmICgnQmluYXJ5JyA9PSBvYmouX2Jzb250eXBlICYmIG9iai5idWZmZXIgJiYgb2JqLnZhbHVlKSB7XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLmNsb25lXG4gICAgICAgID8gb2JqLmNsb25lKClcbiAgICAgICAgOiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai52YWx1ZSh0cnVlKSwgb2JqLnN1Yl90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoJ0RhdGUnID09PSBvYmouY29uc3RydWN0b3IubmFtZSB8fCAnRnVuY3Rpb24nID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKCtvYmopO1xuXG4gICAgaWYgKCdSZWdFeHAnID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XG5cbiAgICBpZiAoJ0J1ZmZlcicgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG9iaik7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob2JqKSlcbiAgICByZXR1cm4gZXhwb3J0cy5jbG9uZU9iamVjdChvYmosIG9wdGlvbnMpO1xuXG4gIGlmIChvYmoudmFsdWVPZilcbiAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucykge1xuICBjb25zdCBtaW5pbWl6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5taW5pbWl6ZSxcbiAgICAgIHJldCA9IHt9LFxuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaiksXG4gICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGhhc0tleXMgPSBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICAgIGsgPSAnJyxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGsgPSBrZXlzW2ldO1xuICAgIC8vIE5vdCB0ZWNobmljYWxseSBwcm90b3R5cGUgcG9sbHV0aW9uIGJlY2F1c2UgdGhpcyB3b3VsZG4ndCBtZXJnZSBwcm9wZXJ0aWVzXG4gICAgLy8gb250byBgT2JqZWN0LnByb3RvdHlwZWAsIGJ1dCBhdm9pZCBwcm9wZXJ0aWVzIGxpa2UgX19wcm90b19fIGFzIGEgcHJlY2F1dGlvbi5cbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrKSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbCA9IGNsb25lKG9ialtrXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIW1pbmltaXplIHx8ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHZhbCkpIHtcbiAgICAgIGhhc0tleXMgfHwgKGhhc0tleXMgPSB0cnVlKTtcbiAgICAgIHJldFtrXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluaW1pemVcbiAgICA/IGhhc0tleXMgJiYgcmV0XG4gICAgOiByZXQ7XG59O1xuXG5leHBvcnRzLmNsb25lQXJyYXkgPSBmdW5jdGlvbiBjbG9uZUFycmF5KGFyciwgb3B0aW9ucykge1xuICBjb25zdCByZXQgPSBbXSxcbiAgICAgIGwgPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKVxuICAgIHJldC5wdXNoKGNsb25lKGFycltpXSwgb3B0aW9ucykpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRvLCBmcm9tKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0b1trZXldKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICAgIG1lcmdlKHRvW2tleV0sIGZyb21ba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTYW1lIGFzIG1lcmdlIGJ1dCBjbG9uZXMgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm1lcmdlQ2xvbmUgPSBmdW5jdGlvbiBtZXJnZUNsb25lKHRvLCBmcm9tKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0b1trZXldKSB7XG4gICAgICB0b1trZXldID0gY2xvbmUoZnJvbVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cG9ydHMuaXNPYmplY3QoZnJvbVtrZXldKSkge1xuICAgICAgICBtZXJnZUNsb25lKHRvW2tleV0sIGZyb21ba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1trZXldID0gY2xvbmUoZnJvbVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVhZCBwcmVmIGhlbHBlciAobW9uZ28gMi4yIGRyaXZlcnMgc3VwcG9ydCB0aGlzKVxuICpcbiAqIEFsbG93cyB1c2luZyBhbGlhc2VzIGluc3RlYWQgb2YgZnVsbCBwcmVmZXJlbmNlIG5hbWVzOlxuICpcbiAqICAgICBwICAgcHJpbWFyeVxuICogICAgIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiAgICAgcyAgIHNlY29uZGFyeVxuICogICAgIHNwICBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqICAgICBuICAgbmVhcmVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmXG4gKi9cblxuZXhwb3J0cy5yZWFkUHJlZiA9IGZ1bmN0aW9uIHJlYWRQcmVmKHByZWYpIHtcbiAgc3dpdGNoIChwcmVmKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHAnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3MnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3AnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBwcmVmID0gJ25lYXJlc3QnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlZjtcbn07XG5cblxuLyoqXG4gKiBSZWFkIENvbmNlcm4gaGVscGVyIChtb25nbyAzLjIgZHJpdmVycyBzdXBwb3J0IHRoaXMpXG4gKlxuICogQWxsb3dzIHVzaW5nIHN0cmluZyB0byBzcGVjaWZ5IHJlYWQgY29uY2VybiBsZXZlbDpcbiAqXG4gKiAgICAgbG9jYWwgICAgICAgICAgMy4yK1xuICogICAgIGF2YWlsYWJsZSAgICAgIDMuNitcbiAqICAgICBtYWpvcml0eSAgICAgICAzLjIrXG4gKiAgICAgbGluZWFyaXphYmxlICAgMy40K1xuICogICAgIHNuYXBzaG90ICAgICAgIDQuMCtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmNlcm5cbiAqL1xuXG5leHBvcnRzLnJlYWRDb25jZXJuID0gZnVuY3Rpb24gcmVhZENvbmNlcm4oY29uY2Vybikge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBjb25jZXJuKSB7XG4gICAgc3dpdGNoIChjb25jZXJuKSB7XG4gICAgICBjYXNlICdsJzpcbiAgICAgICAgY29uY2VybiA9ICdsb2NhbCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNvbmNlcm4gPSAnYXZhaWxhYmxlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgY29uY2VybiA9ICdtYWpvcml0eSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbHonOlxuICAgICAgICBjb25jZXJuID0gJ2xpbmVhcml6YWJsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNvbmNlcm4gPSAnc25hcHNob3QnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uY2VybiA9IHsgbGV2ZWw6IGNvbmNlcm4gfTtcbiAgfVxuICByZXR1cm4gY29uY2Vybjtcbn07XG5cbi8qKlxuICogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsIGhlbHBlclxuICovXG5cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5leHBvcnRzLnRvU3RyaW5nID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChhcmcpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmNvbnN0IGlzT2JqZWN0ID0gZXhwb3J0cy5pc09iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XScgPT0gZXhwb3J0cy50b1N0cmluZyhhcmcpO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBoZWxwZXJcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcblxuLyoqXG4gKiBCYXNpYyBPYmplY3QuY3JlYXRlIHBvbHlmaWxsLlxuICogT25seSBvbmUgYXJndW1lbnQgaXMgc3VwcG9ydGVkLlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuICovXG5cbmV4cG9ydHMuY3JlYXRlID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgT2JqZWN0LmNyZWF0ZVxuICA/IE9iamVjdC5jcmVhdGVcbiAgOiBjcmVhdGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZShwcm90bykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGluZyBwcm9wZXJ0aWVzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEYoKSB7IH1cbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuXG4vKipcbiAqIGluaGVyaXRhbmNlXG4gKi9cblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnByb3RvdHlwZSA9IGV4cG9ydHMuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUpO1xuICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIGFuIGFyZ3VtZW50cyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FueX0gdlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/mquery@5.0.0/node_modules/mquery/lib/utils.js\n");

/***/ })

};
;