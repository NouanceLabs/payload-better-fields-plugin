"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+table@0.20.0";
exports.ids = ["vendor-chunks/@lexical+table@0.20.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $findCellNode: () => (/* binding */ $findCellNode),\n/* harmony export */   $findTableNode: () => (/* binding */ $findTableNode),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/../node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/../node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(rsc)/../node_modules/.pnpm/@lexical+clipboard@0.20.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    return $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined).setRowSpan(rowSpan).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lexicalNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = grid.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n        }\n        nodeMap.set(cell.getKey(), cell);\n        for (const child of $getChildrenRecursively(cell)) {\n          nodeMap.set(child.getKey(), child);\n        }\n        lastRow = currentRow;\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n          editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      const cellNodes = selection.getNodes().filter($isTableCellNode);\n      const paragraph = cellNodes[0].getFirstChild();\n      const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n      cellNodes.forEach(cellNode => {\n        anchor.set(cellNode.getKey(), 0, 'element');\n        focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n        formatSelection.formatText(type, alignFormatWith);\n      });\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n      this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n          const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => deatatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove,\n      onMouseUp\n    };\n  };\n  const onMouseDown = event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n      editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n    }, 0);\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction deatatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = Object.freeze(colWidths) ;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const tableNode = $createTableNode();\n    tableNode.__rowStriping = serializedNode.rowStriping || false;\n    tableNode.__colWidths = serializedNode.colWidths;\n    return tableNode;\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined,\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n            const cols = tableElement.querySelectorAll('col');\n            colGroup.append(...cols);\n            const rows = tableElement.querySelectorAll('tr');\n            tBody.append(...rows);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    this.getWritable().__rowStriping = newRowStriping;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      const width = col.style.width;\n      if (!width || !PIXEL_VALUE_REG_EXP.test(width)) {\n        columns = undefined;\n        break;\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3RhYmxlQDAuMjAuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRJO0FBQyswQjtBQUN0NEI7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVztBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFZzZCIiwic291cmNlcyI6WyIvaG9tZS9wYXVsL3Byb2plY3RzL3BheWxvYWQvcGx1Z2luLWRldmVsb3BtZW50L2JldHRlci1maWVsZHMvZ2l0cm9vdC9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4yMC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsICRmaW5kTWF0Y2hpbmdQYXJlbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgb2JqZWN0S2xhc3NFcXVhbHMsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBFbGVtZW50Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkaXNUZXh0Tm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBjcmVhdGVDb21tYW5kLCAkY3JlYXRlVGV4dE5vZGUsICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkY3JlYXRlUG9pbnQsICRpc1BhcmFncmFwaE5vZGUsICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTCwgJGdldE5vZGVCeUtleSwgaXNDdXJyZW50bHlSZWFkT25seU1vZGUsIFRFWFRfVFlQRV9UT19GT1JNQVQsICRzZXRTZWxlY3Rpb24sIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGdldFJvb3QsIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfSElHSCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBLRVlfRVNDQVBFX0NPTU1BTkQsIERFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBLRVlfREVMRVRFX0NPTU1BTkQsIENVVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIEtFWV9UQUJfQ09NTUFORCwgRk9DVVNfQ09NTUFORCwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc0RlY29yYXRvck5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGNvcHlUb0NsaXBib2FyZCwgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uIH0gZnJvbSAnQGxleGljYWwvY2xpcGJvYXJkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBQSVhFTF9WQUxVRV9SRUdfRVhQID0gL14oXFxkKyg/OlxcLlxcZCspPylweCQvO1xuXG4vLyAuUGxheWdyb3VuZEVkaXRvclRoZW1lX190YWJsZUNlbGwgd2lkdGggdmFsdWUgZnJvbVxuLy8gcGFja2FnZXMvbGV4aWNhbC1wbGF5Z3JvdW5kL3NyYy90aGVtZXMvUGxheWdyb3VuZEVkaXRvclRoZW1lLmNzc1xuY29uc3QgQ09MVU1OX1dJRFRIID0gNzU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgVGFibGVDZWxsSGVhZGVyU3RhdGVzID0ge1xuICBCT1RIOiAzLFxuICBDT0xVTU46IDIsXG4gIE5PX1NUQVRVUzogMCxcbiAgUk9XOiAxXG59O1xuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlQ2VsbE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKG5vZGUuX19oZWFkZXJTdGF0ZSwgbm9kZS5fX2NvbFNwYW4sIG5vZGUuX193aWR0aCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20obm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICAgIHRoaXMuX19yb3dTcGFuID0gbm9kZS5fX3Jvd1NwYW47XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG5vZGUuX19iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGQ6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdGg6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IGNvbFNwYW4gPSBzZXJpYWxpemVkTm9kZS5jb2xTcGFuIHx8IDE7XG4gICAgY29uc3Qgcm93U3BhbiA9IHNlcmlhbGl6ZWROb2RlLnJvd1NwYW4gfHwgMTtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHNlcmlhbGl6ZWROb2RlLndpZHRoIHx8IHVuZGVmaW5lZCkuc2V0Um93U3Bhbihyb3dTcGFuKS5zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGwpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICB0aGlzLl9fcm93U3BhbiA9IDE7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fYmFja2dyb3VuZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbCwgdGhpcy5oYXNIZWFkZXIoKSAmJiBjb25maWcudGhlbWUudGFibGVDZWxsSGVhZGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgZWxlbWVudF8gPSBlbGVtZW50O1xuICAgICAgZWxlbWVudF8uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7XG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnRfLmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgICAgZWxlbWVudF8ucm93U3BhbiA9IHRoaXMuX19yb3dTcGFuO1xuICAgICAgfVxuICAgICAgZWxlbWVudF8uc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgQ09MVU1OX1dJRFRIfXB4YDtcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAndG9wJztcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnRleHRBbGlnbiA9ICdzdGFydCc7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpO1xuICAgICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50Xy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzSGVhZGVyKCkpIHtcbiAgICAgICAgZWxlbWVudF8uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmMmYzZjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICBoZWFkZXJTdGF0ZTogdGhpcy5fX2hlYWRlclN0YXRlLFxuICAgICAgcm93U3BhbjogdGhpcy5fX3Jvd1NwYW4sXG4gICAgICB0eXBlOiAndGFibGVjZWxsJyxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgICB9O1xuICB9XG4gIGdldENvbFNwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19jb2xTcGFuO1xuICB9XG4gIHNldENvbFNwYW4oY29sU3Bhbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFJvd1NwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19yb3dTcGFuO1xuICB9XG4gIHNldFJvd1NwYW4ocm93U3Bhbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNIZWFkZXIoKSA/ICd0aCcgOiAndGQnO1xuICB9XG4gIHNldEhlYWRlclN0eWxlcyhoZWFkZXJTdGF0ZSwgbWFzayA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faGVhZGVyU3RhdGUgPSBoZWFkZXJTdGF0ZSAmIG1hc2sgfCBzZWxmLl9faGVhZGVyU3RhdGUgJiB+bWFzaztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRIZWFkZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZTtcbiAgfVxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3dpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX193aWR0aDtcbiAgfVxuICBnZXRCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgc2V0QmFja2dyb3VuZENvbG9yKG5ld0JhY2tncm91bmRDb2xvcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2JhY2tncm91bmRDb2xvciA9IG5ld0JhY2tncm91bmRDb2xvcjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0b2dnbGVIZWFkZXJTdHlsZShoZWFkZXJTdGF0ZVRvVG9nZ2xlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBpZiAoKHNlbGYuX19oZWFkZXJTdGF0ZSAmIGhlYWRlclN0YXRlVG9Ub2dnbGUpID09PSBoZWFkZXJTdGF0ZVRvVG9nZ2xlKSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgLT0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fX2hlYWRlclN0YXRlICs9IGhlYWRlclN0YXRlVG9Ub2dnbGU7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGhhc0hlYWRlclN0YXRlKGhlYWRlclN0YXRlKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldEhlYWRlclN0eWxlcygpICYgaGVhZGVyU3RhdGUpID09PSBoZWFkZXJTdGF0ZTtcbiAgfVxuICBoYXNIZWFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZSAhPT0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX19oZWFkZXJTdGF0ZSAhPT0gdGhpcy5fX2hlYWRlclN0YXRlIHx8IHByZXZOb2RlLl9fd2lkdGggIT09IHRoaXMuX193aWR0aCB8fCBwcmV2Tm9kZS5fX2NvbFNwYW4gIT09IHRoaXMuX19jb2xTcGFuIHx8IHByZXZOb2RlLl9fcm93U3BhbiAhPT0gdGhpcy5fX3Jvd1NwYW4gfHwgcHJldk5vZGUuX19iYWNrZ3JvdW5kQ29sb3IgIT09IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLndpZHRoKSkge1xuICAgIHdpZHRoID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS53aWR0aCk7XG4gIH1cbiAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKG5vZGVOYW1lID09PSAndGgnID8gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVyA6IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGRvbU5vZGVfLmNvbFNwYW4sIHdpZHRoKTtcbiAgdGFibGVDZWxsTm9kZS5fX3Jvd1NwYW4gPSBkb21Ob2RlXy5yb3dTcGFuO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkb21Ob2RlXy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICcnKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBjb25zdCBzdHlsZSA9IGRvbU5vZGVfLnN0eWxlO1xuICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IChzdHlsZSAmJiBzdHlsZS50ZXh0RGVjb3JhdGlvbiB8fCAnJykuc3BsaXQoJyAnKTtcbiAgY29uc3QgaGFzQm9sZEZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0ID09PSAnNzAwJyB8fCBzdHlsZS5mb250V2VpZ2h0ID09PSAnYm9sZCc7XG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygnbGluZS10aHJvdWdoJyk7XG4gIGNvbnN0IGhhc0l0YWxpY0ZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYyc7XG4gIGNvbnN0IGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ3VuZGVybGluZScpO1xuICByZXR1cm4ge1xuICAgIGFmdGVyOiBjaGlsZExleGljYWxOb2RlcyA9PiB7XG4gICAgICBpZiAoY2hpbGRMZXhpY2FsTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRMZXhpY2FsTm9kZXM7XG4gICAgfSxcbiAgICBmb3JDaGlsZDogKGxleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSkgPT4ge1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUocGFyZW50TGV4aWNhbE5vZGUpICYmICEkaXNFbGVtZW50Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGxleGljYWxOb2RlKSAmJiBsZXhpY2FsTm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAgICAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnaXRhbGljJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCd1bmRlcmxpbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQobGV4aWNhbE5vZGUpO1xuICAgICAgICByZXR1cm4gcGFyYWdyYXBoTm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCBjb2xTcGFuID0gMSwgd2lkdGgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3Bhbiwgd2lkdGgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCTEVfQ09NTUFORCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVSb3dOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZXJvdyc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlUm93Tm9kZShub2RlLl9faGVpZ2h0LCBub2RlLl9fa2V5KTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlUm93RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVSb3dOb2RlKHNlcmlhbGl6ZWROb2RlLmhlaWdodCk7XG4gIH1cbiAgY29uc3RydWN0b3IoaGVpZ2h0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgLi4uKHRoaXMuZ2V0SGVpZ2h0KCkgJiYge1xuICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KClcbiAgICAgIH0pLFxuICAgICAgdHlwZTogJ3RhYmxlcm93JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICBpZiAodGhpcy5fX2hlaWdodCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9faGVpZ2h0fXB4YDtcbiAgICB9XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUudGFibGVSb3cpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzLl9faGVpZ2h0O1xuICB9XG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlaWdodDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX19oZWlnaHQgIT09IHRoaXMuX19oZWlnaHQ7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZVJvd0VsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBkb21Ob2RlXyA9IGRvbU5vZGU7XG4gIGxldCBoZWlnaHQgPSB1bmRlZmluZWQ7XG4gIGlmIChQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3QoZG9tTm9kZV8uc3R5bGUuaGVpZ2h0KSkge1xuICAgIGhlaWdodCA9IHBhcnNlRmxvYXQoZG9tTm9kZV8uc3R5bGUuaGVpZ2h0KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVSb3dOb2RlKGhlaWdodCkpO1xufVxuZnVuY3Rpb24gJGlzVGFibGVSb3dOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZVJvd05vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgaW5jbHVkZUhlYWRlcnMgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgZm9yIChsZXQgaVJvdyA9IDA7IGlSb3cgPCByb3dDb3VudDsgaVJvdysrKSB7XG4gICAgY29uc3QgdGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgIGZvciAobGV0IGlDb2x1bW4gPSAwOyBpQ29sdW1uIDwgY29sdW1uQ291bnQ7IGlDb2x1bW4rKykge1xuICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgIGlmICh0eXBlb2YgaW5jbHVkZUhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLnJvd3MpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLmNvbHVtbnMpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKCRjcmVhdGVUZXh0Tm9kZSgpKTtcbiAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgdGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICB9XG4gICAgdGFibGVOb2RlLmFwcGVuZCh0YWJsZVJvd05vZGUpO1xuICB9XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZShzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlUm93Tm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZVJvd05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVSb3dOb2RlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVSb3dOb2RlKSk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuIHRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVDZWxsTm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZSk7XG4gIHJldHVybiB7XG4gICAgYWJvdmU6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5IC0gMSwgdGFibGUpLFxuICAgIGJlbG93OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSArIDEsIHRhYmxlKSxcbiAgICBsZWZ0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCAtIDEsIHksIHRhYmxlKSxcbiAgICByaWdodDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggKyAxLCB5LCB0YWJsZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgodGFibGVOb2RlLCBpbmRleFRvRGVsZXRlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAoaW5kZXhUb0RlbGV0ZSA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IGluZGV4VG9EZWxldGUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1tpbmRleFRvRGVsZXRlXTtcbiAgdGFyZ2V0Um93Tm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvdyh0YWJsZU5vZGUsIHRhcmdldEluZGV4LCBzaG91bGRJbnNlcnRBZnRlciA9IHRydWUsIHJvd0NvdW50LCB0YWJsZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93cy5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSByb3cgdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbdGFyZ2V0SW5kZXhdO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKHRhcmdldFJvd05vZGUpKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NlbGxzID0gdGFyZ2V0Um93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdGFibGVDb2x1bW5Db3VudCA9IHRhYmxlUm93Q2VsbHMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3VGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0YWJsZUNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsRnJvbVRhcmdldFJvdyA9IHRhYmxlUm93Q2VsbHNbY107XG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93KSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3ZlICYmIGFib3ZlLmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pIHx8IGJlbG93ICYmIGJlbG93Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRBZnRlcihuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3cgYmVmb3JlIGluc2VydGlvbiBpbmRleCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuY29uc3QgZ2V0SGVhZGVyU3RhdGUgPSAoY3VycmVudFN0YXRlLCBwb3NzaWJsZVN0YXRlKSA9PiB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIIHx8IGN1cnJlbnRTdGF0ZSA9PT0gcG9zc2libGVTdGF0ZSkge1xuICAgIHJldHVybiBwb3NzaWJsZVN0YXRlO1xuICB9XG4gIHJldHVybiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdGFibGUgcm93IGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGluc2VydGVkIHRhYmxlIHJvdyBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3dfX0VYUEVSSU1FTlRBTChpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBmb2N1c0NlbGwsIGZvY3VzQ2VsbCk7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBsZXQgaW5zZXJ0ZWRSb3cgPSBudWxsO1xuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICBjb25zdCBmb2N1c0VuZFJvdyA9IGZvY3VzU3RhcnRSb3cgKyBmb2N1c0NlbGwuX19yb3dTcGFuIC0gMTtcbiAgICBjb25zdCBmb2N1c0VuZFJvd01hcCA9IGdyaWRNYXBbZm9jdXNFbmRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBmb2N1c0VuZFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA8PSBmb2N1c0VuZFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGZvY3VzRW5kUm93TWFwW2ldLmNlbGw7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSBjdXJyZW50Q2VsbC5fX2hlYWRlclN0YXRlO1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pO1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvY3VzRW5kUm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzRW5kUm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShmb2N1c0VuZFJvd05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZm9jdXNFbmRSb3cgaXMgbm90IGEgVGFibGVSb3dOb2RlYCk7XG4gICAgfVxuICAgIGZvY3VzRW5kUm93Tm9kZS5pbnNlcnRBZnRlcihuZXdSb3cpO1xuICAgIGluc2VydGVkUm93ID0gbmV3Um93O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZvY3VzU3RhcnRSb3dNYXAgPSBncmlkTWFwW2ZvY3VzU3RhcnRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBmb2N1c1N0YXJ0Um93TWFwW2ldO1xuICAgICAgaWYgKHN0YXJ0Um93ID09PSBmb2N1c1N0YXJ0Um93KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gZm9jdXNTdGFydFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmb2N1c1N0YXJ0Um93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzU3RhcnRSb3cpO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGZvY3VzU3RhcnRSb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGZvY3VzRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBmb2N1c1N0YXJ0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3Um93KTtcbiAgICBpbnNlcnRlZFJvdyA9IG5ld1JvdztcbiAgfVxuICByZXR1cm4gaW5zZXJ0ZWRSb3c7XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCBjb2x1bW5Db3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQgPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZVJvd3MubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW3JdO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhcmdldENlbGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICByaWdodFxuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCwgdGFibGUpO1xuICAgICAgICBsZXQgaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICAgICAgICBpZiAobGVmdCAmJiBsZWZ0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpIHx8IHJpZ2h0ICYmIHJpZ2h0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdUYWJsZUNlbGwgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICAgIG5ld1RhYmxlQ2VsbC5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQucHVzaCh7XG4gICAgICAgICAgbmV3VGFibGVDZWxsLFxuICAgICAgICAgIHRhcmdldENlbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQuZm9yRWFjaCgoe1xuICAgIG5ld1RhYmxlQ2VsbCxcbiAgICB0YXJnZXRDZWxsXG4gIH0pID0+IHtcbiAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QWZ0ZXIobmV3VGFibGVDZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Q2VsbC5pbnNlcnRCZWZvcmUobmV3VGFibGVDZWxsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFibGVOb2RlO1xufVxuXG4vKipcbiAqIEluc2VydHMgYSBjb2x1bW4gYmVmb3JlIG9yIGFmdGVyIHRoZSBjdXJyZW50IGZvY3VzIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogZmlyc3QgaW5zZXJ0ZWQgY2VsbCBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTChpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbYW5jaG9yQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbCwsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgW2dyaWRNYXAsIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBNYXRoLm1heChmb2N1c0NlbGxNYXAuc3RhcnRDb2x1bW4sIGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW4pIDogTWF0aC5taW4oZm9jdXNDZWxsTWFwLnN0YXJ0Q29sdW1uLCBhbmNob3JDZWxsTWFwLnN0YXJ0Q29sdW1uKTtcbiAgY29uc3QgaW5zZXJ0QWZ0ZXJDb2x1bW4gPSBpbnNlcnRBZnRlciA/IHN0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiAtIDEgOiBzdGFydENvbHVtbiAtIDE7XG4gIGNvbnN0IGdyaWRGaXJzdENoaWxkID0gZ3JpZC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKGdyaWRGaXJzdENoaWxkKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBmaXJzdFRhYmxlIGNoaWxkIHRvIGJlIGEgcm93YCk7XG4gIH1cbiAgbGV0IGZpcnN0SW5zZXJ0ZWRDZWxsID0gbnVsbDtcbiAgZnVuY3Rpb24gJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpIHtcbiAgICBjb25zdCBjZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICBpZiAoZmlyc3RJbnNlcnRlZENlbGwgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0SW5zZXJ0ZWRDZWxsID0gY2VsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgbGV0IGxvb3BSb3cgPSBncmlkRmlyc3RDaGlsZDtcbiAgcm93TG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBsb29wUm93LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcm93IG5leHRTaWJsaW5nIHRvIGJlIGEgcm93YCk7XG4gICAgICB9XG4gICAgICBsb29wUm93ID0gY3VycmVudFJvdztcbiAgICB9XG4gICAgY29uc3Qgcm93TWFwID0gZ3JpZE1hcFtpXTtcbiAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uIDwgMCA/IDAgOiBpbnNlcnRBZnRlckNvbHVtbl0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIGNvbnN0IGhlYWRlclN0YXRlID0gZ2V0SGVhZGVyU3RhdGUoY3VycmVudENlbGxIZWFkZXJTdGF0ZSwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVyk7XG4gICAgaWYgKGluc2VydEFmdGVyQ29sdW1uIDwgMCkge1xuICAgICAgJGluc2VydEZpcnN0KGxvb3BSb3csICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjZWxsOiBjdXJyZW50Q2VsbCxcbiAgICAgIHN0YXJ0Q29sdW1uOiBjdXJyZW50U3RhcnRDb2x1bW4sXG4gICAgICBzdGFydFJvdzogY3VycmVudFN0YXJ0Um93XG4gICAgfSA9IHJvd01hcFtpbnNlcnRBZnRlckNvbHVtbl07XG4gICAgaWYgKGN1cnJlbnRTdGFydENvbHVtbiArIGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDEgPD0gaW5zZXJ0QWZ0ZXJDb2x1bW4pIHtcbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGxSb3dTdGFydCA9IGN1cnJlbnRTdGFydFJvdztcbiAgICAgIGxldCBwcmV2Q2VsbEluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW47XG4gICAgICB3aGlsZSAoaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgIT09IGkgJiYgaW5zZXJ0QWZ0ZXJDZWxsLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgICAgcHJldkNlbGxJbmRleCAtPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW47XG4gICAgICAgIGlmIChwcmV2Q2VsbEluZGV4ID49IDApIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjZWxsOiBjZWxsXyxcbiAgICAgICAgICAgIHN0YXJ0Um93OiBzdGFydFJvd19cbiAgICAgICAgICB9ID0gcm93TWFwW3ByZXZDZWxsSW5kZXhdO1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbCA9IGNlbGxfO1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ID0gc3RhcnRSb3dfO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvb3BSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUpKTtcbiAgICAgICAgICBjb250aW51ZSByb3dMb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q2VsbC5zZXRDb2xTcGFuKGN1cnJlbnRDZWxsLl9fY29sU3BhbiArIDEpO1xuICAgIH1cbiAgfVxuICBpZiAoZmlyc3RJbnNlcnRlZENlbGwgIT09IG51bGwpIHtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChmaXJzdEluc2VydGVkQ2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gbmV3Q29sV2lkdGhzW2NvbHVtbkluZGV4XTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKGNvbHVtbkluZGV4LCAwLCBuZXdXaWR0aCk7XG4gICAgZ3JpZC5zZXRDb2xXaWR0aHMobmV3Q29sV2lkdGhzKTtcbiAgfVxuICByZXR1cm4gZmlyc3RJbnNlcnRlZENlbGw7XG59XG5mdW5jdGlvbiAkZGVsZXRlVGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW2ldO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgY29sdW1uIHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKSA/IFtzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKV0gOiBbc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCldO1xuICBjb25zdCBbYW5jaG9yQ2VsbCwsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGxdID0gJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgW2dyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGFuY2hvckNlbGwsIGZvY3VzQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogYW5jaG9yU3RhcnRSb3dcbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBjb25zdCBmb2N1c0VuZFJvdyA9IGZvY3VzU3RhcnRSb3cgKyBmb2N1c0NlbGwuX19yb3dTcGFuIC0gMTtcbiAgaWYgKGdyaWRNYXAubGVuZ3RoID09PSBmb2N1c0VuZFJvdyAtIGFuY2hvclN0YXJ0Um93ICsgMSkge1xuICAgIC8vIEVtcHR5IGdyaWRcbiAgICBncmlkLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCBuZXh0Um93ID0gZ3JpZE1hcFtmb2N1c0VuZFJvdyArIDFdO1xuICBjb25zdCBuZXh0Um93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzRW5kUm93ICsgMSk7XG4gIGZvciAobGV0IHJvdyA9IGZvY3VzRW5kUm93OyByb3cgPj0gYW5jaG9yU3RhcnRSb3c7IHJvdy0tKSB7XG4gICAgZm9yIChsZXQgY29sdW1uID0gY29sdW1uQ291bnQgLSAxOyBjb2x1bW4gPj0gMDsgY29sdW1uLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3c6IGNlbGxTdGFydFJvdyxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNlbGxTdGFydENvbHVtblxuICAgICAgfSA9IGdyaWRNYXBbcm93XVtjb2x1bW5dO1xuICAgICAgaWYgKGNlbGxTdGFydENvbHVtbiAhPT0gY29sdW1uKSB7XG4gICAgICAgIC8vIERvbid0IHJlcGVhdCB3b3JrIGZvciB0aGUgc2FtZSBDZWxsXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gUm93cyBvdmVyZmxvd2luZyB0b3AgaGF2ZSB0byBiZSB0cmltbWVkXG4gICAgICBpZiAocm93ID09PSBhbmNob3JTdGFydFJvdyAmJiBjZWxsU3RhcnRSb3cgPCBhbmNob3JTdGFydFJvdykge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gLSAoY2VsbFN0YXJ0Um93IC0gYW5jaG9yU3RhcnRSb3cpKTtcbiAgICAgIH1cbiAgICAgIC8vIFJvd3Mgb3ZlcmZsb3dpbmcgYm90dG9tIGhhdmUgdG8gYmUgdHJpbW1lZCBhbmQgbW92ZWQgdG8gdGhlIG5leHQgcm93XG4gICAgICBpZiAoY2VsbFN0YXJ0Um93ID49IGFuY2hvclN0YXJ0Um93ICYmIGNlbGxTdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA+IGZvY3VzRW5kUm93KSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiAtIChmb2N1c0VuZFJvdyAtIGNlbGxTdGFydFJvdyArIDEpKTtcbiAgICAgICAgaWYgKCEobmV4dFJvd05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5leHRSb3dOb2RlIG5vdCB0byBiZSBudWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChuZXh0Um93Tm9kZSwgY2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2VsbDogcHJldmlvdXNDZWxsXG4gICAgICAgICAgfSA9IG5leHRSb3dbY29sdW1uIC0gMV07XG4gICAgICAgICAgcHJldmlvdXNDZWxsLmluc2VydEFmdGVyKGNlbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChyb3cpO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvd05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cbiAgICByb3dOb2RlLnJlbW92ZSgpO1xuICB9XG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3Qgc3RhcnRDb2x1bW4gPSBNYXRoLm1pbihhbmNob3JTdGFydENvbHVtbiwgZm9jdXNTdGFydENvbHVtbik7XG4gIGNvbnN0IGVuZENvbHVtbiA9IE1hdGgubWF4KGFuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW4gLSAxLCBmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiAtIDEpO1xuICBjb25zdCBzZWxlY3RlZENvbHVtbkNvdW50ID0gZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPT09IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSkge1xuICAgIC8vIEVtcHR5IGdyaWRcbiAgICBncmlkLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgcm93Q291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sdW1uID0gc3RhcnRDb2x1bW47IGNvbHVtbiA8PSBlbmRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gPCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBzdGFydENvbHVtbikge1xuICAgICAgICAgIGNvbnN0IG92ZXJmbG93TGVmdCA9IHN0YXJ0Q29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uO1xuICAgICAgICAgIC8vIE92ZXJmbG93aW5nIGxlZnRcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLVxuICAgICAgICAgIC8vIFBvc3NpYmxlIG92ZXJmbG93IHJpZ2h0IHRvb1xuICAgICAgICAgIE1hdGgubWluKHNlbGVjdGVkQ29sdW1uQ291bnQsIGNlbGwuX19jb2xTcGFuIC0gb3ZlcmZsb3dMZWZ0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2VsbFN0YXJ0Q29sdW1uICsgY2VsbC5fX2NvbFNwYW4gLSAxID4gZW5kQ29sdW1uKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IGVuZENvbHVtbikge1xuICAgICAgICAgIC8vIE92ZXJmbG93aW5nIHJpZ2h0XG4gICAgICAgICAgY29uc3QgaW5TZWxlY3RlZEFyZWEgPSBlbmRDb2x1bW4gLSBjZWxsU3RhcnRDb2x1bW4gKyAxO1xuICAgICAgICAgIGNlbGwuc2V0Q29sU3BhbihjZWxsLl9fY29sU3BhbiAtIGluU2VsZWN0ZWRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZm9jdXNSb3dNYXAgPSBncmlkTWFwW2ZvY3VzU3RhcnRSb3ddO1xuICBjb25zdCBuZXh0Q29sdW1uID0gYW5jaG9yU3RhcnRDb2x1bW4gPiBmb2N1c1N0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gKyBhbmNob3JDZWxsLl9fY29sU3Bhbl0gOiBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3Bhbl07XG4gIGlmIChuZXh0Q29sdW1uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRDb2x1bW47XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBmb2N1c1N0YXJ0Q29sdW1uIDwgYW5jaG9yU3RhcnRDb2x1bW4gPyBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uIC0gMV0gOiBmb2N1c1Jvd01hcFthbmNob3JTdGFydENvbHVtbiAtIDFdO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gcHJldmlvdXNSb3c7XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIG5ld0NvbFdpZHRocy5zcGxpY2Uoc3RhcnRDb2x1bW4sIHNlbGVjdGVkQ29sdW1uQ291bnQpO1xuICAgIGdyaWQuc2V0Q29sV2lkdGhzKG5ld0NvbFdpZHRocyk7XG4gIH1cbn1cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpIHtcbiAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gY2VsbC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgaWYgKGZpcnN0RGVzY2VuZGFudCA9PSBudWxsKSB7XG4gICAgY2VsbC5zZWxlY3RTdGFydCgpO1xuICB9IGVsc2Uge1xuICAgIGZpcnN0RGVzY2VuZGFudC5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0U3RhcnQoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kKG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiAkdW5tZXJnZUNlbGwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IFtjZWxsLCByb3csIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IGNvbFNwYW4gPSBjZWxsLl9fY29sU3BhbjtcbiAgY29uc3Qgcm93U3BhbiA9IGNlbGwuX19yb3dTcGFuO1xuICBpZiAoY29sU3BhbiA9PT0gMSAmJiByb3dTcGFuID09PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFttYXAsIGNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBjZWxsLCBjZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uLFxuICAgIHN0YXJ0Um93XG4gIH0gPSBjZWxsTWFwO1xuICAvLyBDcmVhdGUgYSBoZXVyaXN0aWMgZm9yIHdoYXQgdGhlIHN0eWxlIG9mIHRoZSB1bm1lcmdlZCBjZWxscyBzaG91bGQgYmVcbiAgLy8gYmFzZWQgb24gd2hldGhlciBldmVyeSByb3cgb3IgY29sdW1uIGFscmVhZHkgaGFkIHRoYXQgc3RhdGUgYmVmb3JlIHRoZVxuICAvLyB1bm1lcmdlLlxuICBjb25zdCBiYXNlQ29sU3R5bGUgPSBjZWxsLl9faGVhZGVyU3RhdGUgJiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICBjb25zdCBjb2xTdHlsZXMgPSBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGNvbFNwYW5cbiAgfSwgKF92LCBpKSA9PiB7XG4gICAgbGV0IGNvbFN0eWxlID0gYmFzZUNvbFN0eWxlO1xuICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IGNvbFN0eWxlICE9PSAwICYmIHJvd0lkeCA8IG1hcC5sZW5ndGg7IHJvd0lkeCsrKSB7XG4gICAgICBjb2xTdHlsZSAmPSBtYXBbcm93SWR4XVtpICsgc3RhcnRDb2x1bW5dLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbFN0eWxlO1xuICB9KTtcbiAgY29uc3QgYmFzZVJvd1N0eWxlID0gY2VsbC5fX2hlYWRlclN0YXRlICYgVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgY29uc3Qgcm93U3R5bGVzID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiByb3dTcGFuXG4gIH0sIChfdiwgaSkgPT4ge1xuICAgIGxldCByb3dTdHlsZSA9IGJhc2VSb3dTdHlsZTtcbiAgICBmb3IgKGxldCBjb2xJZHggPSAwOyByb3dTdHlsZSAhPT0gMCAmJiBjb2xJZHggPCBtYXBbMF0ubGVuZ3RoOyBjb2xJZHgrKykge1xuICAgICAgcm93U3R5bGUgJj0gbWFwW2kgKyBzdGFydFJvd11bY29sSWR4XS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgfVxuICAgIHJldHVybiByb3dTdHlsZTtcbiAgfSk7XG4gIGlmIChjb2xTcGFuID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29sU3BhbjsgaSsrKSB7XG4gICAgICBjZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tpXSB8IHJvd1N0eWxlc1swXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICB9XG4gICAgY2VsbC5zZXRDb2xTcGFuKDEpO1xuICB9XG4gIGlmIChyb3dTcGFuID4gMSkge1xuICAgIGxldCBjdXJyZW50Um93Tm9kZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJvd1NwYW47IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudFJvdyA9IHN0YXJ0Um93ICsgaTtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3dNYXAgPSBtYXBbY3VycmVudFJvd107XG4gICAgICBjdXJyZW50Um93Tm9kZSA9IChjdXJyZW50Um93Tm9kZSB8fCByb3cpLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93Tm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHJvdyBuZXh0IHNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgc3RhcnRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsTWFwID0gY3VycmVudFJvd01hcFtjb2x1bW5dO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gY3VycmVudFJvdykge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgY29sdW1uICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbFNwYW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChjdXJyZW50Um93Tm9kZSwgJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2pdIHwgcm93U3R5bGVzW2ldKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gY29sU3BhbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tqXSB8IHJvd1N0eWxlc1tpXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkLCBjZWxsQSwgY2VsbEIpO1xuICBpZiAoIShjZWxsQVZhbHVlICE9PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGBBbmNob3Igbm90IGZvdW5kIGluIFRhYmxlYCk7XG4gIH1cbiAgaWYgKCEoY2VsbEJWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRm9jdXMgbm90IGZvdW5kIGluIFRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkLCBjZWxsQSwgY2VsbEIpIHtcbiAgY29uc3QgdGFibGVNYXAgPSBbXTtcbiAgbGV0IGNlbGxBVmFsdWUgPSBudWxsO1xuICBsZXQgY2VsbEJWYWx1ZSA9IG51bGw7XG4gIGZ1bmN0aW9uIGdldE1hcFJvdyhpKSB7XG4gICAgbGV0IHJvdyA9IHRhYmxlTWFwW2ldO1xuICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFibGVNYXBbaV0gPSByb3cgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbiAgfVxuICBjb25zdCBncmlkQ2hpbGRyZW4gPSBncmlkLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IGdyaWRDaGlsZHJlbi5sZW5ndGg7IHJvd0lkeCsrKSB7XG4gICAgY29uc3Qgcm93ID0gZ3JpZENoaWxkcmVuW3Jvd0lkeF07XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlTm9kZSBjaGlsZHJlbiB0byBiZSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgZm9yIChsZXQgY2VsbCA9IHJvdy5nZXRGaXJzdENoaWxkKCksIGNvbElkeCA9IDA7IGNlbGwgIT0gbnVsbDsgY2VsbCA9IGNlbGwuZ2V0TmV4dFNpYmxpbmcoKSkge1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVJvd05vZGUgY2hpbGRyZW4gdG8gYmUgVGFibGVDZWxsTm9kZWApO1xuICAgICAgfSAvLyBTa2lwIHBhc3QgYW55IGNvbHVtbnMgdGhhdCB3ZXJlIG1lcmdlZCBmcm9tIGEgaGlnaGVyIHJvd1xuICAgICAgY29uc3Qgc3RhcnRNYXBSb3cgPSBnZXRNYXBSb3cocm93SWR4KTtcbiAgICAgIHdoaWxlIChzdGFydE1hcFJvd1tjb2xJZHhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sSWR4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNvbElkeCxcbiAgICAgICAgc3RhcnRSb3c6IHJvd0lkeFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgX19yb3dTcGFuOiByb3dTcGFuLFxuICAgICAgICBfX2NvbFNwYW46IGNvbFNwYW5cbiAgICAgIH0gPSBjZWxsO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dTcGFuOyBqKyspIHtcbiAgICAgICAgaWYgKHJvd0lkeCArIGogPj0gZ3JpZENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSB0YWJsZSBpcyBub24tcmVjdGFuZ3VsYXIgd2l0aCBhIHJvd1NwYW5cbiAgICAgICAgICAvLyBiZWxvdyB0aGUgbGFzdCA8dHI+IGluIHRoZSB0YWJsZS5cbiAgICAgICAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgaGFuZGxlIHRoaXMgd2l0aCBhIG5vZGUgdHJhbnNmb3JtXG4gICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgdGFibGVzIGFyZSBhbHdheXMgcmVjdGFuZ3VsYXIgYnV0IHRoaXNcbiAgICAgICAgICAvLyB3aWxsIGF2b2lkIGNyYXNoZXMgc3VjaCBhcyAjNjU4NFxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGVyZSBhcmUgcHJvYmFibHkgc3RpbGwgbGF0ZW50IGJ1Z3NcbiAgICAgICAgICAvLyByZWdhcmRpbmcgY29sU3BhbiBvciBnZW5lcmFsIGNlbGwgY291bnQgbWlzbWF0Y2hlcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXBSb3cgPSBnZXRNYXBSb3cocm93SWR4ICsgaik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sU3BhbjsgaSsrKSB7XG4gICAgICAgICAgbWFwUm93W2NvbElkeCArIGldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQSAhPT0gbnVsbCAmJiBjZWxsQVZhbHVlID09PSBudWxsICYmIGNlbGxBLmlzKGNlbGwpKSB7XG4gICAgICAgIGNlbGxBVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQiAhPT0gbnVsbCAmJiBjZWxsQlZhbHVlID09PSBudWxsICYmIGNlbGxCLmlzKGNlbGwpKSB7XG4gICAgICAgIGNlbGxCVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZVRyaXBsZXQoc291cmNlKSB7XG4gIGxldCBjZWxsO1xuICBpZiAoc291cmNlIGluc3RhbmNlb2YgVGFibGVDZWxsTm9kZSkge1xuICAgIGNlbGwgPSBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoJ19fdHlwZScgaW4gc291cmNlKSB7XG4gICAgY29uc3QgY2VsbF8gPSAkZmluZE1hdGNoaW5nUGFyZW50KHNvdXJjZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgYSBwYXJlbnQgVGFibGVDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjZWxsID0gY2VsbF87XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2VsbF8gPSAkZmluZE1hdGNoaW5nUGFyZW50KHNvdXJjZS5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9XG4gIGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSB0byBoYXZlIGEgcGFyZW50IFRhYmxlUm93Tm9kZWApO1xuICB9XG4gIGNvbnN0IGdyaWQgPSByb3cuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVOb2RlKGdyaWQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlUm93Tm9kZSB0byBoYXZlIGEgcGFyZW50IFRhYmxlTm9kZWApO1xuICB9XG4gIHJldHVybiBbY2VsbCwgcm93LCBncmlkXTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxOb2RlUmVjdCh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IFtjZWxsTm9kZSwsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldCh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3Qgcm93cyA9IGdyaWROb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHJvd0NvdW50ID0gcm93cy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gcm93c1swXS5nZXRDaGlsZHJlbigpLmxlbmd0aDtcblxuICAvLyBDcmVhdGUgYSBtYXRyaXggb2YgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgdGFibGUgdG8gdHJhY2sgdGhlIHBvc2l0aW9uIG9mIGVhY2ggY2VsbFxuICBjb25zdCBjZWxsTWF0cml4ID0gbmV3IEFycmF5KHJvd0NvdW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgY2VsbE1hdHJpeFtpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gIH1cbiAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd0NvdW50OyByb3dJbmRleCsrKSB7XG4gICAgY29uc3Qgcm93ID0gcm93c1tyb3dJbmRleF07XG4gICAgY29uc3QgY2VsbHMgPSByb3cuZ2V0Q2hpbGRyZW4oKTtcbiAgICBsZXQgY29sdW1uSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGNlbGxJbmRleCA9IDA7IGNlbGxJbmRleCA8IGNlbGxzLmxlbmd0aDsgY2VsbEluZGV4KyspIHtcbiAgICAgIC8vIEZpbmQgdGhlIG5leHQgYXZhaWxhYmxlIHBvc2l0aW9uIGluIHRoZSBtYXRyaXgsIHNraXAgdGhlIHBvc2l0aW9uIG9mIG1lcmdlZCBjZWxsc1xuICAgICAgd2hpbGUgKGNlbGxNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4XSkge1xuICAgICAgICBjb2x1bW5JbmRleCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VsbCA9IGNlbGxzW2NlbGxJbmRleF07XG4gICAgICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW4gfHwgMTtcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBjZWxsLl9fY29sU3BhbiB8fCAxO1xuXG4gICAgICAvLyBQdXQgdGhlIGNlbGwgaW50byB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgbWF0cml4XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd1NwYW47IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuICAgICAgICAgIGNlbGxNYXRyaXhbcm93SW5kZXggKyBpXVtjb2x1bW5JbmRleCArIGpdID0gY2VsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdG8gdGhlIG9yaWdpbmFsIGluZGV4LCByb3cgc3BhbiBhbmQgY29sdW1uIHNwYW4gb2YgdGhlIGNlbGwuXG4gICAgICBpZiAoY2VsbE5vZGUgPT09IGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xTcGFuLFxuICAgICAgICAgIGNvbHVtbkluZGV4LFxuICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgIHJvd1NwYW5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbHVtbkluZGV4ICs9IGNvbFNwYW47XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFibGVLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiYmFja3dhcmRzXCIsIG1lYW5pbmcgdGhlIGZvY3VzXG4gICAqIGxvZ2ljYWxseSBwcmVjZWRlcyB0aGUgYW5jaG9yIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgU2VsZWN0aW9uIGlzIGJhY2t3YXJkcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1cy5pc0JlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH1cbiAgZ2V0Q2FjaGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE5vZGVzO1xuICB9XG4gIHNldENhY2hlZE5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgfVxuICBpcyhzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFibGVLZXkgPT09IHNlbGVjdGlvbi50YWJsZUtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cbiAgc2V0KHRhYmxlS2V5LCBhbmNob3JDZWxsS2V5LCBmb2N1c0NlbGxLZXkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbih0aGlzLnRhYmxlS2V5LCB0aGlzLmFuY2hvciwgdGhpcy5mb2N1cyk7XG4gIH1cbiAgaXNDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4dHJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgfVxuICBpbnNlcnRSYXdUZXh0KHRleHQpIHtcbiAgICAvLyBEbyBub3RoaW5nP1xuICB9XG4gIGluc2VydFRleHQoKSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIFRleHRGb3JtYXRUeXBlIGlzIHByZXNlbnQgb24gdGhlIFNlbGVjdGlvbi5cbiAgICogVGhpcyB3aWxsIGJlIHRydWUgaWYgYW55IHBhcmFncmFwaCBpbiB0YWJsZSBjZWxscyBoYXMgdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHRoZSBUZXh0Rm9ybWF0VHlwZSB0byBjaGVjayBmb3IuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGZvcm1hdCBpcyBjdXJyZW50bHkgdG9nZ2xlZCBvbiBvbiB0aGUgU2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYXNGb3JtYXQodHlwZSkge1xuICAgIGxldCBmb3JtYXQgPSAwO1xuICAgIGNvbnN0IGNlbGxOb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKS5maWx0ZXIoJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY2VsbE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gY2VsbE5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc1BhcmFncmFwaE5vZGUocGFyYWdyYXBoKSkge1xuICAgICAgICBmb3JtYXQgfD0gcGFyYWdyYXBoLmdldFRleHRGb3JtYXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKGZvcm1hdCAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG4gIGluc2VydE5vZGVzKG5vZGVzKSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gdGhpcy5mb2N1cy5nZXROb2RlKCk7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGZvY3VzTm9kZS5zZWxlY3QoMCwgZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpKSk7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIC8vIFRPRE8gRGVwcmVjYXRlIHRoaXMgbWV0aG9kLiBJdCdzIGNvbmZ1c2luZyB3aGVuIHVzZWQgd2l0aCBjb2xzcGFufHJvd3NwYW5cbiAgZ2V0U2hhcGUoKSB7XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMuYW5jaG9yLmtleSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uIGFuY2hvciB0byBiZSAob3IgYSBjaGlsZCBvZikgVGFibGVDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoYW5jaG9yQ2VsbE5vZGUpO1xuICAgIGlmICghKGFuY2hvckNlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBnZXRDZWxsUmVjdDogZXhwZWN0ZWQgdG8gZmluZCBBbmNob3JOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMuZm9jdXMua2V5KTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiBmb2N1cyB0byBiZSAob3IgYSBjaGlsZCBvZikgVGFibGVDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlUmVjdCA9ICRnZXRUYWJsZUNlbGxOb2RlUmVjdChmb2N1c0NlbGxOb2RlKTtcbiAgICBpZiAoIShmb2N1c0NlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBnZXRDZWxsUmVjdDogZXhwZWN0ZWQgdG8gZmluZCBmb2N1c0NlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGgubWluKGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgpO1xuICAgIGNvbnN0IHN0b3BYID0gTWF0aC5tYXgoYW5jaG9yQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4ICsgYW5jaG9yQ2VsbE5vZGVSZWN0LmNvbFNwYW4gLSAxLCBmb2N1c0NlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbFNwYW4gLSAxKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4KTtcbiAgICBjb25zdCBzdG9wWSA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5yb3dJbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5yb3dTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5yb3dTcGFuIC0gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21YOiBNYXRoLm1pbihzdGFydFgsIHN0b3BYKSxcbiAgICAgIGZyb21ZOiBNYXRoLm1pbihzdGFydFksIHN0b3BZKSxcbiAgICAgIHRvWDogTWF0aC5tYXgoc3RhcnRYLCBzdG9wWCksXG4gICAgICB0b1k6IE1hdGgubWF4KHN0YXJ0WSwgc3RvcFkpXG4gICAgfTtcbiAgfVxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gdGhpcy5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHRoaXMuZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGFuY2hvckNlbGwgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIC8vIHRvZG8gcmVwbGFjZSB3aXRoIHRyaXBsZXRcbiAgICBjb25zdCBmb2N1c0NlbGwgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gYW5jaG9yIHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yUm93ID0gYW5jaG9yQ2VsbC5nZXRQYXJlbnQoKTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShhbmNob3JSb3cpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYW5jaG9yQ2VsbCB0byBoYXZlIGEgcGFyZW50IFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5vZGUgPSBhbmNob3JSb3cuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlTm9kZSB0byBoYXZlIGEgcGFyZW50IFRhYmxlTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxHcmlkID0gZm9jdXNDZWxsLmdldFBhcmVudHMoKVsxXTtcbiAgICBpZiAoZm9jdXNDZWxsR3JpZCAhPT0gdGFibGVOb2RlKSB7XG4gICAgICBpZiAoIXRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzQ2VsbCkpIHtcbiAgICAgICAgLy8gZm9jdXMgaXMgb24gaGlnaGVyIEdyaWQgbGV2ZWwgdGhhbiBhbmNob3JcbiAgICAgICAgY29uc3QgZ3JpZFBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZ3JpZFBhcmVudCAhPSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBncmlkUGFyZW50IHRvIGhhdmUgYSBwYXJlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCh0aGlzLnRhYmxlS2V5LCBncmlkUGFyZW50LmdldEtleSgpLCBmb2N1c0NlbGwuZ2V0S2V5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jaG9yIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gZm9jdXNcbiAgICAgICAgY29uc3QgZm9jdXNDZWxsUGFyZW50ID0gZm9jdXNDZWxsR3JpZC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZm9jdXNDZWxsUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGZvY3VzQ2VsbFBhcmVudCB0byBoYXZlIGEgcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQodGhpcy50YWJsZUtleSwgZm9jdXNDZWxsLmdldEtleSgpLCBmb2N1c0NlbGxQYXJlbnQuZ2V0S2V5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE1hcHBpbmcgdGhlIHdob2xlIEdyaWQgZXZlcnkgdGltZSBub3QgZWZmaWNpZW50LiBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGVudGlyZSBzdGF0ZSBvbmx5XG4gICAgLy8gb25jZSAob24gbG9hZCkgYW5kIGl0ZXJhdGUgb24gaXQgYXMgdXBkYXRlcyBvY2N1ci4gSG93ZXZlciwgdG8gZG8gdGhpcyB3ZSBuZWVkIHRvIGhhdmUgdGhlXG4gICAgLy8gYWJpbGl0eSB0byBzdG9yZSBhIHN0YXRlLiBLaWxsaW5nIFRhYmxlU2VsZWN0aW9uIGFuZCBtb3ZpbmcgdGhlIGxvZ2ljIHRvIHRoZSBwbHVnaW4gd291bGQgbWFrZVxuICAgIC8vIHRoaXMgcG9zc2libGUuXG4gICAgY29uc3QgW21hcCwgY2VsbEFNYXAsIGNlbGxCTWFwXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICAgIGxldCBtaW5Db2x1bW4gPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydENvbHVtbiwgY2VsbEJNYXAuc3RhcnRDb2x1bW4pO1xuICAgIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICAgIGxldCBtYXhDb2x1bW4gPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydENvbHVtbiArIGNlbGxBTWFwLmNlbGwuX19jb2xTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQk1hcC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGxldCBtYXhSb3cgPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydFJvdyArIGNlbGxBTWFwLmNlbGwuX19yb3dTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRSb3cgKyBjZWxsQk1hcC5jZWxsLl9fcm93U3BhbiAtIDEpO1xuICAgIGxldCBleHBsb3JlZE1pbkNvbHVtbiA9IG1pbkNvbHVtbjtcbiAgICBsZXQgZXhwbG9yZWRNaW5Sb3cgPSBtaW5Sb3c7XG4gICAgbGV0IGV4cGxvcmVkTWF4Q29sdW1uID0gbWluQ29sdW1uO1xuICAgIGxldCBleHBsb3JlZE1heFJvdyA9IG1pblJvdztcbiAgICBmdW5jdGlvbiBleHBhbmRCb3VuZGFyeShtYXBWYWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93XG4gICAgICB9ID0gbWFwVmFsdWU7XG4gICAgICBtaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGxTdGFydENvbHVtbik7XG4gICAgICBtaW5Sb3cgPSBNYXRoLm1pbihtaW5Sb3csIGNlbGxTdGFydFJvdyk7XG4gICAgICBtYXhDb2x1bW4gPSBNYXRoLm1heChtYXhDb2x1bW4sIGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSk7XG4gICAgICBtYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxTdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSk7XG4gICAgfVxuICAgIHdoaWxlIChtaW5Db2x1bW4gPCBleHBsb3JlZE1pbkNvbHVtbiB8fCBtaW5Sb3cgPCBleHBsb3JlZE1pblJvdyB8fCBtYXhDb2x1bW4gPiBleHBsb3JlZE1heENvbHVtbiB8fCBtYXhSb3cgPiBleHBsb3JlZE1heFJvdykge1xuICAgICAgaWYgKG1pbkNvbHVtbiA8IGV4cGxvcmVkTWluQ29sdW1uKSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgbGVmdFxuICAgICAgICBjb25zdCByb3dEaWZmID0gZXhwbG9yZWRNYXhSb3cgLSBleHBsb3JlZE1pblJvdztcbiAgICAgICAgY29uc3QgcHJldmlvdXNDb2x1bW4gPSBleHBsb3JlZE1pbkNvbHVtbiAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW3ByZXZpb3VzQ29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZWRNaW5Db2x1bW4gPSBwcmV2aW91c0NvbHVtbjtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5Sb3cgPCBleHBsb3JlZE1pblJvdykge1xuICAgICAgICAvLyBFeHBhbmQgb24gdG9wXG4gICAgICAgIGNvbnN0IGNvbHVtbkRpZmYgPSBleHBsb3JlZE1heENvbHVtbiAtIGV4cGxvcmVkTWluQ29sdW1uO1xuICAgICAgICBjb25zdCBwcmV2aW91c1JvdyA9IGV4cGxvcmVkTWluUm93IC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gY29sdW1uRGlmZjsgaSsrKSB7XG4gICAgICAgICAgZXhwYW5kQm91bmRhcnkobWFwW3ByZXZpb3VzUm93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1pblJvdyA9IHByZXZpb3VzUm93O1xuICAgICAgfVxuICAgICAgaWYgKG1heENvbHVtbiA+IGV4cGxvcmVkTWF4Q29sdW1uKSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgcmlnaHRcbiAgICAgICAgY29uc3Qgcm93RGlmZiA9IGV4cGxvcmVkTWF4Um93IC0gZXhwbG9yZWRNaW5Sb3c7XG4gICAgICAgIGNvbnN0IG5leHRDb2x1bW4gPSBleHBsb3JlZE1heENvbHVtbiArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW25leHRDb2x1bW5dKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1heENvbHVtbiA9IG5leHRDb2x1bW47XG4gICAgICB9XG4gICAgICBpZiAobWF4Um93ID4gZXhwbG9yZWRNYXhSb3cpIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRoZSBib3R0b21cbiAgICAgICAgY29uc3QgY29sdW1uRGlmZiA9IGV4cGxvcmVkTWF4Q29sdW1uIC0gZXhwbG9yZWRNaW5Db2x1bW47XG4gICAgICAgIGNvbnN0IG5leHRSb3cgPSBleHBsb3JlZE1heFJvdyArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHVtbkRpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtuZXh0Um93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1heFJvdyA9IG5leHRSb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgdXNlIGEgTWFwIGhlcmUgYmVjYXVzZSBtZXJnZWQgY2VsbHMgaW4gdGhlIGdyaWQgd291bGQgb3RoZXJ3aXNlXG4gICAgLy8gc2hvdyB1cCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgbm9kZXMgYXJyYXlcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcChbW3RhYmxlTm9kZS5nZXRLZXkoKSwgdGFibGVOb2RlXV0pO1xuICAgIGxldCBsYXN0Um93ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gbWluUm93OyBpIDw9IG1heFJvdzsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbWluQ29sdW1uOyBqIDw9IG1heENvbHVtbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjZWxsXG4gICAgICAgIH0gPSBtYXBbaV1bal07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZUNlbGxOb2RlIHBhcmVudCB0byBiZSBhIFRhYmxlUm93Tm9kZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBsYXN0Um93KSB7XG4gICAgICAgICAgbm9kZU1hcC5zZXQoY3VycmVudFJvdy5nZXRLZXkoKSwgY3VycmVudFJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZU1hcC5zZXQoY2VsbC5nZXRLZXkoKSwgY2VsbCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgJGdldENoaWxkcmVuUmVjdXJzaXZlbHkoY2VsbCkpIHtcbiAgICAgICAgICBub2RlTWFwLnNldChjaGlsZC5nZXRLZXkoKSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSb3cgPSBjdXJyZW50Um93O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IEFycmF5LmZyb20obm9kZU1hcC52YWx1ZXMoKSk7XG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCkuZmlsdGVyKG5vZGUgPT4gJGlzVGFibGVDZWxsTm9kZShub2RlKSk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY29uc3Qgcm93ID0gbm9kZS5fX3BhcmVudDtcbiAgICAgIGNvbnN0IG5leHRSb3cgPSAobm9kZXNbaSArIDFdIHx8IHt9KS5fX3BhcmVudDtcbiAgICAgIHRleHRDb250ZW50ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKSArIChuZXh0Um93ICE9PSByb3cgPyAnXFxuJyA6ICdcXHQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiAkaXNUYWJsZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgVGFibGVTZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbigncm9vdCcsIGFuY2hvciwgZm9jdXMpO1xufVxuZnVuY3Rpb24gJGdldENoaWxkcmVuUmVjdXJzaXZlbHkobm9kZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtub2RlXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmICghKGN1cnJlbnROb2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgU3RhY2subGVuZ3RoID4gMDsgY2FuJ3QgYmUgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnVuc2hpZnQoLi4uY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgbm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBUYWJsZU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoZWRpdG9yLCB0YWJsZU5vZGVLZXkpIHtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1JlbW92ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZUtleTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnRhYmxlID0ge1xuICAgICAgY29sdW1uczogMCxcbiAgICAgIGRvbVJvd3M6IFtdLFxuICAgICAgcm93czogMFxuICAgIH07XG4gICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy50cmFja1RhYmxlKCk7XG4gICAgdGhpcy5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMubGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9O1xuICB9XG4gIGdldFRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgncmVtb3ZlTGlzdGVuZXJzJyk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlKS5mb3JFYWNoKHJlbW92ZUxpc3RlbmVyID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICAgIHRoaXMubGlzdGVuZXJzVG9SZW1vdmUuY2xlYXIoKTtcbiAgfVxuICB0cmFja1RhYmxlKCkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIocmVjb3JkcyA9PiB7XG4gICAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBsZXQgZ3JpZE5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZTtcbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdUQUJMRScgfHwgbm9kZU5hbWUgPT09ICdUQk9EWScgfHwgbm9kZU5hbWUgPT09ICdUSEVBRCcgfHwgbm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgICAgIGdyaWROZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncmlkTmVlZHNSZWRyYXcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gdGhpcy5lZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuICAgICAgdGhpcy50YWJsZSA9IGdldFRhYmxlKHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNsZWFySGlnaGxpZ2h0KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yWCA9IC0xO1xuICAgIHRoaXMuYW5jaG9yWSA9IC0xO1xuICAgIHRoaXMuZm9jdXNYID0gLTE7XG4gICAgdGhpcy5mb2N1c1kgPSAtMTtcbiAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBncmlkID0gZ2V0VGFibGUodGFibGVFbGVtZW50KTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCBncmlkLCBudWxsKTtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuICBlbmFibGVIaWdobGlnaHRTdHlsZSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCh0YWJsZUVsZW1lbnQsIGVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICAgIHRhYmxlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlLXNlbGVjdGlvbicpO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGRpc2FibGVIaWdobGlnaHRTdHlsZSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUYWJsZVRhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0aGlzLnRhYmxlTm9kZUtleSkge1xuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGhpcy50YWJsZSwgdGhpcy50YWJsZVNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhYmxlTm9kZUtleSA9IHNlbGVjdGlvbi50YWJsZUtleTtcbiAgICAgIHRoaXMudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuICBzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgaWdub3JlU3RhcnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VsbFggPSBjZWxsLng7XG4gICAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcbiAgICAgIHRoaXMuZm9jdXNDZWxsID0gY2VsbDtcbiAgICAgIGlmICh0aGlzLmFuY2hvckNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICAgICAgLy8gQ29sbGFwc2UgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQodGhpcy5hbmNob3JDZWxsLmVsZW0sIDAsIHRoaXMuZm9jdXNDZWxsLmVsZW0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyAmJiAodGhpcy5hbmNob3JYICE9PSBjZWxsWCB8fCB0aGlzLmFuY2hvclkgIT09IGNlbGxZIHx8IGlnbm9yZVN0YXJ0KSkge1xuICAgICAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgfSBlbHNlIGlmIChjZWxsWCA9PT0gdGhpcy5mb2N1c1ggJiYgY2VsbFkgPT09IHRoaXMuZm9jdXNZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9jdXNYID0gY2VsbFg7XG4gICAgICB0aGlzLmZvY3VzWSA9IGNlbGxZO1xuICAgICAgaWYgKHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscykge1xuICAgICAgICBjb25zdCBmb2N1c1RhYmxlQ2VsbE5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuICAgICAgICBpZiAodGhpcy50YWJsZVNlbGVjdGlvbiAhPSBudWxsICYmIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgIT0gbnVsbCAmJiAkaXNUYWJsZUNlbGxOb2RlKGZvY3VzVGFibGVDZWxsTm9kZSkgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGZvY3VzVGFibGVDZWxsTm9kZSkpKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNOb2RlS2V5ID0gZm9jdXNUYWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSB0aGlzLnRhYmxlU2VsZWN0aW9uLmNsb25lKCkgfHwgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gZm9jdXNOb2RlS2V5O1xuICAgICAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24uc2V0KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmFuY2hvckNlbGxOb2RlS2V5LCB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24odGhpcy50YWJsZVNlbGVjdGlvbik7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gY2VsbDtcbiAgICB0aGlzLmFuY2hvclggPSBjZWxsLng7XG4gICAgdGhpcy5hbmNob3JZID0gY2VsbC55O1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBhbmNob3JUYWJsZUNlbGxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGFuY2hvclRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGVLZXkgPSBhbmNob3JUYWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbiAhPSBudWxsID8gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIDogJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBhbmNob3JOb2RlS2V5O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZvcm1hdENlbGxzKHR5cGUpIHtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ3JpZCBzZWxlY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBhbmNob3IgPSBmb3JtYXRTZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgZm9jdXMgPSBmb3JtYXRTZWxlY3Rpb24uZm9jdXM7XG4gICAgICBjb25zdCBjZWxsTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5maWx0ZXIoJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZXNbMF0uZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgY29uc3QgYWxpZ25Gb3JtYXRXaXRoID0gJGlzUGFyYWdyYXBoTm9kZShwYXJhZ3JhcGgpID8gcGFyYWdyYXBoLmdldEZvcm1hdEZsYWdzKHR5cGUsIG51bGwpIDogbnVsbDtcbiAgICAgIGNlbGxOb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgICAgYW5jaG9yLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgZm9jdXMuc2V0KGNlbGxOb2RlLmdldEtleSgpLCBjZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgZm9ybWF0U2VsZWN0aW9uLmZvcm1hdFRleHQodHlwZSwgYWxpZ25Gb3JtYXRXaXRoKTtcbiAgICAgIH0pO1xuICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgdGhpcy5lZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuICBjbGVhclRleHQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBncmlkIHNlbGVjdGlvbmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID09PSB0aGlzLnRhYmxlLmNvbHVtbnMgKiB0aGlzLnRhYmxlLnJvd3MpIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIC8vIERlbGV0ZSBlbnRpcmUgdGFibGVcbiAgICAgICAgdGFibGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9ICRnZXRSb290KCk7XG4gICAgICAgIHJvb3ROb2RlLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjZWxsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgICBjZWxsTm9kZS5hcHBlbmQocGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgY2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gcGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGhpcy50YWJsZSwgbnVsbCk7XG4gICAgICAkc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBMRVhJQ0FMX0VMRU1FTlRfS0VZID0gJ19fbGV4aWNhbFRhYmxlU2VsZWN0aW9uJztcbmNvbnN0IGdldERPTVNlbGVjdGlvbiA9IHRhcmdldFdpbmRvdyA9PiBDQU5fVVNFX0RPTSA/ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG5jb25zdCBpc01vdXNlRG93bk9uRXZlbnQgPSBldmVudCA9PiB7XG4gIHJldHVybiAoZXZlbnQuYnV0dG9ucyAmIDEpID09PSAxO1xufTtcbmZ1bmN0aW9uIGFwcGx5VGFibGVIYW5kbGVycyh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCwgZWRpdG9yLCBoYXNUYWJIYW5kbGVyKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gcm9vdCBlbGVtZW50LicpO1xuICB9XG4gIGNvbnN0IHRhYmxlT2JzZXJ2ZXIgPSBuZXcgVGFibGVPYnNlcnZlcihlZGl0b3IsIHRhYmxlTm9kZS5nZXRLZXkoKSk7XG4gIGNvbnN0IGVkaXRvcldpbmRvdyA9IGVkaXRvci5fd2luZG93IHx8IHdpbmRvdztcbiAgYXR0YWNoVGFibGVPYnNlcnZlclRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcik7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKCgpID0+IGRlYXRhdGNoVGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZU9ic2VydmVyKSk7XG4gIGNvbnN0IGNyZWF0ZU1vdXNlSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gbW92ZUV2ZW50ID0+IHtcbiAgICAgIC8vIGRlbGF5aW5nIG1vdXNlbW92ZSBoYW5kbGVyIHRvIGFsbG93IHNlbGVjdGlvbmNoYW5nZSBoYW5kbGVyIGZyb20gTGV4aWNhbEV2ZW50cy50cyB0byBiZSBleGVjdXRlZCBmaXJzdFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNNb3VzZURvd25PbkV2ZW50KG1vdmVFdmVudCkgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXNDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQobW92ZUV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChmb2N1c0NlbGwgIT09IG51bGwgJiYgKHRhYmxlT2JzZXJ2ZXIuYW5jaG9yWCAhPT0gZm9jdXNDZWxsLnggfHwgdGFibGVPYnNlcnZlci5hbmNob3JZICE9PSBmb2N1c0NlbGwueSkpIHtcbiAgICAgICAgICBtb3ZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0NlbGwpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBvbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VVcFxuICAgIH07XG4gIH07XG4gIGNvbnN0IG9uTW91c2VEb3duID0gZXZlbnQgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvcldpbmRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGlmIChhbmNob3JDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihhbmNob3JDZWxsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Nb3VzZVVwLFxuICAgICAgICBvbk1vdXNlTW92ZVxuICAgICAgfSA9IGNyZWF0ZU1vdXNlSGFuZGxlcnMoKTtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAsIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICAgIH0sIDApO1xuICB9O1xuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcblxuICAvLyBDbGVhciBzZWxlY3Rpb24gd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGRvbS5cbiAgY29uc3QgbW91c2VEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25DYWxsYmFjaywgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAnZG93bicsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ3VwJywgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICdiYWNrd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ2ZvcndhcmQnLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpLCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIGNvbnN0IGRlbGV0ZVRleHRIYW5kbGVyID0gY29tbWFuZCA9PiAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmICFpc0ZvY3VzSW5zaWRlIHx8IGlzRm9jdXNJbnNpZGUgJiYgIWlzQW5jaG9ySW5zaWRlO1xuICAgICAgaWYgKHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuY2xlYXJUZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVhcmVzdEVsZW1lbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSk7XG4gICAgICBjb25zdCB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSA9IG5lYXJlc3RFbGVtZW50Tm9kZSAmJiAkZmluZE1hdGNoaW5nUGFyZW50KG5lYXJlc3RFbGVtZW50Tm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAkaXNUYWJsZUNlbGxOb2RlKG4uZ2V0UGFyZW50KCkpKTtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUodG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUpIHx8ICEkaXNFbGVtZW50Tm9kZShuZWFyZXN0RWxlbWVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21tYW5kID09PSBERUxFVEVfTElORV9DT01NQU5EICYmIHRvcExldmVsQ2VsbEVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IEZpeCBEZWxldGUgTGluZSBpbiBUYWJsZSBDZWxscy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgW0RFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORF0uZm9yRWFjaChjb21tYW5kID0+IHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGRlbGV0ZVRleHRIYW5kbGVyKGNvbW1hbmQpLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH0pO1xuICBjb25zdCAkZGVsZXRlQ2VsbEhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgdGFibGUgYnV0IHNob3VsZCByZW1vdmUgdGhlIHdob2xlIHRhYmxlXG4gICAgLy8gd2UgZXhwYW5kIHRoZSBzZWxlY3Rpb24gc28gdGhhdCBib3RoIHRoZSBhbmNob3IgYW5kIGZvY3VzIGFyZSBvdXRzaWRlXG4gICAgLy8gdGhlIHRhYmxlIGFuZCB0aGUgZWRpdG9yJ3MgY29tbWFuZCBsaXN0ZW5lciB3aWxsIGhhbmRsZSB0aGUgZGVsZXRlXG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIGlmIChpc0FuY2hvckluc2lkZSAhPT0gaXNGb2N1c0luc2lkZSkge1xuICAgICAgY29uc3QgdGFibGVQb2ludCA9IGlzQW5jaG9ySW5zaWRlID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgICAgY29uc3Qgb3V0ZXJQb2ludCA9IGlzQW5jaG9ySW5zaWRlID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgICAgLy8gUHJlc2VydmUgdGhlIG91dGVyIHBvaW50XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0eXBlXG4gICAgICB9ID0gc2VsZWN0aW9uW291dGVyUG9pbnRdO1xuICAgICAgLy8gRXhwYW5kIHRoZSBzZWxlY3Rpb24gYXJvdW5kIHRoZSB0YWJsZVxuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdGFibGVOb2RlW3NlbGVjdGlvblt0YWJsZVBvaW50XS5pc0JlZm9yZShzZWxlY3Rpb25bb3V0ZXJQb2ludF0pID8gJ3NlbGVjdFByZXZpb3VzJyA6ICdzZWxlY3ROZXh0J10oKTtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIG91dGVyIHBvaW50IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgIG5ld1NlbGVjdGlvbltvdXRlclBvaW50XS5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xuICAgICAgLy8gTGV0IHRoZSBiYXNlIGltcGxlbWVudGF0aW9uIGhhbmRsZSB0aGUgcmVzdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGFibGVPYnNlcnZlci5jbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCAkZGVsZXRlQ2VsbEhhbmRsZXIsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfREVMRVRFX0NPTU1BTkQsICRkZWxldGVDZWxsSGFuZGxlciwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENVVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGlmICghKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ29weWluZyB0byB0aGUgY2xpcGJvYXJkIGlzIGFzeW5jIHNvIHdlIG11c3QgY2FwdHVyZSB0aGUgZGF0YVxuICAgICAgLy8gYmVmb3JlIHdlIGRlbGV0ZSBpdFxuICAgICAgdm9pZCBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgQ2xpcGJvYXJkRXZlbnQpID8gZXZlbnQgOiBudWxsLCAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uKSk7XG4gICAgICBjb25zdCBpbnRlcmNlcHRlZCA9ICRkZWxldGVDZWxsSGFuZGxlcihldmVudCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcmNlcHRlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuZm9ybWF0Q2VsbHMocGF5bG9hZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgZm9ybWF0VHlwZSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvck5vZGUpIHx8ICEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlTWFwLCBhbmNob3JDZWxsLCBmb2N1c0NlbGxdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgY29uc3QgbWF4Um93ID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydFJvdywgZm9jdXNDZWxsLnN0YXJ0Um93KTtcbiAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChhbmNob3JDZWxsLnN0YXJ0Q29sdW1uLCBmb2N1c0NlbGwuc3RhcnRDb2x1bW4pO1xuICAgIGNvbnN0IG1pblJvdyA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWluQ29sdW1uID0gTWF0aC5taW4oYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBmb3IgKGxldCBpID0gbWluUm93OyBpIDw9IG1heFJvdzsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbWluQ29sdW1uOyBqIDw9IG1heENvbHVtbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZU1hcFtpXVtqXS5jZWxsO1xuICAgICAgICBjZWxsLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgY29uc3QgY2VsbENoaWxkcmVuID0gY2VsbC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNlbGxDaGlsZHJlbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2VsbENoaWxkcmVuW2tdO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICAgICAgaWYgKGVkZ2VQb3NpdGlvbikge1xuICAgICAgICAgICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSwgWyRjcmVhdGVUZXh0Tm9kZShwYXlsb2FkKV0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICBpZiAoaGFzVGFiSGFuZGxlcikge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICBpZiAodGFibGVDZWxsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgc2VsZWN0VGFibGVOb2RlSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVOb2RlLCBjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksICFldmVudC5zaGlmdEtleSA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9DVVNfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICBmdW5jdGlvbiBnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkge1xuICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICByZXR1cm4gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gIH1cbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCBzZWxlY3Rpb25QYXlsb2FkID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBub2RlcyxcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBzZWxlY3Rpb25QYXlsb2FkO1xuICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgPSBpc1JhbmdlU2VsZWN0aW9uICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSkgIT09IG51bGwgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsIHx8IGlzVGFibGVTZWxlY3Rpb247XG4gICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMSB8fCAhJGlzVGFibGVOb2RlKG5vZGVzWzBdKSB8fCAhaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgfHwgYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvcl0gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBuZXdHcmlkID0gbm9kZXNbMF07XG4gICAgY29uc3QgbmV3R3JpZFJvd3MgPSBuZXdHcmlkLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgbmV3Q29sdW1uQ291bnQgPSBuZXdHcmlkLmdldEZpcnN0Q2hpbGRPclRocm93KCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgbmV3Um93Q291bnQgPSBuZXdHcmlkLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGdyaWRDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICBjb25zdCBncmlkUm93Tm9kZSA9IGdyaWRDZWxsTm9kZSAmJiAkZmluZE1hdGNoaW5nUGFyZW50KGdyaWRDZWxsTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuICAgIGNvbnN0IGdyaWROb2RlID0gZ3JpZFJvd05vZGUgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChncmlkUm93Tm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShncmlkQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZVJvd05vZGUoZ3JpZFJvd05vZGUpIHx8ICEkaXNUYWJsZU5vZGUoZ3JpZE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0WSA9IGdyaWRSb3dOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1pbihncmlkTm9kZS5nZXRDaGlsZHJlblNpemUoKSAtIDEsIHN0YXJ0WSArIG5ld1Jvd0NvdW50IC0gMSk7XG4gICAgY29uc3Qgc3RhcnRYID0gZ3JpZENlbGxOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgY29uc3Qgc3RvcFggPSBNYXRoLm1pbihncmlkUm93Tm9kZS5nZXRDaGlsZHJlblNpemUoKSAtIDEsIHN0YXJ0WCArIG5ld0NvbHVtbkNvdW50IC0gMSk7XG4gICAgY29uc3QgZnJvbVggPSBNYXRoLm1pbihzdGFydFgsIHN0b3BYKTtcbiAgICBjb25zdCBmcm9tWSA9IE1hdGgubWluKHN0YXJ0WSwgc3RvcFkpO1xuICAgIGNvbnN0IHRvWCA9IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpO1xuICAgIGNvbnN0IHRvWSA9IE1hdGgubWF4KHN0YXJ0WSwgc3RvcFkpO1xuICAgIGNvbnN0IGdyaWRSb3dOb2RlcyA9IGdyaWROb2RlLmdldENoaWxkcmVuKCk7XG4gICAgbGV0IG5ld1Jvd0lkeCA9IDA7XG4gICAgZm9yIChsZXQgciA9IGZyb21ZOyByIDw9IHRvWTsgcisrKSB7XG4gICAgICBjb25zdCBjdXJyZW50R3JpZFJvd05vZGUgPSBncmlkUm93Tm9kZXNbcl07XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50R3JpZFJvd05vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0dyaWRSb3dOb2RlID0gbmV3R3JpZFJvd3NbbmV3Um93SWR4XTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKG5ld0dyaWRSb3dOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBncmlkQ2VsbE5vZGVzID0gY3VycmVudEdyaWRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCBuZXdHcmlkQ2VsbE5vZGVzID0gbmV3R3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGxldCBuZXdDb2x1bW5JZHggPSAwO1xuICAgICAgZm9yIChsZXQgYyA9IGZyb21YOyBjIDw9IHRvWDsgYysrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRHcmlkQ2VsbE5vZGUgPSBncmlkQ2VsbE5vZGVzW2NdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY3VycmVudEdyaWRDZWxsTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3R3JpZENlbGxOb2RlID0gbmV3R3JpZENlbGxOb2Rlc1tuZXdDb2x1bW5JZHhdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobmV3R3JpZENlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbENoaWxkcmVuID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBuZXdHcmlkQ2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICAgIGN1cnJlbnRHcmlkQ2VsbE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEdyaWRDZWxsTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsQ2hpbGRyZW4uZm9yRWFjaChuID0+IG4ucmVtb3ZlKCkpO1xuICAgICAgICBuZXdDb2x1bW5JZHgrKztcbiAgICAgIH1cbiAgICAgIG5ld1Jvd0lkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1c1xuICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgLy8gVXNpbmcgZXhwbGljaXQgY29tcGFyaXNvbiB3aXRoIHRhYmxlIG5vZGUgdG8gZW5zdXJlIGl0J3Mgbm90IGEgbmVzdGVkIHRhYmxlXG4gICAgICAvLyBhcyBpbiB0aGF0IGNhc2Ugd2UnbGwgbGVhdmUgc2VsZWN0aW9uIHJlc29sdmluZyB0byB0aGF0IHRhYmxlXG4gICAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShmb2N1c05vZGUpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSAhIShhbmNob3JDZWxsTm9kZSAmJiB0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoYW5jaG9yQ2VsbE5vZGUpKSk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gISEoZm9jdXNDZWxsTm9kZSAmJiB0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNDZWxsTm9kZSkpKTtcbiAgICAgIGNvbnN0IGlzUGFydGlhbHlXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICE9PSBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGlmIChpc1BhcnRpYWx5V2l0aGluVGFibGUpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIGlmIChpc0ZvY3VzSW5zaWRlKSB7XG4gICAgICAgICAgY29uc3QgW3RhYmxlTWFwXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBmb2N1c0NlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXS5jZWxsO1xuICAgICAgICAgIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV0uYXQoLTEpLmNlbGw7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldChpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldEtleSgpIDogbGFzdENlbGwuZ2V0S2V5KCksIGlzQmFja3dhcmQgPyBmaXJzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiBsYXN0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FuY2hvckluc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXS5jZWxsO1xuICAgICAgICAgIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV0uYXQoLTEpLmNlbGw7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgaXNCYWNrd2FyZCwgc2V0IHRoZSBhbmNob3IgdG8gYmUgYXQgdGhlIGVuZCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBjdXJzb3IgbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgICAgICAqIHRoZSB0YWJsZSBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uLCB0aGUgZW50aXJlIHRhYmxlIHdpbGwgYmUgc2VsZWN0ZWQgZnJvbSBpdHMgZW5kLlxuICAgICAgICAgICAqIE90aGVyd2lzZSwgaWYgZm9yd2FyZCwgc2V0IHRoZSBhbmNob3IgdG8gYmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZSBzbyB0aGF0IHdoZW4gdGhlIGZvY3VzIGlzIGRyYWdnZWRcbiAgICAgICAgICAgKiBvdXRzaWRlIHRoIGVuZCBvZiB0aGUgdGFibGUsIGl0IHdpbGwgc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0YWJsZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuZXdTZWxlY3Rpb24uYW5jaG9yLnNldChpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0S2V5KCkgOiBmaXJzdENlbGwuZ2V0S2V5KCksIGlzQmFja3dhcmQgPyBsYXN0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgICB9IGVsc2UgaWYgKGlzV2l0aGluVGFibGUpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBzZWxlY3Rpb24gc3BhbnMgYWNyb3NzIG11bHRpcGxlIGNlbGxzIGJ1dCBzdGlsbFxuICAgICAgICAvLyBoYXMgcmFuZ2Ugc2VsZWN0aW9uLCB0aGVuIHdlIGNvbnZlcnQgaXQgaW50byBncmlkIHNlbGVjdGlvblxuICAgICAgICBpZiAoIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci5zZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSkpO1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZShmb2N1c0NlbGxOb2RlKSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCF0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG9uTW91c2VVcCxcbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZVxuICAgICAgICAgICAgICB9ID0gY3JlYXRlTW91c2VIYW5kbGVycygpO1xuICAgICAgICAgICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICAgICAgICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gJiYgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU5vZGUuZ2V0S2V5KCkpIHtcbiAgICAgIC8vIGlmIHNlbGVjdGlvbiBnb2VzIG91dHNpZGUgb2YgdGhlIHRhYmxlIHdlIG5lZWQgdG8gY2hhbmdlIGl0IHRvIFJhbmdlIHNlbGVjdGlvblxuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgJiYgZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSkge1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21TZWxlY3Rpb24uZm9jdXNOb2RlKTtcbiAgICAgICAgY29uc3QgaXNGb2N1c091dHNpZGUgPSBmb2N1c05vZGUgJiYgIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c05vZGUpKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSBhbmNob3JOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JOb2RlKSk7XG4gICAgICAgIGlmIChpc0ZvY3VzT3V0c2lkZSAmJiBpc0FuY2hvckluc2lkZSAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tKGRvbVNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgICBpZiAobmV3U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uYW5jaG9yLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0aW9uICYmICFzZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikgJiYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpICYmIHRhYmxlT2JzZXJ2ZXIudGFibGVTZWxlY3Rpb24gJiYgIXRhYmxlT2JzZXJ2ZXIudGFibGVTZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikpIHtcbiAgICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci51cGRhdGVUYWJsZVRhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhYmxlT2JzZXJ2ZXIuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKCF0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICBpZiAoZWRnZVBvc2l0aW9uKSB7XG4gICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICByZXR1cm4gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGRlYXRhdGNoVGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZU9ic2VydmVyKSB7XG4gIGlmIChnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpID09PSB0YWJsZU9ic2VydmVyKSB7XG4gICAgZGVsZXRlIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoVGFibGVPYnNlcnZlclRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoIShnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpID09PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGB0YWJsZUVsZW1lbnQgYWxyZWFkeSBoYXMgYW4gYXR0YWNoZWQgVGFibGVPYnNlcnZlcmApO1xuICB9XG4gIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXSA9IHRhYmxlT2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpIHtcbiAgcmV0dXJuIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NQ2VsbEZyb21UYXJnZXQobm9kZSkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGVOYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnVEQnIHx8IG5vZGVOYW1lID09PSAnVEgnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgY2VsbCA9IGN1cnJlbnROb2RlLl9jZWxsO1xuICAgICAgaWYgKGNlbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpIHtcbiAgY29uc3QgZG9tUm93cyA9IFtdO1xuICBjb25zdCBncmlkID0ge1xuICAgIGNvbHVtbnM6IDAsXG4gICAgZG9tUm93cyxcbiAgICByb3dzOiAwXG4gIH07XG4gIGxldCBjdXJyZW50Tm9kZSA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0cicpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgZG9tUm93cy5sZW5ndGggPSAwO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGVNYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVNYW1lID09PSAnVEQnIHx8IG5vZGVNYW1lID09PSAnVEgnKSB7XG4gICAgICBjb25zdCBlbGVtID0gY3VycmVudE5vZGU7XG4gICAgICBjb25zdCBjZWxsID0ge1xuICAgICAgICBlbGVtLFxuICAgICAgICBoYXNCYWNrZ3JvdW5kQ29sb3I6IGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yICE9PSAnJyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY3VycmVudE5vZGUuX2NlbGwgPSBjZWxsO1xuICAgICAgbGV0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm93ID0gZG9tUm93c1t5XSA9IFtdO1xuICAgICAgfVxuICAgICAgcm93W3hdID0gY2VsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAoc2libGluZyAhPSBudWxsKSB7XG4gICAgICB4Kys7XG4gICAgICBjdXJyZW50Tm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQubmV4dFNpYmxpbmc7XG4gICAgICBpZiAocGFyZW50U2libGluZyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeSsrO1xuICAgICAgeCA9IDA7XG4gICAgICBjdXJyZW50Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGdyaWQuY29sdW1ucyA9IHggKyAxO1xuICBncmlkLnJvd3MgPSB5ICsgMTtcbiAgcmV0dXJuIGdyaWQ7XG59XG5mdW5jdGlvbiAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGFibGUsIHNlbGVjdGlvbikge1xuICBjb25zdCBzZWxlY3RlZENlbGxOb2RlcyA9IG5ldyBTZXQoc2VsZWN0aW9uID8gc2VsZWN0aW9uLmdldE5vZGVzKCkgOiBbXSk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlLCAoY2VsbCwgbGV4aWNhbE5vZGUpID0+IHtcbiAgICBjb25zdCBlbGVtID0gY2VsbC5lbGVtO1xuICAgIGlmIChzZWxlY3RlZENlbGxOb2Rlcy5oYXMobGV4aWNhbE5vZGUpKSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAgICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpO1xuICAgICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJGZvckVhY2hUYWJsZUNlbGwoZ3JpZCwgY2IpIHtcbiAgY29uc3Qge1xuICAgIGRvbVJvd3NcbiAgfSA9IGdyaWQ7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgZG9tUm93cy5sZW5ndGg7IHkrKykge1xuICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgaWYgKCFyb3cpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICAgIGlmIChsZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYihjZWxsLCBsZXhpY2FsTm9kZSwge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZVNlbGVjdGlvbikge1xuICB0YWJsZVNlbGVjdGlvbi5kaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgJGZvckVhY2hUYWJsZUNlbGwodGFibGVTZWxlY3Rpb24udGFibGUsIGNlbGwgPT4ge1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpO1xuICB9KTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKSB7XG4gIHRhYmxlT2JzZXJ2ZXIuZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgJGZvckVhY2hUYWJsZUNlbGwodGFibGVPYnNlcnZlci50YWJsZSwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3Qgc2VsZWN0VGFibGVOb2RlSW5EaXJlY3Rpb24gPSAodGFibGVPYnNlcnZlciwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnYmFja3dhcmQnOlxuICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgaWYgKHggIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLmNvbHVtbnMgLSAxIDogMCkpIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeSAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlT2JzZXJ2ZXIudGFibGUucm93cyAtIDEgOiAwKSkge1xuICAgICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyhpc0ZvcndhcmQgPyAwIDogdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSwgeSArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB0YWJsZU9ic2VydmVyLnRhYmxlKSwgaXNGb3J3YXJkKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNGb3J3YXJkKSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHkgLSAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdkb3duJzpcbiAgICAgIGlmICh5ICE9PSB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5ICsgMSwgdGFibGVPYnNlcnZlci50YWJsZSksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5jb25zdCBhZGp1c3RGb2N1c05vZGVJbkRpcmVjdGlvbiA9ICh0YWJsZU9ic2VydmVyLCB0YWJsZU5vZGUsIHgsIHksIGRpcmVjdGlvbikgPT4ge1xuICBjb25zdCBpc0ZvcndhcmQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJztcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICBpZiAoeCAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEgOiAwKSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB5LCB0YWJsZU9ic2VydmVyLnRhYmxlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICd1cCc6XG4gICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSAtIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICByZXR1cm4gaXNBbmNob3JJbnNpZGUgJiYgaXNGb2N1c0luc2lkZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCwgZnJvbVN0YXJ0KSB7XG4gIGlmIChmcm9tU3RhcnQpIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmNvbnN0IEJST1dTRVJfQkxVRV9SR0IgPSAnMTcyLDIwNiwyNDcnO1xuZnVuY3Rpb24gJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCkge1xuICBjb25zdCBlbGVtZW50ID0gY2VsbC5lbGVtO1xuICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZWxlbWVudCk7XG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gbm9kZS5nZXRCYWNrZ3JvdW5kQ29sb3IoKTtcbiAgaWYgKGJhY2tncm91bmRDb2xvciA9PT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBgcmdiKCR7QlJPV1NFUl9CTFVFX1JHQn0pYCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsIGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHJnYmEoJHtCUk9XU0VSX0JMVUVfUkdCfSwwLjg1KSwgcmdiYSgke0JST1dTRVJfQkxVRV9SR0J9LDAuODUpKWApO1xuICB9XG4gIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2NhcmV0LWNvbG9yJywgJ3RyYW5zcGFyZW50Jyk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBMZXhpY2FsTm9kZSBmcm9tIFRhYmxlIENlbGwgRE9NTm9kZWApO1xuICB9XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG5vZGUuZ2V0QmFja2dyb3VuZENvbG9yKCk7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gIH1cbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjYXJldC1jb2xvcicpO1xufVxuZnVuY3Rpb24gJGZpbmRDZWxsTm9kZShub2RlKSB7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuICRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpID8gY2VsbE5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGZpbmRUYWJsZU5vZGUobm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZU5vZGUodGFibGVOb2RlKSA/IHRhYmxlTm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgZGlyZWN0aW9uLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgaWYgKChkaXJlY3Rpb24gPT09ICd1cCcgfHwgZGlyZWN0aW9uID09PSAnZG93bicpICYmIGlzVHlwZWFoZWFkTWVudUluVmlldyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvclR5cGUgPSBzZWxlY3Rpb24uYW5jaG9yLnR5cGU7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgICAgICBpZiAoYW5jaG9yVHlwZSAhPT0gJ2VsZW1lbnQnICYmICEoYW5jaG9yVHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvck9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIWFuY2hvck5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgaWYgKCFzaWJsaW5nTm9kZSB8fCAhJGlzVGFibGVOb2RlKHNpYmxpbmdOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBzaWJsaW5nTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChkaXJlY3Rpb24gPT09ICd1cCcgfHwgZGlyZWN0aW9uID09PSAnZG93bicpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICAgIGNvbnN0IGlzVGFibGVVbnNlbGVjdCA9ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAoZGlyZWN0aW9uID09PSAndXAnICYmICFzZWxlY3Rpb24uaXNCYWNrd2FyZCgpIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nICYmIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkpO1xuICAgICAgICBpZiAoaXNUYWJsZVVuc2VsZWN0KSB7XG4gICAgICAgICAgbGV0IGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNQYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c1BhcmVudE5vZGUsICRpc1RhYmxlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb2N1c1BhcmVudE5vZGUgIT09IHRhYmxlTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvY3VzUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gZGlyZWN0aW9uID09PSAnZG93bicgPyBmb2N1c1BhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA6IGZvY3VzUGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgICBpZiAoIXNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgIG5ld09mZnNldCA9IHNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdGb2N1c05vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHNpYmxpbmcuZ2V0TGFzdENoaWxkKCk7XG4gICAgICAgICAgICAgIG5ld0ZvY3VzTm9kZSA9IGxhc3RDZWxsID8gbGFzdENlbGwgOiBzaWJsaW5nO1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSAkaXNUZXh0Tm9kZShuZXdGb2N1c05vZGUpID8gbmV3Rm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldChuZXdGb2N1c05vZGUuZ2V0S2V5KCksIG5ld09mZnNldCwgJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/ICd0ZXh0JyA6ICdlbGVtZW50Jyk7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gZGlyZWN0aW9uID09PSAndXAnID8gc2VsZWN0aW9uLmdldE5vZGVzKClbc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoIC0gMV0gOiBzZWxlY3Rpb24uZ2V0Tm9kZXMoKVswXTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3RlZE5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzUGFyZW50T2YodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gdGFibGVOb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0RGVzY2VuZGFudCB8fCAhbGFzdERlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGZpcnN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsQ29vcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGZpcnN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbENvb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShsYXN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coZmlyc3RDZWxsQ29vcmRzLngsIGZpcnN0Q2VsbENvb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3cobGFzdENlbGxDb29yZHMueCwgbGFzdENlbGxDb29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihmaXJzdENlbGxET00pO1xuICAgICAgICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihsYXN0Q2VsbERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNOb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICFuLmlzSW5saW5lKCkpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzUGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNQYXJlbnROb2RlLCAkaXNUYWJsZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvY3VzUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gZGlyZWN0aW9uID09PSAnZG93bicgPyBmb2N1c1BhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA6IGZvY3VzUGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgICBpZiAoJGlzVGFibGVOb2RlKHNpYmxpbmcpICYmIHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5ID09PSBzaWJsaW5nLmdldEtleSgpKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSBzaWJsaW5nLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBzaWJsaW5nLmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0RGVzY2VuZGFudCB8fCAhbGFzdERlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGZpcnN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICBjb25zdCBbbGFzdENlbGxOb2RlXSA9ICRnZXROb2RlVHJpcGxldChsYXN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBzZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoKGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGZpcnN0Q2VsbE5vZGUgOiBsYXN0Q2VsbE5vZGUpLmdldEtleSgpLCBkaXJlY3Rpb24gPT09ICd1cCcgPyAwIDogbGFzdENlbGxOb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlID0gJGZpbmRUYWJsZU5vZGUoYW5jaG9yQ2VsbE5vZGUpO1xuICAgIGlmIChhbmNob3JDZWxsVGFibGUgIT09IHRhYmxlTm9kZSAmJiBhbmNob3JDZWxsVGFibGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbFRhYmxlLmdldEtleSgpKTtcbiAgICAgIGlmIChhbmNob3JDZWxsVGFibGVFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci50YWJsZSA9IGdldFRhYmxlKGFuY2hvckNlbGxUYWJsZUVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgYW5jaG9yQ2VsbFRhYmxlLCB0YWJsZU9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgY29uc3QgYW5jaG9yVHlwZSA9IGFuY2hvci50eXBlO1xuICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCFhbmNob3JOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiAkaXNEZWNvcmF0b3JOb2RlKHNlbGVjdGVkTm9kZXNbMF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0V4aXRpbmdUYWJsZUFuY2hvcihhbmNob3JUeXBlLCBhbmNob3JPZmZzZXQsIGFuY2hvck5vZGUsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuICRoYW5kbGVUYWJsZUV4aXQoZXZlbnQsIGFuY2hvck5vZGUsIHRhYmxlTm9kZSwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbERvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbE5vZGUuX19rZXkpO1xuICAgIGNvbnN0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yLmtleSk7XG4gICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgZWRnZVNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVkZ2VTZWxlY3Rpb25SZWN0ID0gYW5jaG9yRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBjb25zdCBlZGdlQ2hpbGQgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBhbmNob3JDZWxsTm9kZS5nZXRGaXJzdENoaWxkKCkgOiBhbmNob3JDZWxsTm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoZWRnZUNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWRnZUNoaWxkRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlZGdlQ2hpbGQuX19rZXkpO1xuICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc0V4aXRpbmcgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBlZGdlUmVjdC50b3AgPiBlZGdlU2VsZWN0aW9uUmVjdC50b3AgLSBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgOiBlZGdlU2VsZWN0aW9uUmVjdC5ib3R0b20gKyBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgPiBlZGdlUmVjdC5ib3R0b207XG4gICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGNvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IFt0YWJsZU5vZGVGcm9tU2VsZWN0aW9uXSA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlRnJvbVNlbGVjdGlvbi5nZXRLZXkoKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVOb2RlKHRhYmxlTm9kZUZyb21TZWxlY3Rpb24pIHx8IHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpO1xuICAgIGNvbnN0IGNvcmRzQW5jaG9yID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlLCBncmlkKTtcbiAgICBjb25zdCBhbmNob3JDZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzQW5jaG9yLngsIGNvcmRzQW5jaG9yLnksIGdyaWQpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihhbmNob3JDZWxsKTtcbiAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSwgZ3JpZCk7XG4gICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWFoZWFkTWVudUluVmlldyhlZGl0b3IpIHtcbiAgLy8gVGhlcmUgaXMgbm8gaW5idWlsdCB3YXkgdG8gY2hlY2sgaWYgdGhlIGNvbXBvbmVudCBwaWNrZXIgaXMgaW4gdmlld1xuICAvLyBidXQgd2UgY2FuIGNoZWNrIGlmIHRoZSByb290IERPTSBlbGVtZW50IGhhcyB0aGUgYXJpYS1jb250cm9scyBhdHRyaWJ1dGUgXCJ0eXBlYWhlYWQtbWVudVwiLlxuICBjb25zdCByb290ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGlmICghcm9vdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcm9vdC5oYXNBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSAmJiByb290LmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpID09PSAndHlwZWFoZWFkLW1lbnUnO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nVGFibGVBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGlzRXhpdGluZ1RhYmxlRWxlbWVudEFuY2hvcih0eXBlLCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHx8ICRpc0V4aXRpbmdUYWJsZVRleHRBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nVGFibGVFbGVtZW50QW5jaG9yKHR5cGUsIGFuY2hvck5vZGUsIGRpcmVjdGlvbikge1xuICByZXR1cm4gdHlwZSA9PT0gJ2VsZW1lbnQnICYmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsIDogYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uICRpc0V4aXRpbmdUYWJsZVRleHRBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc1ZhbGlkT2Zmc2V0ID0gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gb2Zmc2V0ID09PSAwIDogb2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHQnICYmIGhhc1ZhbGlkT2Zmc2V0ICYmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsIDogcGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uICRoYW5kbGVUYWJsZUV4aXQoZXZlbnQsIGFuY2hvck5vZGUsIHRhYmxlTm9kZSwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbdGFibGVNYXAsIGNlbGxWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgaWYgKCFpc0V4aXRpbmdDZWxsKHRhYmxlTWFwLCBjZWxsVmFsdWUsIGRpcmVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9Ob2RlID0gJGdldEV4aXRpbmdUb05vZGUoYW5jaG9yTm9kZSwgZGlyZWN0aW9uLCB0YWJsZU5vZGUpO1xuICBpZiAoIXRvTm9kZSB8fCAkaXNUYWJsZU5vZGUodG9Ob2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpO1xuICBpZiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKSB7XG4gICAgdG9Ob2RlLnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHRvTm9kZS5zZWxlY3RTdGFydCgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nQ2VsbCh0YWJsZU1hcCwgY2VsbFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF07XG4gIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV1bdGFibGVNYXBbMF0ubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbixcbiAgICBzdGFydFJvd1xuICB9ID0gY2VsbFZhbHVlO1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gc3RhcnRDb2x1bW4gPT09IGZpcnN0Q2VsbC5zdGFydENvbHVtbiAmJiBzdGFydFJvdyA9PT0gZmlyc3RDZWxsLnN0YXJ0Um93IDogc3RhcnRDb2x1bW4gPT09IGxhc3RDZWxsLnN0YXJ0Q29sdW1uICYmIHN0YXJ0Um93ID09PSBsYXN0Q2VsbC5zdGFydFJvdztcbn1cbmZ1bmN0aW9uICRnZXRFeGl0aW5nVG9Ob2RlKGFuY2hvck5vZGUsIGRpcmVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgYW5jaG9yU2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIHJldHVybiBhbmNob3JTaWJsaW5nICYmICRpc1RhYmxlTm9kZShhbmNob3JTaWJsaW5nKSA/IGFuY2hvclNpYmxpbmcgOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyB0YWJsZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiB0YWJsZU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSwgY2hpbGRyZW4pIHtcbiAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIGlmIChlZGdlUG9zaXRpb24gPT09ICdmaXJzdCcpIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlTm9kZS5pbnNlcnRBZnRlcihwYXJhZ3JhcGhOb2RlKTtcbiAgfVxuICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCguLi4oY2hpbGRyZW4gfHwgW10pKTtcbiAgcGFyYWdyYXBoTm9kZS5zZWxlY3RFbmQoKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCF0YWJsZU5vZGVQYXJlbnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlUGFyZW50LmdldEtleSgpKTtcbiAgaWYgKCF0YWJsZU5vZGVQYXJlbnRET00pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIG5lc3RlZCB0YWJsZXNcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAhPT0gdGFibGVOb2RlUGFyZW50RE9NKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gIGlmICghYW5jaG9yQ2VsbE5vZGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHBhcmVudFRhYmxlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JDZWxsTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICBpZiAoISRpc1RhYmxlTm9kZShwYXJlbnRUYWJsZSkgfHwgIXBhcmVudFRhYmxlLmlzKHRhYmxlTm9kZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IFt0YWJsZU1hcCwgY2VsbFZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsTm9kZSwgYW5jaG9yQ2VsbE5vZGUpO1xuICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXTtcbiAgY29uc3QgbGFzdENlbGwgPSB0YWJsZU1hcFt0YWJsZU1hcC5sZW5ndGggLSAxXVt0YWJsZU1hcFswXS5sZW5ndGggLSAxXTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0gPSBjZWxsVmFsdWU7XG4gIGNvbnN0IGlzQXRGaXJzdENlbGwgPSBzdGFydFJvdyA9PT0gZmlyc3RDZWxsLnN0YXJ0Um93ICYmIHN0YXJ0Q29sdW1uID09PSBmaXJzdENlbGwuc3RhcnRDb2x1bW47XG4gIGNvbnN0IGlzQXRMYXN0Q2VsbCA9IHN0YXJ0Um93ID09PSBsYXN0Q2VsbC5zdGFydFJvdyAmJiBzdGFydENvbHVtbiA9PT0gbGFzdENlbGwuc3RhcnRDb2x1bW47XG4gIGlmIChpc0F0Rmlyc3RDZWxsKSB7XG4gICAgcmV0dXJuICdmaXJzdCc7XG4gIH0gZWxzZSBpZiAoaXNBdExhc3RDZWxsKSB7XG4gICAgcmV0dXJuICdsYXN0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlQ29sZ3JvdXAoZG9tLCBjb25maWcsIGNvbENvdW50LCBjb2xXaWR0aHMpIHtcbiAgY29uc3QgY29sR3JvdXAgPSBkb20ucXVlcnlTZWxlY3RvcignY29sZ3JvdXAnKTtcbiAgaWYgKCFjb2xHcm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb2xzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IGNvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbCcpO1xuICAgIGNvbnN0IHdpZHRoID0gY29sV2lkdGhzICYmIGNvbFdpZHRoc1tpXTtcbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIGNvbC5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAgICB9XG4gICAgY29scy5wdXNoKGNvbCk7XG4gIH1cbiAgY29sR3JvdXAucmVwbGFjZUNoaWxkcmVuKC4uLmNvbHMpO1xufVxuZnVuY3Rpb24gc2V0Um93U3RyaXBpbmcoZG9tLCBjb25maWcsIHJvd1N0cmlwaW5nKSB7XG4gIGlmIChyb3dTdHJpcGluZykge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVSb3dTdHJpcGluZyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlUm93U3RyaXBpbmcpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1yb3ctc3RyaXBpbmcnKTtcbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cbiAgZ2V0Q29sV2lkdGhzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fY29sV2lkdGhzO1xuICB9XG4gIHNldENvbFdpZHRocyhjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIC8vIE5PVEU6IE5vZGUgcHJvcGVydGllcyBzaG91bGQgYmUgaW1tdXRhYmxlLiBGcmVlemUgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uLlxuICAgIHNlbGYuX19jb2xXaWR0aHMgPSBPYmplY3QuZnJlZXplKGNvbFdpZHRocykgO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2NvbFdpZHRocyA9IHByZXZOb2RlLl9fY29sV2lkdGhzO1xuICAgIHRoaXMuX19yb3dTdHJpcGluZyA9IHByZXZOb2RlLl9fcm93U3RyaXBpbmc7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGU6IF9ub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZSgpO1xuICAgIHRhYmxlTm9kZS5fX3Jvd1N0cmlwaW5nID0gc2VyaWFsaXplZE5vZGUucm93U3RyaXBpbmcgfHwgZmFsc2U7XG4gICAgdGFibGVOb2RlLl9fY29sV2lkdGhzID0gc2VyaWFsaXplZE5vZGUuY29sV2lkdGhzO1xuICAgIHJldHVybiB0YWJsZU5vZGU7XG4gIH1cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fcm93U3RyaXBpbmcgPSBmYWxzZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBjb2xXaWR0aHM6IHRoaXMuZ2V0Q29sV2lkdGhzKCksXG4gICAgICByb3dTdHJpcGluZzogdGhpcy5fX3Jvd1N0cmlwaW5nID8gdGhpcy5fX3Jvd1N0cmlwaW5nIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgY29uc3QgY29sR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgIHRhYmxlRWxlbWVudC5hcHBlbmRDaGlsZChjb2xHcm91cCk7XG4gICAgdXBkYXRlQ29sZ3JvdXAodGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgdGhpcy5nZXRDb2xXaWR0aHMoKSk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZSk7XG4gICAgaWYgKHRoaXMuX19yb3dTdHJpcGluZykge1xuICAgICAgc2V0Um93U3RyaXBpbmcodGFibGVFbGVtZW50LCBjb25maWcsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGVFbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBpZiAocHJldk5vZGUuX19yb3dTdHJpcGluZyAhPT0gdGhpcy5fX3Jvd1N0cmlwaW5nKSB7XG4gICAgICBzZXRSb3dTdHJpcGluZyhkb20sIGNvbmZpZywgdGhpcy5fX3Jvd1N0cmlwaW5nKTtcbiAgICB9XG4gICAgdXBkYXRlQ29sZ3JvdXAoZG9tLCBjb25maWcsIHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgdGhpcy5nZXRDb2xXaWR0aHMoKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0RE9NKGVkaXRvciksXG4gICAgICBhZnRlcjogdGFibGVFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHRhYmxlRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSB0YWJsZUVsZW1lbnQuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgY29uc3QgY29sR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgICAgICAgIGNvbnN0IHRCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudCh0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xzID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbCcpO1xuICAgICAgICAgICAgY29sR3JvdXAuYXBwZW5kKC4uLmNvbHMpO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCd0cicpO1xuICAgICAgICAgICAgdEJvZHkuYXBwZW5kKC4uLnJvd3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdFbGVtZW50LnJlcGxhY2VDaGlsZHJlbihjb2xHcm91cCwgdEJvZHkpO1xuICAgICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3dzLFxuICAgICAgZG9tUm93c1xuICAgIH0gPSB0YWJsZTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvd3M7IHkrKykge1xuICAgICAgY29uc3Qgcm93ID0gZG9tUm93c1t5XTtcbiAgICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSByb3cuZmluZEluZGV4KGNlbGwgPT4ge1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVsZW1cbiAgICAgICAgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IGNlbGxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZWxlbSk7XG4gICAgICAgIHJldHVybiBjZWxsTm9kZSA9PT0gdGFibGVDZWxsTm9kZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgaW4gdGFibGUuJyk7XG4gIH1cbiAgZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgY29uc3Qgcm93ID0gZG9tUm93c1t5XTtcbiAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHggPCByb3cubGVuZ3RoID8geCA6IHJvdy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGNlbGwgPSByb3dbaW5kZXhdO1xuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuICBnZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmICghY2VsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIG5vdCBmb3VuZCBhdCBjb3Jkcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgYXQgY29yZHMgbm90IFRhYmxlQ2VsbE5vZGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGdldFJvd1N0cmlwaW5nKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0TGF0ZXN0KCkuX19yb3dTdHJpcGluZyk7XG4gIH1cbiAgc2V0Um93U3RyaXBpbmcobmV3Um93U3RyaXBpbmcpIHtcbiAgICB0aGlzLmdldFdyaXRhYmxlKCkuX19yb3dTdHJpcGluZyA9IG5ld1Jvd1N0cmlwaW5nO1xuICB9XG4gIGNhblNlbGVjdEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldENvbHVtbkNvdW50KCkge1xuICAgIGNvbnN0IGZpcnN0Um93ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCFmaXJzdFJvdykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XG4gICAgZmlyc3RSb3cuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoY2VsbCkpIHtcbiAgICAgICAgY29sdW1uQ291bnQgKz0gY2VsbC5nZXRDb2xTcGFuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbkNvdW50O1xuICB9XG59XG5mdW5jdGlvbiAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZShlZGl0b3IsIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZS5nZXRLZXkoKSk7XG4gIGlmICh0YWJsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgRWxlbWVudCBOb3QgRm91bmQnKTtcbiAgfVxuICByZXR1cm4gZ2V0VGFibGUodGFibGVFbGVtZW50KTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGFibGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZSgpO1xuICBpZiAoZG9tTm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1yb3ctc3RyaXBpbmcnKSkge1xuICAgIHRhYmxlTm9kZS5zZXRSb3dTdHJpcGluZyh0cnVlKTtcbiAgfVxuICBjb25zdCBjb2xHcm91cCA9IGRvbU5vZGUucXVlcnlTZWxlY3RvcignOnNjb3BlID4gY29sZ3JvdXAnKTtcbiAgaWYgKGNvbEdyb3VwKSB7XG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbCBvZiBjb2xHcm91cC5xdWVyeVNlbGVjdG9yQWxsKCc6c2NvcGUgPiBjb2wnKSkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjb2wuc3R5bGUud2lkdGg7XG4gICAgICBpZiAoIXdpZHRoIHx8ICFQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3Qod2lkdGgpKSB7XG4gICAgICAgIGNvbHVtbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29sdW1ucy5wdXNoKHBhcnNlRmxvYXQod2lkdGgpKTtcbiAgICB9XG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgIHRhYmxlTm9kZS5zZXRDb2xXaWR0aHMoY29sdW1ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZTogdGFibGVOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuZXhwb3J0IHsgJGNvbXB1dGVUYWJsZU1hcCwgJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2ssICRjcmVhdGVUYWJsZUNlbGxOb2RlLCAkY3JlYXRlVGFibGVOb2RlLCAkY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMsICRjcmVhdGVUYWJsZVJvd05vZGUsICRjcmVhdGVUYWJsZVNlbGVjdGlvbiwgJGRlbGV0ZVRhYmxlQ29sdW1uLCAkZGVsZXRlVGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUwsICRmaW5kQ2VsbE5vZGUsICRmaW5kVGFibGVOb2RlLCAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZSwgJGdldE5vZGVUcmlwbGV0LCAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZSwgJGdldFRhYmxlQ2VsbE5vZGVSZWN0LCAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlLCAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdywgJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSwgJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdywgJGluc2VydFRhYmxlQ29sdW1uLCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGluc2VydFRhYmxlUm93LCAkaW5zZXJ0VGFibGVSb3dfX0VYUEVSSU1FTlRBTCwgJGlzVGFibGVDZWxsTm9kZSwgJGlzVGFibGVOb2RlLCAkaXNUYWJsZVJvd05vZGUsICRpc1RhYmxlU2VsZWN0aW9uLCAkcmVtb3ZlVGFibGVSb3dBdEluZGV4LCAkdW5tZXJnZUNlbGwsIElOU0VSVF9UQUJMRV9DT01NQU5ELCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMsIFRhYmxlQ2VsbE5vZGUsIFRhYmxlTm9kZSwgVGFibGVPYnNlcnZlciwgVGFibGVSb3dOb2RlLCBhcHBseVRhYmxlSGFuZGxlcnMsIGdldERPTUNlbGxGcm9tVGFyZ2V0LCBnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ })

};
;