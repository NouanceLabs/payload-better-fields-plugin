"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+utils@0.20.0";
exports.ids = ["vendor-chunks/@lexical+utils@0.20.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!****************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ positionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/../node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/../node_modules/.pnpm/@lexical+selection@0.20.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3V0aWxzQDAuMjAuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK047QUFDckg7QUFDN0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQiwyRUFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDLFdBQVcsMERBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc1JBQXNSLDZDQUFRO0FBQzlSLDRRQUE0USw2Q0FBUTtBQUNwUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9DQUFvQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVEQUFjO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVEQUFjO0FBQ3pFLE9BQU8sdURBQWM7QUFDckI7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQWE7QUFDZjs7QUFFQTtBQUNBLHFFQUFxRSxrQ0FBa0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWEsTUFBTSw4REFBcUI7QUFDNUQsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUSw0REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLGlEQUFRO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZuQiIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3V0aWxzQDAuMjAuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgVGV4dE5vZGUsICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGNsb25lV2l0aFByb3BlcnRpZXMsICRzZXRTZWxlY3Rpb24sICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGlzVGV4dE5vZGUsICRzcGxpdE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkc3BsaXROb2RlLCBpc0Jsb2NrRG9tTm9kZSwgaXNIVE1MQW5jaG9yRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNJbmxpbmVEb21Ob2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZSB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00kMSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19BUFBMRSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0ZJUkVGT1gkMSA9IENBTl9VU0VfRE9NJDEgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMSA9IENBTl9VU0VfRE9NJDEgJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkkMSA9IENBTl9VU0VfRE9NJDEgJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MkMSA9IENBTl9VU0VfRE9NJDEgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbmNvbnN0IElTX0FORFJPSUQkMSA9IENBTl9VU0VfRE9NJDEgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0NIUk9NRSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSQxID0gQ0FOX1VTRV9ET00kMSAmJiBJU19BTkRST0lEJDEgJiYgSVNfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQkMSA9IENBTl9VU0VfRE9NJDEgJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FJDE7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGFsbCBmdW5jdGlvbnMgcGFzc2VkIHdoZW4gY2FsbGVkLiBJdCBpcyBnZW5lcmFsbHkgdXNlZFxuICogdG8gcmVnaXN0ZXIgbXVsdGlwbGUgbGV4aWNhbCBsaXN0ZW5lcnMgYW5kIHRoZW4gdGVhciB0aGVtIGRvd24gd2l0aCBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLCBzdWNoXG4gKiBhcyBSZWFjdCdzIHVzZUVmZmVjdCBob29rLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiB1c2VFZmZlY3QoKCkgPT4ge1xuICogICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDEgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMiBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQzIGxvZ2ljKVxuICogICApXG4gKiB9LCBbZWRpdG9yXSlcbiAqIGBgYFxuICogSW4gdGhpcyBjYXNlLCB1c2VFZmZlY3QgaXMgcmV0dXJuaW5nIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBtZXJnZVJlZ2lzdGVyIGFzIGEgY2xlYW51cFxuICogZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZWl0aGVyIHRoZSB1c2VFZmZlY3QgcnVucyBhZ2FpbiAoZHVlIHRvIG9uZSBvZiBpdHMgZGVwZW5kZW5jaWVzXG4gKiB1cGRhdGluZykgb3IgdGhlIGNvbXBvbmVudCBpdCByZXNpZGVzIGluIHVubW91bnRzLlxuICogTm90ZSB0aGUgZnVuY3Rpb25zIGRvbid0IG5lY2Nlc2FyaWx5IG5lZWQgdG8gYmUgaW4gYW4gYXJyYXkgYXMgYWxsIGFyZ3VtZW50c1xuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGZ1bmMgYXJndW1lbnQgYW5kIHNwcmVhZCBmcm9tIHRoZXJlLlxuICogVGhlIG9yZGVyIG9mIGNsZWFudXAgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGFyZ3VtZW50IG9yZGVyLiBHZW5lcmFsbHkgaXQgaXNcbiAqIGV4cGVjdGVkIHRoYXQgdGhlIGZpcnN0IFwiYWNxdWlyZVwiIHdpbGwgYmUgXCJyZWxlYXNlZFwiIGxhc3QgKExJRk8gb3JkZXIpLFxuICogYmVjYXVzZSBhIGxhdGVyIHN0ZXAgbWF5IGhhdmUgc29tZSBkZXBlbmRlbmN5IG9uIGFuIGVhcmxpZXIgb25lLlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhcnJheSBvZiBjbGVhbnVwIGZ1bmN0aW9ucyBtZWFudCB0byBiZSBleGVjdXRlZCBieSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB0aGUgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgYWxsIHRoZSBwYXNzZWQgY2xlYW51cCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVnaXN0ZXIoLi4uZnVuYykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBmdW5jLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBmdW5jW2ldKCk7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHRoZSByZWZlcmVuY2VzIGFuZCBtYWtlIGZ1dHVyZSBjYWxscyBhIG5vLW9wXG4gICAgZnVuYy5sZW5ndGggPSAwO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHB4KHZhbHVlKSB7XG4gIHJldHVybiBgJHt2YWx1ZX1weGA7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gcG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHJvb3RET01Ob2RlID0gbnVsbDtcbiAgbGV0IHBhcmVudERPTU5vZGUgPSBudWxsO1xuICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICBsZXQgbGFzdE5vZGVzID0gW107XG4gIGNvbnN0IHdyYXBwZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGlmICghKHJvb3RET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCByb290RE9NTm9kZWApO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnRET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCBwYXJlbnRET01Ob2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IHJvb3RMZWZ0LFxuICAgICAgdG9wOiByb290VG9wXG4gICAgfSA9IHJvb3RET01Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGVfID0gcGFyZW50RE9NTm9kZTtcbiAgICBjb25zdCByZWN0cyA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpO1xuICAgIGlmICghd3JhcHBlck5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHBhcmVudERPTU5vZGVfLmFwcGVuZCh3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHJvb3RMZWZ0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmxlZnQgIT09IGxlZnQpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcCA9IHB4KHJlY3QudG9wIC0gcm9vdFRvcCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS50b3AgIT09IHRvcCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IHB4KHJlY3Qud2lkdGgpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHQgPSBweChyZWN0LmhlaWdodCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdE5vZGUucGFyZW50Tm9kZSAhPT0gd3JhcHBlck5vZGUpIHtcbiAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kKHJlY3ROb2RlKTtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2Rlc1tpXSA9IHJlY3ROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdE5vZGVzLmxlbmd0aCA+IHJlY3RzLmxlbmd0aCkge1xuICAgICAgbGFzdE5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVwb3NpdGlvbmVkKSB7XG4gICAgICBvblJlcG9zaXRpb24obGFzdE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgICByb290RE9NTm9kZSA9IG51bGw7XG4gICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB3cmFwcGVyTm9kZS5yZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGFzdE5vZGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICBsYXN0Tm9kZXMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIGNvbnN0IGN1cnJlbnRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50Um9vdERPTU5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCEoY3VycmVudFBhcmVudERPTU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICBsZXQgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICBmdW5jdGlvbiBjb21wdXRlKGVkaXRvclN0YXRlKSB7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZUtleSA9IGN1cnJlbnRBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZUtleSA9IGN1cnJlbnRGb2N1c05vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEFuY2hvck5vZGVLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEZvY3VzTm9kZUtleSk7XG4gICAgICBjb25zdCBkaWZmZXJlbnRBbmNob3JET00gPSBwcmV2aW91c0FuY2hvck5vZGUgPT09IG51bGwgfHwgY3VycmVudEFuY2hvck5vZGVET00gPT09IG51bGwgfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKSB8fCBjdXJyZW50QW5jaG9yTm9kZSAhPT0gcHJldmlvdXNBbmNob3JOb2RlICYmICghKHByZXZpb3VzQW5jaG9yTm9kZSBpbnN0YW5jZW9mIFRleHROb2RlKSB8fCBjdXJyZW50QW5jaG9yTm9kZS51cGRhdGVET00ocHJldmlvdXNBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZWRpdG9yLl9jb25maWcpKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSA9PT0gbnVsbCB8fCBjdXJyZW50Rm9jdXNPZmZzZXQgIT09IHByZXZpb3VzRm9jdXNPZmZzZXQgfHwgY3VycmVudEZvY3VzTm9kZUtleSAhPT0gcHJldmlvdXNGb2N1c05vZGUuZ2V0S2V5KCkgfHwgY3VycmVudEZvY3VzTm9kZSAhPT0gcHJldmlvdXNGb2N1c05vZGUgJiYgKCEocHJldmlvdXNGb2N1c05vZGUgaW5zdGFuY2VvZiBUZXh0Tm9kZSkgfHwgY3VycmVudEZvY3VzTm9kZS51cGRhdGVET00ocHJldmlvdXNGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00sIGVkaXRvci5fY29uZmlnKSk7XG4gICAgICBpZiAoZGlmZmVyZW50QW5jaG9yRE9NIHx8IGRpZmZlcmVudEZvY3VzRE9NKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvckhUTUxFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3IuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgY29uc3QgZm9jdXNIVE1MRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXMuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZWN0aW9uIGJleW9uZCB0aGUgY29tbW9uIFRleHROb2RlXG4gICAgICAgIGlmIChhbmNob3JIVE1MRWxlbWVudCAhPT0gbnVsbCAmJiBmb2N1c0hUTUxFbGVtZW50ICE9PSBudWxsICYmIGFuY2hvckhUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJyAmJiBmb2N1c0hUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJykge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBsZXQgZmlyc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgZmlyc3RPZmZzZXQ7XG4gICAgICAgICAgbGV0IGxhc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgbGFzdE9mZnNldDtcbiAgICAgICAgICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgICAgICAgICAgZmlyc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBmaXJzdE9mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGFuY2hvckhUTUxFbGVtZW50O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0SFRNTEVsZW1lbnQgPSBhbmNob3JIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdFRleHROb2RlID0gZmlyc3RIVE1MRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGlmICghKGZpcnN0VGV4dE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCBub2RlIHRvIGJlIGZpcnN0IGNoaWxkIG9mIHNwYW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGFzdFRleHROb2RlID0gbGFzdEhUTUxFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKCEobGFzdFRleHROb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQgbm9kZSB0byBiZSBmaXJzdCBjaGlsZCBvZiBzcGFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZpcnN0VGV4dE5vZGUsIGZpcnN0T2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobGFzdFRleHROb2RlLCBsYXN0T2Zmc2V0KTtcbiAgICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9IHBvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgZG9tTm9kZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkb21Ob2RlIG9mIGRvbU5vZGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGVTdHlsZSA9IGRvbU5vZGUuc3R5bGU7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCAhPT0gJ0hpZ2hsaWdodCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCA9ICdIaWdobGlnaHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuY29sb3IgIT09ICdIaWdobGlnaHRUZXh0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5jb2xvciA9ICdIaWdobGlnaHRUZXh0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnpJbmRleCAhPT0gJy0xJykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS56SW5kZXggPSAnLTEnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucG9pbnRlckV2ZW50cyAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZXBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb25SZXBvc2l0aW9uKGRvbU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gY3VycmVudEFuY2hvck5vZGU7XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgcmVtb3ZlUmFuZ2VMaXN0ZW5lciwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCBhZGRzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byBhZGQgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgWydlbGVtZW50LWlubmVyIGFjdGl2ZScsIHRydWUsIG51bGxdKVxuICogd2lsbCBhZGQgYm90aCAnZWxlbWVudC1pbm5lcicgYW5kICdhY3RpdmUnIGFzIGNsYXNzZXMgdG8gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgYWRkZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHJlbW92ZXMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIFsnYWN0aXZlIHNtYWxsJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIHJlbW92ZSBib3RoIHRoZSAnYWN0aXZlJyBhbmQgJ3NtYWxsJyBjbGFzc2VzIGZyb20gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgcmVtb3ZlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgZm9yIChjb25zdCBhY2NlcHRhYmxlVHlwZSBvZiBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKGFjY2VwdGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMZXhpY2FsIEZpbGUgUmVhZGVyIHdpdGg6XG4gKiAgMS4gTUlNRSB0eXBlIHN1cHBvcnRcbiAqICAyLiBiYXRjaGVkIHJlc3VsdHMgKEhpc3RvcnlQbHVnaW4gY29tcGF0aWJpbGl0eSlcbiAqICAzLiBPcmRlciBhd2FyZSAocmVzcGVjdHMgdGhlIG9yZGVyIHdoZW4gbXVsdGlwbGUgRmlsZXMgYXJlIHBhc3NlZClcbiAqXG4gKiBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihmaWxlcywgWydpbWFnZS8nXSk7XG4gKiBmaWxlc1Jlc3VsdC5mb3JFYWNoKGZpbGUgPT4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZCgnSU5TRVJUX0lNQUdFJywgXFxcXHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIFxcXFx9KSk7XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRmlsZVJlYWRlcihmaWxlcywgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBjb25zdCBmaWxlc0l0ZXJhdG9yID0gZmlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBcIkRlcHRoLUZpcnN0IFNlYXJjaFwiIHN0YXJ0cyBhdCB0aGUgcm9vdC90b3Agbm9kZSBvZiBhIHRyZWUgYW5kIGdvZXMgYXMgZmFyIGFzIGl0IGNhbiBkb3duIGEgYnJhbmNoIGVuZFxuICogYmVmb3JlIGJhY2t0cmFja2luZyBhbmQgZmluZGluZyBhIG5ldyBwYXRoLiBDb25zaWRlciBzb2x2aW5nIGEgbWF6ZSBieSBodWdnaW5nIGVpdGhlciB3YWxsLCBtb3ZpbmcgZG93biBhXG4gKiBicmFuY2ggdW50aWwgeW91IGhpdCBhIGRlYWQtZW5kIChsZWFmKSBhbmQgYmFja3RyYWNraW5nIHRvIGZpbmQgdGhlIG5lYXJlc3QgYnJhbmNoaW5nIHBhdGggYW5kIHJlcGVhdC5cbiAqIEl0IHdpbGwgdGhlbiByZXR1cm4gYWxsIHRoZSBub2RlcyBmb3VuZCBpbiB0aGUgc2VhcmNoIGluIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICogXFxcXHtkZXB0aDogbnVtYmVyLCBub2RlOiBMZXhpY2FsTm9kZVxcXFx9IEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJGRmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJGRmc0l0ZXJhdG9yKHN0YXJ0Tm9kZSwgZW5kTm9kZSkpO1xufVxuY29uc3QgaXRlcmF0b3JEb25lID0ge1xuICBkb25lOiB0cnVlLFxuICB2YWx1ZTogdW5kZWZpbmVkXG59O1xuY29uc3QgaXRlcmF0b3JOb3REb25lID0gdmFsdWUgPT4gKHtcbiAgZG9uZTogZmFsc2UsXG4gIHZhbHVlXG59KTtcblxuLyoqXG4gKiAkZGZzIGl0ZXJhdG9yLiBUcmVlIHRyYXZlcnNhbCBpcyBkb25lIG9uIHRoZSBmbHkgYXMgbmV3IHZhbHVlcyBhcmUgcmVxdWVzdGVkIHdpdGggTygxKSBtZW1vcnkuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gaXRlcmF0b3IsIGVhY2ggeWllbGRlZCB2YWx1ZSBpcyBhIERGU05vZGUuIEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJGRmc0l0ZXJhdG9yKHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCBzdGFydCA9IChzdGFydE5vZGUgfHwgJGdldFJvb3QoKSkuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IHN0YXJ0RGVwdGggPSAkZ2V0RGVwdGgoc3RhcnQpO1xuICBjb25zdCBlbmQgPSBlbmROb2RlO1xuICBsZXQgbm9kZSA9IHN0YXJ0O1xuICBsZXQgZGVwdGggPSBzdGFydERlcHRoO1xuICBsZXQgaXNGaXJzdE5leHQgPSB0cnVlO1xuICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICBuZXh0KCkge1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpcnN0TmV4dCkge1xuICAgICAgICBpc0ZpcnN0TmV4dCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JOb3REb25lKHtcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZXB0aERpZmY7XG4gICAgICAgIFtub2RlLCBkZXB0aERpZmZdID0gJGdldE5leHRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nKG5vZGUpIHx8IFtudWxsLCAwXTtcbiAgICAgICAgZGVwdGggKz0gZGVwdGhEaWZmO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgJiYgZGVwdGggPD0gc3RhcnREZXB0aCkge1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yTm90RG9uZSh7XG4gICAgICAgIGRlcHRoLFxuICAgICAgICBub2RlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vZGUgc2libGluZyB3aGVuIHRoaXMgZXhpc3RzLCBvdGhlcndpc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHNpYmxpbmcuIEZvciBleGFtcGxlXG4gKiBSIC0+IFAgLT4gVDEsIFQyXG4gKiAgIC0+IFAyXG4gKiByZXR1cm5zIFQyIGZvciBub2RlIFQxLCBQMiBmb3Igbm9kZSBUMiwgYW5kIG51bGwgZm9yIG5vZGUgUDIuXG4gKiBAcGFyYW0gbm9kZSBMZXhpY2FsTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5ICh0dXBsZSkgY29udGFpbmluZyB0aGUgZm91bmQgTGV4aWNhbCBub2RlIGFuZCB0aGUgZGVwdGggZGlmZmVyZW5jZSwgb3IgbnVsbCwgaWYgdGhpcyBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB7XG4gIGxldCBub2RlXyA9IG5vZGU7XG4gIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICBsZXQgc2libGluZyA9IG51bGw7XG4gIGxldCBkZXB0aERpZmYgPSAwO1xuICB3aGlsZSAoc2libGluZyA9PT0gbnVsbCAmJiBub2RlXyAhPT0gbnVsbCkge1xuICAgIHNpYmxpbmcgPSBub2RlXy5nZXROZXh0U2libGluZygpO1xuICAgIGlmIChzaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBub2RlXyA9IG5vZGVfLmdldFBhcmVudCgpO1xuICAgICAgZGVwdGhEaWZmLS07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVfID0gc2libGluZztcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGVfID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFtub2RlXywgZGVwdGhEaWZmXTtcbn1cbmZ1bmN0aW9uICRnZXREZXB0aChub2RlKSB7XG4gIGxldCBpbm5lck5vZGUgPSBub2RlO1xuICBsZXQgZGVwdGggPSAwO1xuICB3aGlsZSAoKGlubmVyTm9kZSA9IGlubmVyTm9kZS5nZXRQYXJlbnQoKSkgIT09IG51bGwpIHtcbiAgICBkZXB0aCsrO1xuICB9XG4gIHJldHVybiBkZXB0aDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHJpZ2h0LXRvLWxlZnQgcHJlb3JkZXIgdHJlZSB0cmF2ZXJzYWwuXG4gKiBGcm9tIHRoZSBzdGFydGluZyBub2RlIGl0IGdvZXMgdG8gdGhlIHJpZ2h0bW9zdCBjaGlsZCwgdGhhbiBiYWNrdHJhY2tzIHRvIHBhcmV0IGFuZCBmaW5kcyBuZXcgcmlnaHRtb3N0IHBhdGguXG4gKiBJdCB3aWxsIHJldHVybiB0aGUgbmV4dCBub2RlIGluIHRyYXZlcnNhbCBzZXF1ZW5jZSBhZnRlciB0aGUgc3RhcnRpbmdOb2RlLlxuICogVGhlIHRyYXZlcnNhbCBpcyBzaW1pbGFyIHRvICRkZnMgZnVuY3Rpb25zIGFib3ZlLCBidXQgdGhlIG5vZGVzIGFyZSB2aXNpdGVkIHJpZ2h0LXRvLWxlZnQsIG5vdCBsZWZ0LXRvLXJpZ2h0LlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2RlIGluIHByZS1vcmRlciByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBzZXF1ZW5jZSBvciBgbnVsbGAsIGlmIHRoZSBub2RlIGRvZXMgbm90IGV4aXN0XG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGxldCBub2RlID0gc3RhcnRpbmdOb2RlO1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICBub2RlID0gbm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc2libGluZyA9IG51bGw7XG4gICAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIG5vZGUgYW5kIHRyYXZlcnNlcyB1cCBpdHMgYW5jZXN0b3JzICh0b3dhcmQgdGhlIHJvb3Qgbm9kZSlcbiAqIGluIG9yZGVyIHRvIGZpbmQgYSBzcGVjaWZpYyB0eXBlIG9mIG5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIHRoZSBub2RlIHRvIGJlZ2luIHNlYXJjaGluZy5cbiAqIEBwYXJhbSBrbGFzcyAtIGFuIGluc3RhbmNlIG9mIHRoZSB0eXBlIG9mIG5vZGUgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJucyB0aGUgbm9kZSBvZiB0eXBlIGtsYXNzIHRoYXQgd2FzIHBhc3NlZCwgb3IgbnVsbCBpZiBub25lIGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwga2xhc3MpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBrbGFzcykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgbm9kZSBvZiB0aGUgbmVhcmVzdCBhbmNlc3Rvciwgb3RoZXJ3aXNlIHRocm93cyBhbiBlcnJvci5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgc3RhcnRpbmcgbm9kZSBvZiB0aGUgc2VhcmNoXG4gKiBAcmV0dXJucyBUaGUgYW5jZXN0b3Igbm9kZSBmb3VuZFxuICovXG5mdW5jdGlvbiAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhzdGFydE5vZGUpIHtcbiAgY29uc3QgYmxvY2tOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydE5vZGUsIG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSk7XG4gIGlmICghJGlzRWxlbWVudE5vZGUoYmxvY2tOb2RlKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7c3RhcnROb2RlLl9fa2V5fSB0byBoYXZlIGNsb3Nlc3QgYmxvY2sgZWxlbWVudCBub2RlLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2tOb2RlO1xufVxuLyoqXG4gKiBTdGFydHMgd2l0aCBhIG5vZGUgYW5kIG1vdmVzIHVwIHRoZSB0cmVlICh0b3dhcmQgdGhlIHJvb3Qgbm9kZSkgdG8gZmluZCBhIG1hdGNoaW5nIG5vZGUgYmFzZWQgb25cbiAqIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgZmluZEZuLiAoQ29uc2lkZXIgSmF2YVNjcmlwdHMnIC5maW5kKCkgZnVuY3Rpb24gd2hlcmUgYSB0ZXN0aW5nIGZ1bmN0aW9uIG11c3QgYmVcbiAqIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gZWcuIGlmKCAobm9kZSkgPT4gbm9kZS5fX3R5cGUgPT09ICdkaXYnKSApIHJldHVybiB0cnVlOyBvdGhlcndpc2UgcmV0dXJuIGZhbHNlXG4gKiBAcGFyYW0gc3RhcnRpbmdOb2RlIC0gVGhlIG5vZGUgd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuXG4gKiBAcGFyYW0gZmluZEZuIC0gQSB0ZXN0aW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSB0ZXN0aW5nIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyBBIHBhcmVudCBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZmluZEZuIHBhcmFtZXRlcnMsIG9yIG51bGwgaWYgb25lIHdhc24ndCBmb3VuZC5cbiAqL1xuY29uc3QgJGZpbmRNYXRjaGluZ1BhcmVudCA9IChzdGFydGluZ05vZGUsIGZpbmRGbikgPT4ge1xuICBsZXQgY3VyciA9IHN0YXJ0aW5nTm9kZTtcbiAgd2hpbGUgKGN1cnIgIT09ICRnZXRSb290KCkgJiYgY3VyciAhPSBudWxsKSB7XG4gICAgaWYgKGZpbmRGbihjdXJyKSkge1xuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuICAgIGN1cnIgPSBjdXJyLmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIG5lc3RlZCBlbGVtZW50IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgaW50byBhIHNpbmdsZSBub2RlIG9mIHRoYXQgdHlwZS5cbiAqIEl0IGlzIGdlbmVyYWxseSB1c2VkIGZvciBtYXJrcy9jb21tZW50aW5nXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSB0YXJnZXQgZm9yIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBiZSBleHRyYWN0ZWQgZnJvbS5cbiAqIEBwYXJhbSBjbG9uZU5vZGUgLSBTZWUge0BsaW5rICRjcmVhdGVNYXJrTm9kZX1cbiAqIEBwYXJhbSBoYW5kbGVPdmVybGFwIC0gSGFuZGxlcyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIHRoZSBub2RlIHRvIGV4dHJhY3QgYW5kIHRoZSB0YXJnZXROb2RlXG4gKiBAcmV0dXJucyBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXIoZWRpdG9yLCB0YXJnZXROb2RlLCBjbG9uZU5vZGUsIGhhbmRsZU92ZXJsYXApIHtcbiAgY29uc3QgJGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcbiAgY29uc3QgJGZpbmRNYXRjaCA9IG5vZGUgPT4ge1xuICAgIC8vIEZpcnN0IHZhbGlkYXRlIHdlIGRvbid0IGhhdmUgYW55IGNoaWxkcmVuIHRoYXQgYXJlIG9mIHRoZSB0YXJnZXQsXG4gICAgLy8gYXMgd2UgbmVlZCB0byBoYW5kbGUgdGhlbSBmaXJzdC5cbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IGNoaWxkTm9kZSA9IG5vZGU7XG4gICAgd2hpbGUgKHBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0ICRlbGVtZW50Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gJGZpbmRNYXRjaChub2RlKTtcbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IG1hdGNoO1xuXG4gICAgICAvLyBTaW1wbGUgcGF0aCwgd2UgY2FuIG1vdmUgY2hpbGQgb3V0IGFuZCBzaWJsaW5ncyBpbnRvIGEgbmV3IHBhcmVudC5cblxuICAgICAgaWYgKGNoaWxkLmlzKG5vZGUpKSB7XG4gICAgICAgIGhhbmRsZU92ZXJsYXAocGFyZW50LCBub2RlKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xlbmd0aCA9IG5leHRTaWJsaW5ncy5sZW5ndGg7XG4gICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihjaGlsZCk7XG4gICAgICAgIGlmIChuZXh0U2libGluZ3NMZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSBjbG9uZU5vZGUocGFyZW50KTtcbiAgICAgICAgICBjaGlsZC5pbnNlcnRBZnRlcihuZXdQYXJlbnQpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFNpYmxpbmdzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1BhcmVudC5hcHBlbmQobmV4dFNpYmxpbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQuY2FuQmVFbXB0eSgpICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgJGVsZW1lbnROb2RlVHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBDbG9uZXMgdGhlIGVkaXRvciBhbmQgbWFya3MgaXQgYXMgZGlydHkgdG8gYmUgcmVjb25jaWxlZC4gSWYgdGhlcmUgd2FzIGEgc2VsZWN0aW9uLFxuICogaXQgd291bGQgYmUgc2V0IGJhY2sgdG8gaXRzIHByZXZpb3VzIHN0YXRlLCBvciBudWxsIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSBlZGl0b3JTdGF0ZSAtIFRoZSBlZGl0b3IncyBzdGF0ZVxuICovXG5mdW5jdGlvbiAkcmVzdG9yZUVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyO1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIGVkaXRvclN0YXRlLl9ub2RlTWFwKSB7XG4gICAgbm9kZU1hcC5zZXQoa2V5LCAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSk7XG4gIH1cbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlKSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUuX25vZGVNYXAgPSBub2RlTWFwO1xuICB9XG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbi5jbG9uZSgpKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggbm9kZSB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG4gICAgICBpZiAoZm9jdXNDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIGZvY3VzTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0NoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgc3BsaXROb2RlID0gZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHNwbGl0T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9jdXNOb2RlLnNwbGl0VGV4dChmb2N1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSAkc3BsaXROb2RlKHNwbGl0Tm9kZSwgc3BsaXRPZmZzZXQpO1xuICAgICAgcmlnaHRUcmVlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIHJpZ2h0VHJlZS5zZWxlY3RTdGFydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gICAgcGFyYWdyYXBoTm9kZS5zZWxlY3QoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgbm9kZSBpbnRvIGFub3RoZXIgbm9kZSBjcmVhdGVkIGZyb20gYSBjcmVhdGVFbGVtZW50Tm9kZSBmdW5jdGlvbiwgZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50Tm9kZSAtIENyZWF0ZXMgYSBuZXcgbGV4aWNhbCBlbGVtZW50IHRvIHdyYXAgdGhlIHRvLWJlLXdyYXBwZWQgbm9kZSBhbmQgcmV0dXJucyBpdC5cbiAqIEByZXR1cm5zIEEgbmV3IGxleGljYWwgZWxlbWVudCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFwcGVuZGVkIHdpdGhpbiAoYXMgYSBjaGlsZCwgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbikuXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEBwYXJhbSBvYmplY3QgPSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSBvYmplY3RDbGFzcyA9IFRoZSBjbGFzcyBvZiB0aGUgdHlwZVxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGhhcyB0aGUgc2FtZSBLbGFzcyBvZiB0aGUgb2JqZWN0Q2xhc3MsIGlnbm9yaW5nIHRoZSBkaWZmZXJlbmNlIGFjcm9zcyB3aW5kb3cgKGUuZy4gZGlmZmVyZW50IGlmcmFtcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUgbm9kZXNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0aGF0IG5lZWRzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0gZmlsdGVyRm4gQSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBvdGhlcndpc2UgbnVsbFxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgbm9kZXNcbiAqL1xuXG5mdW5jdGlvbiAkZmlsdGVyKG5vZGVzLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBmaWx0ZXJGbihub2Rlc1tpXSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBcHBlbmRzIHRoZSBub2RlIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gcGFyZW50IEEgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBub2RlIE5vZGUgdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlWm9vbUxldmVsKGVsZW1lbnQpIHtcbiAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgem9vbSA9IDE7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgem9vbSAqPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnem9vbScpKTtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiB6b29tO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZWRpdG9yIGlzIGEgbmVzdGVkIGVkaXRvciBjcmVhdGVkIGJ5IExleGljYWxOZXN0ZWRDb21wb3NlclxuICovXG5mdW5jdGlvbiAkaXNFZGl0b3JJc05lc3RlZEVkaXRvcihlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsO1xufVxuXG5leHBvcnQgeyAkZGZzLCAkZGZzSXRlcmF0b3IsICRmaWx0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsICRnZXREZXB0aCwgJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3csICRnZXROZWFyZXN0Tm9kZU9mVHlwZSwgJGdldE5leHRSaWdodFByZW9yZGVyTm9kZSwgJGdldE5leHRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IsICRyZXN0b3JlRWRpdG9yU3RhdGUsICR3cmFwTm9kZUluRWxlbWVudCwgQ0FOX1VTRV9CRUZPUkVfSU5QVVQsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBJU19BTkRST0lEX0NIUk9NRSwgSVNfQVBQTEUsIElTX0FQUExFX1dFQktJVCwgSVNfQ0hST01FLCBJU19GSVJFRk9YLCBJU19JT1MsIElTX1NBRkFSSSwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgY2FsY3VsYXRlWm9vbUxldmVsLCBpc01pbWVUeXBlLCBtYXJrU2VsZWN0aW9uLCBtZWRpYUZpbGVSZWFkZXIsIG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzLCBwb3NpdGlvbk5vZGVPblJhbmdlLCByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;