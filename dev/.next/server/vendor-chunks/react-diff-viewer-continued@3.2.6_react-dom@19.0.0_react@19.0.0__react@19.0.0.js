"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0";
exports.ids = ["vendor-chunks/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/compute-lines.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/compute-lines.js ***!
  \*************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __webpack_require__(/*! diff */ \"(ssr)/../node_modules/.pnpm/diff@5.2.0/node_modules/diff/lib/index.js\");\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n    DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n    DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType = exports.DiffType || (exports.DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n    DiffMethod[\"CHARS\"] = \"diffChars\";\n    DiffMethod[\"WORDS\"] = \"diffWords\";\n    DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n    DiffMethod[\"LINES\"] = \"diffLines\";\n    DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n    DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n    DiffMethod[\"CSS\"] = \"diffCss\";\n    DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod = exports.DiffMethod || (exports.DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = (value) => {\n    if (value === '')\n        return [];\n    const lines = value.replace(/\\n$/, '').split('\\n');\n    return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n    const diffArray = jsDiff[compareMethod](oldValue, newValue);\n    const computedDiff = {\n        left: [],\n        right: [],\n    };\n    diffArray.forEach(({ added, removed, value }) => {\n        const diffInformation = {};\n        if (added) {\n            diffInformation.type = DiffType.ADDED;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n        }\n        if (removed) {\n            diffInformation.type = DiffType.REMOVED;\n            diffInformation.value = value;\n            computedDiff.left.push(diffInformation);\n        }\n        if (!removed && !added) {\n            diffInformation.type = DiffType.DEFAULT;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n            computedDiff.left.push(diffInformation);\n        }\n        return diffInformation;\n    });\n    return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0) => {\n    let diffArray = [];\n    // Use diffLines for strings, and diffJson for objects...\n    if (typeof oldString === 'string' && typeof newString === 'string') {\n        diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n            newlineIsToken: false,\n            ignoreWhitespace: false,\n            ignoreCase: false,\n        });\n    }\n    else {\n        diffArray = diff.diffJson(oldString, newString);\n    }\n    let rightLineNumber = linesOffset;\n    let leftLineNumber = linesOffset;\n    let lineInformation = [];\n    let counter = 0;\n    const diffLines = [];\n    const ignoreDiffIndexes = [];\n    const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n        const lines = constructLines(value);\n        return lines\n            .map((line, lineIndex) => {\n            const left = {};\n            const right = {};\n            if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) ||\n                (evaluateOnlyFirstLine && lineIndex !== 0)) {\n                return undefined;\n            }\n            if (added || removed) {\n                let countAsChange = true;\n                if (removed) {\n                    leftLineNumber += 1;\n                    left.lineNumber = leftLineNumber;\n                    left.type = DiffType.REMOVED;\n                    left.value = line || ' ';\n                    // When the current line is of type REMOVED, check the next item in\n                    // the diff array whether it is of type ADDED. If true, the current\n                    // diff will be marked as both REMOVED and ADDED. Meaning, the\n                    // current line is a modification.\n                    const nextDiff = diffArray[diffIndex + 1];\n                    if (nextDiff && nextDiff.added) {\n                        const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n                        if (nextDiffLines) {\n                            const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n                            const { value: rightValue, lineNumber, type, } = nextDiffLineInfo[0].right;\n                            // When identified as modification, push the next diff to ignore\n                            // list as the next value will be added in this line computation as\n                            // right and left values.\n                            ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n                            right.lineNumber = lineNumber;\n                            if (left.value === rightValue) {\n                                // The new value is exactly the same as the old\n                                countAsChange = false;\n                                right.type = 0;\n                                left.type = 0;\n                                right.value = rightValue;\n                            }\n                            else {\n                                right.type = type;\n                                // Do char level diff and assign the corresponding values to the\n                                // left and right diff information object.\n                                if (disableWordDiff) {\n                                    right.value = rightValue;\n                                }\n                                else {\n                                    const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                                    right.value = computedDiff.right;\n                                    left.value = computedDiff.left;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    rightLineNumber += 1;\n                    right.lineNumber = rightLineNumber;\n                    right.type = DiffType.ADDED;\n                    right.value = line;\n                }\n                if (countAsChange && !evaluateOnlyFirstLine) {\n                    if (!diffLines.includes(counter)) {\n                        diffLines.push(counter);\n                    }\n                }\n            }\n            else {\n                leftLineNumber += 1;\n                rightLineNumber += 1;\n                left.lineNumber = leftLineNumber;\n                left.type = DiffType.DEFAULT;\n                left.value = line;\n                right.lineNumber = rightLineNumber;\n                right.type = DiffType.DEFAULT;\n                right.value = line;\n            }\n            if (!evaluateOnlyFirstLine) {\n                counter += 1;\n            }\n            return { right, left };\n        })\n            .filter(Boolean);\n    };\n    diffArray.forEach(({ added, removed, value }, index) => {\n        lineInformation = [\n            ...lineInformation,\n            ...getLineInformation(value, index, added, removed),\n        ];\n    });\n    return {\n        lineInformation,\n        diffLines,\n    };\n};\nexports.computeLineInformation = computeLineInformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2NvbXB1dGUtbGluZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3RFLGFBQWEsbUJBQU8sQ0FBQyxtRkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsR0FBRyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVDQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxHQUFHLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIi9ob21lL3BhdWwvcHJvamVjdHMvcGF5bG9hZC9wbHVnaW4tZGV2ZWxvcG1lbnQvYmV0dGVyLWZpZWxkcy9naXRyb290L25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWRAMy4yLjZfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9jb21wdXRlLWxpbmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlTGluZUluZm9ybWF0aW9uID0gZXhwb3J0cy5EaWZmTWV0aG9kID0gZXhwb3J0cy5EaWZmVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGRpZmYgPSByZXF1aXJlKFwiZGlmZlwiKTtcbmNvbnN0IGpzRGlmZiA9IGRpZmY7XG52YXIgRGlmZlR5cGU7XG4oZnVuY3Rpb24gKERpZmZUeXBlKSB7XG4gICAgRGlmZlR5cGVbRGlmZlR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIkFEREVEXCJdID0gMV0gPSBcIkFEREVEXCI7XG4gICAgRGlmZlR5cGVbRGlmZlR5cGVbXCJSRU1PVkVEXCJdID0gMl0gPSBcIlJFTU9WRURcIjtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIkNIQU5HRURcIl0gPSAzXSA9IFwiQ0hBTkdFRFwiO1xufSkoRGlmZlR5cGUgPSBleHBvcnRzLkRpZmZUeXBlIHx8IChleHBvcnRzLkRpZmZUeXBlID0ge30pKTtcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL3RyZWUvdjQuMC4xI2FwaSBmb3IgbW9yZSBpbmZvIG9uIHRoZSBiZWxvdyBKc0RpZmYgbWV0aG9kc1xudmFyIERpZmZNZXRob2Q7XG4oZnVuY3Rpb24gKERpZmZNZXRob2QpIHtcbiAgICBEaWZmTWV0aG9kW1wiQ0hBUlNcIl0gPSBcImRpZmZDaGFyc1wiO1xuICAgIERpZmZNZXRob2RbXCJXT1JEU1wiXSA9IFwiZGlmZldvcmRzXCI7XG4gICAgRGlmZk1ldGhvZFtcIldPUkRTX1dJVEhfU1BBQ0VcIl0gPSBcImRpZmZXb3Jkc1dpdGhTcGFjZVwiO1xuICAgIERpZmZNZXRob2RbXCJMSU5FU1wiXSA9IFwiZGlmZkxpbmVzXCI7XG4gICAgRGlmZk1ldGhvZFtcIlRSSU1NRURfTElORVNcIl0gPSBcImRpZmZUcmltbWVkTGluZXNcIjtcbiAgICBEaWZmTWV0aG9kW1wiU0VOVEVOQ0VTXCJdID0gXCJkaWZmU2VudGVuY2VzXCI7XG4gICAgRGlmZk1ldGhvZFtcIkNTU1wiXSA9IFwiZGlmZkNzc1wiO1xuICAgIERpZmZNZXRob2RbXCJKU09OXCJdID0gXCJkaWZmSnNvblwiO1xufSkoRGlmZk1ldGhvZCA9IGV4cG9ydHMuRGlmZk1ldGhvZCB8fCAoZXhwb3J0cy5EaWZmTWV0aG9kID0ge30pKTtcbi8qKlxuICogU3BsaXRzIGRpZmYgdGV4dCBieSBuZXcgbGluZSBhbmQgY29tcHV0ZXMgZmluYWwgbGlzdCBvZiBkaWZmIGxpbmVzIGJhc2VkIG9uXG4gKiBjb25kaXRpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBEaWZmIHRleHQgZnJvbSB0aGUganMgZGlmZiBtb2R1bGUuXG4gKi9cbmNvbnN0IGNvbnN0cnVjdExpbmVzID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSAnJylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGxpbmVzID0gdmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzO1xufTtcbi8qKlxuICogQ29tcHV0ZXMgd29yZCBkaWZmIGluZm9ybWF0aW9uIGluIHRoZSBsaW5lLlxuICogW1RPRE9dOiBDb25zaWRlciBhZGRpbmcgb3B0aW9ucyBhcmd1bWVudCBmb3IgSnNEaWZmIHRleHQgYmxvY2sgY29tcGFyaXNvblxuICpcbiAqIEBwYXJhbSBvbGRWYWx1ZSBPbGQgd29yZCBpbiB0aGUgbGluZS5cbiAqIEBwYXJhbSBuZXdWYWx1ZSBOZXcgd29yZCBpbiB0aGUgbGluZS5cbiAqIEBwYXJhbSBjb21wYXJlTWV0aG9kIEpzRGlmZiB0ZXh0IGRpZmYgbWV0aG9kIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi90cmVlL3Y0LjAuMSNhcGlcbiAqL1xuY29uc3QgY29tcHV0ZURpZmYgPSAob2xkVmFsdWUsIG5ld1ZhbHVlLCBjb21wYXJlTWV0aG9kID0gRGlmZk1ldGhvZC5DSEFSUykgPT4ge1xuICAgIGNvbnN0IGRpZmZBcnJheSA9IGpzRGlmZltjb21wYXJlTWV0aG9kXShvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIGNvbnN0IGNvbXB1dGVkRGlmZiA9IHtcbiAgICAgICAgbGVmdDogW10sXG4gICAgICAgIHJpZ2h0OiBbXSxcbiAgICB9O1xuICAgIGRpZmZBcnJheS5mb3JFYWNoKCh7IGFkZGVkLCByZW1vdmVkLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZmZJbmZvcm1hdGlvbiA9IHt9O1xuICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuQURERUQ7XG4gICAgICAgICAgICBkaWZmSW5mb3JtYXRpb24udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbXB1dGVkRGlmZi5yaWdodC5wdXNoKGRpZmZJbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuUkVNT1ZFRDtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLmxlZnQucHVzaChkaWZmSW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVtb3ZlZCAmJiAhYWRkZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuREVGQVVMVDtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLnJpZ2h0LnB1c2goZGlmZkluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVkRGlmZi5sZWZ0LnB1c2goZGlmZkluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZkluZm9ybWF0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiBjb21wdXRlZERpZmY7XG59O1xuLyoqXG4gKiBbVE9ET106IFRoaW5rIGFib3V0IG1vdmluZyBjb21tb24gbGVmdCBhbmQgcmlnaHQgdmFsdWUgYXNzaWdubWVudCB0byBhXG4gKiBjb21tb24gcGxhY2UuIEJldHRlciByZWFkYWJpbGl0eT9cbiAqXG4gKiBDb21wdXRlcyBsaW5lIHdpc2UgaW5mb3JtYXRpb24gYmFzZWQgaW4gdGhlIGpzIGRpZmYgaW5mb3JtYXRpb24gcGFzc2VkLiBFYWNoXG4gKiBsaW5lIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGxlZnQgYW5kIHJpZ2h0IHNlY3Rpb24uIExlZnQgc2lkZSBkZW5vdGVzXG4gKiBkZWxldGlvbiBhbmQgcmlnaHQgc2lkZSBkZW5vdGVzIGFkZGl0aW9uLlxuICpcbiAqIEBwYXJhbSBvbGRTdHJpbmcgT2xkIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIG5ld1N0cmluZyBOZXcgc3RyaW5nIHRvIGNvbXBhcmUgd2l0aCBvbGQgc3RyaW5nLlxuICogQHBhcmFtIGRpc2FibGVXb3JkRGlmZiBGbGFnIHRvIGVuYWJsZS9kaXNhYmxlIHdvcmQgZGlmZi5cbiAqIEBwYXJhbSBsaW5lQ29tcGFyZU1ldGhvZCBKc0RpZmYgdGV4dCBkaWZmIG1ldGhvZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvdHJlZS92NC4wLjEjYXBpXG4gKiBAcGFyYW0gbGluZXNPZmZzZXQgbGluZSBudW1iZXIgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICovXG5jb25zdCBjb21wdXRlTGluZUluZm9ybWF0aW9uID0gKG9sZFN0cmluZywgbmV3U3RyaW5nLCBkaXNhYmxlV29yZERpZmYgPSBmYWxzZSwgbGluZUNvbXBhcmVNZXRob2QgPSBEaWZmTWV0aG9kLkNIQVJTLCBsaW5lc09mZnNldCA9IDApID0+IHtcbiAgICBsZXQgZGlmZkFycmF5ID0gW107XG4gICAgLy8gVXNlIGRpZmZMaW5lcyBmb3Igc3RyaW5ncywgYW5kIGRpZmZKc29uIGZvciBvYmplY3RzLi4uXG4gICAgaWYgKHR5cGVvZiBvbGRTdHJpbmcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBuZXdTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpZmZBcnJheSA9IGRpZmYuZGlmZkxpbmVzKG9sZFN0cmluZy50cmltUmlnaHQoKSwgbmV3U3RyaW5nLnRyaW1SaWdodCgpLCB7XG4gICAgICAgICAgICBuZXdsaW5lSXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpZmZBcnJheSA9IGRpZmYuZGlmZkpzb24ob2xkU3RyaW5nLCBuZXdTdHJpbmcpO1xuICAgIH1cbiAgICBsZXQgcmlnaHRMaW5lTnVtYmVyID0gbGluZXNPZmZzZXQ7XG4gICAgbGV0IGxlZnRMaW5lTnVtYmVyID0gbGluZXNPZmZzZXQ7XG4gICAgbGV0IGxpbmVJbmZvcm1hdGlvbiA9IFtdO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBjb25zdCBkaWZmTGluZXMgPSBbXTtcbiAgICBjb25zdCBpZ25vcmVEaWZmSW5kZXhlcyA9IFtdO1xuICAgIGNvbnN0IGdldExpbmVJbmZvcm1hdGlvbiA9ICh2YWx1ZSwgZGlmZkluZGV4LCBhZGRlZCwgcmVtb3ZlZCwgZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gY29uc3RydWN0TGluZXModmFsdWUpO1xuICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgIC5tYXAoKGxpbmUsIGxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVEaWZmSW5kZXhlcy5pbmNsdWRlcyhgJHtkaWZmSW5kZXh9LSR7bGluZUluZGV4fWApIHx8XG4gICAgICAgICAgICAgICAgKGV2YWx1YXRlT25seUZpcnN0TGluZSAmJiBsaW5lSW5kZXggIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRlZCB8fCByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50QXNDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQubGluZU51bWJlciA9IGxlZnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LnR5cGUgPSBEaWZmVHlwZS5SRU1PVkVEO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LnZhbHVlID0gbGluZSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGN1cnJlbnQgbGluZSBpcyBvZiB0eXBlIFJFTU9WRUQsIGNoZWNrIHRoZSBuZXh0IGl0ZW0gaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRpZmYgYXJyYXkgd2hldGhlciBpdCBpcyBvZiB0eXBlIEFEREVELiBJZiB0cnVlLCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmIHdpbGwgYmUgbWFya2VkIGFzIGJvdGggUkVNT1ZFRCBhbmQgQURERUQuIE1lYW5pbmcsIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYSBtb2RpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREaWZmID0gZGlmZkFycmF5W2RpZmZJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dERpZmYgJiYgbmV4dERpZmYuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREaWZmTGluZXMgPSBjb25zdHJ1Y3RMaW5lcyhuZXh0RGlmZi52YWx1ZSlbbGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RGlmZkxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERpZmZMaW5lSW5mbyA9IGdldExpbmVJbmZvcm1hdGlvbihuZXh0RGlmZkxpbmVzLCBkaWZmSW5kZXgsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiByaWdodFZhbHVlLCBsaW5lTnVtYmVyLCB0eXBlLCB9ID0gbmV4dERpZmZMaW5lSW5mb1swXS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGlkZW50aWZpZWQgYXMgbW9kaWZpY2F0aW9uLCBwdXNoIHRoZSBuZXh0IGRpZmYgdG8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBhcyB0aGUgbmV4dCB2YWx1ZSB3aWxsIGJlIGFkZGVkIGluIHRoaXMgbGluZSBjb21wdXRhdGlvbiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGFuZCBsZWZ0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVEaWZmSW5kZXhlcy5wdXNoKGAke2RpZmZJbmRleCArIDF9LSR7bGluZUluZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnZhbHVlID09PSByaWdodFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50QXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBjaGFyIGxldmVsIGRpZmYgYW5kIGFzc2lnbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnQgYW5kIHJpZ2h0IGRpZmYgaW5mb3JtYXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZVdvcmREaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC52YWx1ZSA9IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZERpZmYgPSBjb21wdXRlRGlmZihsaW5lLCByaWdodFZhbHVlLCBsaW5lQ29tcGFyZU1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC52YWx1ZSA9IGNvbXB1dGVkRGlmZi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQudmFsdWUgPSBjb21wdXRlZERpZmYubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LmxpbmVOdW1iZXIgPSByaWdodExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSBEaWZmVHlwZS5BRERFRDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQudmFsdWUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY291bnRBc0NoYW5nZSAmJiAhZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlmZkxpbmVzLmluY2x1ZGVzKGNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmTGluZXMucHVzaChjb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgcmlnaHRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgbGVmdC5saW5lTnVtYmVyID0gbGVmdExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGVmdC50eXBlID0gRGlmZlR5cGUuREVGQVVMVDtcbiAgICAgICAgICAgICAgICBsZWZ0LnZhbHVlID0gbGluZTtcbiAgICAgICAgICAgICAgICByaWdodC5saW5lTnVtYmVyID0gcmlnaHRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSBEaWZmVHlwZS5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgcmlnaHQsIGxlZnQgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgfTtcbiAgICBkaWZmQXJyYXkuZm9yRWFjaCgoeyBhZGRlZCwgcmVtb3ZlZCwgdmFsdWUgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGluZUluZm9ybWF0aW9uID0gW1xuICAgICAgICAgICAgLi4ubGluZUluZm9ybWF0aW9uLFxuICAgICAgICAgICAgLi4uZ2V0TGluZUluZm9ybWF0aW9uKHZhbHVlLCBpbmRleCwgYWRkZWQsIHJlbW92ZWQpLFxuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmZvcm1hdGlvbixcbiAgICAgICAgZGlmZkxpbmVzLFxuICAgIH07XG59O1xuZXhwb3J0cy5jb21wdXRlTGluZUluZm9ybWF0aW9uID0gY29tcHV0ZUxpbmVJbmZvcm1hdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/compute-lines.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/index.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/index.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiffMethod = exports.LineNumberPrefix = void 0;\nconst React = __webpack_require__(/*! react */ \"(ssr)/../node_modules/.pnpm/next@15.1.0_@babel+core@7.26.0_babel-plugin-macros@3.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.77.4/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nconst PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\");\nconst classnames_1 = __webpack_require__(/*! classnames */ \"(ssr)/../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js\");\nconst compute_lines_1 = __webpack_require__(/*! ./compute-lines */ \"(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/compute-lines.js\");\nObject.defineProperty(exports, \"DiffMethod\", ({ enumerable: true, get: function () { return compute_lines_1.DiffMethod; } }));\nconst styles_1 = __webpack_require__(/*! ./styles */ \"(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/styles.js\");\nconst m = __webpack_require__(/*! memoize-one */ \"(ssr)/../node_modules/.pnpm/memoize-one@6.0.0/node_modules/memoize-one/dist/memoize-one.esm.js\");\nconst memoize = m.default || m;\nvar LineNumberPrefix;\n(function (LineNumberPrefix) {\n    LineNumberPrefix[\"LEFT\"] = \"L\";\n    LineNumberPrefix[\"RIGHT\"] = \"R\";\n})(LineNumberPrefix = exports.LineNumberPrefix || (exports.LineNumberPrefix = {}));\nclass DiffViewer extends React.Component {\n    constructor(props) {\n        super(props);\n        /**\n         * Resets code block expand to the initial stage. Will be exposed to the parent component via\n         * refs.\n         */\n        this.resetCodeBlocks = () => {\n            if (this.state.expandedBlocks.length > 0) {\n                this.setState({\n                    expandedBlocks: [],\n                });\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Pushes the target expanded code block to the state. During the re-render,\n         * this value is used to expand/fold unmodified code.\n         */\n        this.onBlockExpand = (id) => {\n            const prevState = this.state.expandedBlocks.slice();\n            prevState.push(id);\n            this.setState({\n                expandedBlocks: prevState,\n            });\n        };\n        /**\n         * Computes final styles for the diff viewer. It combines the default styles with the user\n         * supplied overrides. The computed styles are cached with performance in mind.\n         *\n         * @param styles User supplied style overrides.\n         */\n        this.computeStyles = memoize(styles_1.default);\n        /**\n         * Returns a function with clicked line number in the closure. Returns an no-op function when no\n         * onLineNumberClick handler is supplied.\n         *\n         * @param id Line id of a line.\n         */\n        this.onLineNumberClickProxy = (id) => {\n            if (this.props.onLineNumberClick) {\n                return (e) => this.props.onLineNumberClick(id, e);\n            }\n            return () => { };\n        };\n        /**\n         * Maps over the word diff and constructs the required React elements to show word diff.\n         *\n         * @param diffArray Word diff information derived from line information.\n         * @param renderer Optional renderer to format diff words. Useful for syntax highlighting.\n         */\n        this.renderWordDiff = (diffArray, renderer) => {\n            return diffArray.map((wordDiff, i) => {\n                return (React.createElement(\"span\", { key: i, className: (0, classnames_1.default)(this.styles.wordDiff, {\n                        [this.styles.wordAdded]: wordDiff.type === compute_lines_1.DiffType.ADDED,\n                        [this.styles.wordRemoved]: wordDiff.type === compute_lines_1.DiffType.REMOVED,\n                    }) }, renderer ? renderer(wordDiff.value) : wordDiff.value));\n            });\n        };\n        /**\n         * Maps over the line diff and constructs the required react elements to show line diff. It calls\n         * renderWordDiff when encountering word diff. This takes care of both inline and split view line\n         * renders.\n         *\n         * @param lineNumber Line number of the current line.\n         * @param type Type of diff of the current line.\n         * @param prefix Unique id to prefix with the line numbers.\n         * @param value Content of the line. It can be a string or a word diff array.\n         * @param additionalLineNumber Additional line number to be shown. Useful for rendering inline\n         *  diff view. Right line number will be passed as additionalLineNumber.\n         * @param additionalPrefix Similar to prefix but for additional line number.\n         */\n        this.renderLine = (lineNumber, type, prefix, value, additionalLineNumber, additionalPrefix) => {\n            const lineNumberTemplate = `${prefix}-${lineNumber}`;\n            const additionalLineNumberTemplate = `${additionalPrefix}-${additionalLineNumber}`;\n            const highlightLine = this.props.highlightLines.includes(lineNumberTemplate) ||\n                this.props.highlightLines.includes(additionalLineNumberTemplate);\n            const added = type === compute_lines_1.DiffType.ADDED;\n            const removed = type === compute_lines_1.DiffType.REMOVED;\n            const changed = type === compute_lines_1.DiffType.CHANGED;\n            let content;\n            if (Array.isArray(value)) {\n                content = this.renderWordDiff(value, this.props.renderContent);\n            }\n            else if (this.props.renderContent) {\n                content = this.props.renderContent(value);\n            }\n            else {\n                content = value;\n            }\n            return (React.createElement(React.Fragment, null,\n                !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: lineNumber && this.onLineNumberClickProxy(lineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !lineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, lineNumber))),\n                !this.props.splitView && !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: additionalLineNumber &&\n                        this.onLineNumberClickProxy(additionalLineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !additionalLineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, additionalLineNumber))),\n                this.props.renderGutter\n                    ? this.props.renderGutter({\n                        lineNumber,\n                        type,\n                        prefix,\n                        value,\n                        additionalLineNumber,\n                        additionalPrefix,\n                        styles: this.styles,\n                    })\n                    : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.marker, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", null,\n                        added && '+',\n                        removed && '-')),\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.content, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, content))));\n        };\n        /**\n         * Generates lines for split view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the left pane of the split view.\n         * @param obj.right Life diff information for the right pane of the split view.\n         * @param index React key for the lines.\n         */\n        this.renderSplitView = ({ left, right }, index) => {\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line },\n                this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value),\n                this.renderLine(right.lineNumber, right.type, LineNumberPrefix.RIGHT, right.value)));\n        };\n        /**\n         * Generates lines for inline view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the added section of the inline view.\n         * @param obj.right Life diff information for the removed section of the inline view.\n         * @param index React key for the lines.\n         */\n        this.renderInlineView = ({ left, right }, index) => {\n            let content;\n            if (left.type === compute_lines_1.DiffType.REMOVED && right.type === compute_lines_1.DiffType.ADDED) {\n                return (React.createElement(React.Fragment, { key: index },\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null)),\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber))));\n            }\n            if (left.type === compute_lines_1.DiffType.REMOVED) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null);\n            }\n            if (left.type === compute_lines_1.DiffType.DEFAULT) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, right.lineNumber, LineNumberPrefix.RIGHT);\n            }\n            if (right.type === compute_lines_1.DiffType.ADDED) {\n                content = this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber);\n            }\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line }, content));\n        };\n        /**\n         * Returns a function with clicked block number in the closure.\n         *\n         * @param id Cold fold block id.\n         */\n        this.onBlockClickProxy = (id) => () => this.onBlockExpand(id);\n        /**\n         * Generates cold fold block. It also uses the custom message renderer when available to show\n         * cold fold messages.\n         *\n         * @param num Number of skipped lines between two blocks.\n         * @param blockNumber Code fold block id.\n         * @param leftBlockLineNumber First left line number after the current code fold block.\n         * @param rightBlockLineNumber First right line number after the current code fold block.\n         */\n        this.renderSkippedLineIndicator = (num, blockNumber, leftBlockLineNumber, rightBlockLineNumber) => {\n            const { hideLineNumbers, splitView } = this.props;\n            const message = this.props.codeFoldMessageRenderer ? (this.props.codeFoldMessageRenderer(num, leftBlockLineNumber, rightBlockLineNumber)) : (React.createElement(\"pre\", { className: this.styles.codeFoldContent },\n                \"Expand \",\n                num,\n                \" lines ...\"));\n            const content = (React.createElement(\"td\", null,\n                React.createElement(\"a\", { onClick: this.onBlockClickProxy(blockNumber), tabIndex: 0 }, message)));\n            const isUnifiedViewWithoutLineNumbers = !splitView && !hideLineNumbers;\n            return (React.createElement(\"tr\", { key: `${leftBlockLineNumber}-${rightBlockLineNumber}`, className: this.styles.codeFold },\n                !hideLineNumbers && React.createElement(\"td\", { className: this.styles.codeFoldGutter }),\n                this.props.renderGutter ? (React.createElement(\"td\", { className: this.styles.codeFoldGutter })) : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)({\n                        [this.styles.codeFoldGutter]: isUnifiedViewWithoutLineNumbers,\n                    }) }),\n                isUnifiedViewWithoutLineNumbers ? (React.createElement(React.Fragment, null,\n                    React.createElement(\"td\", null),\n                    content)) : (React.createElement(React.Fragment, null,\n                    content,\n                    this.props.renderGutter ? React.createElement(\"td\", null) : null,\n                    React.createElement(\"td\", null))),\n                React.createElement(\"td\", null),\n                React.createElement(\"td\", null)));\n        };\n        /**\n         * Generates the entire diff view.\n         */\n        this.renderDiff = () => {\n            const { oldValue, newValue, splitView, disableWordDiff, compareMethod, linesOffset, } = this.props;\n            const { lineInformation, diffLines } = (0, compute_lines_1.computeLineInformation)(oldValue, newValue, disableWordDiff, compareMethod, linesOffset);\n            const extraLines = this.props.extraLinesSurroundingDiff < 0\n                ? 0\n                : this.props.extraLinesSurroundingDiff;\n            let skippedLines = [];\n            return lineInformation.map((line, i) => {\n                const diffBlockStart = diffLines[0];\n                const currentPosition = diffBlockStart - i;\n                if (this.props.showDiffOnly) {\n                    if (currentPosition === -extraLines) {\n                        skippedLines = [];\n                        diffLines.shift();\n                    }\n                    if (line.left.type === compute_lines_1.DiffType.DEFAULT &&\n                        (currentPosition > extraLines ||\n                            typeof diffBlockStart === 'undefined') &&\n                        !this.state.expandedBlocks.includes(diffBlockStart)) {\n                        skippedLines.push(i + 1);\n                        // show skipped line indicator only if there is more than one line to hide\n                        if (i === lineInformation.length - 1 && skippedLines.length > 1) {\n                            return this.renderSkippedLineIndicator(skippedLines.length, diffBlockStart, line.left.lineNumber, line.right.lineNumber);\n                            // if we are trying to hide the last line, just show it\n                        }\n                        else if (i < lineInformation.length - 1) {\n                            return null;\n                        }\n                    }\n                }\n                const diffNodes = splitView\n                    ? this.renderSplitView(line, i)\n                    : this.renderInlineView(line, i);\n                if (currentPosition === extraLines && skippedLines.length > 0) {\n                    const { length } = skippedLines;\n                    skippedLines = [];\n                    return (React.createElement(React.Fragment, { key: i },\n                        this.renderSkippedLineIndicator(length, diffBlockStart, line.left.lineNumber, line.right.lineNumber),\n                        diffNodes));\n                }\n                return diffNodes;\n            });\n        };\n        this.render = () => {\n            const { oldValue, newValue, useDarkTheme, leftTitle, rightTitle, splitView, hideLineNumbers, } = this.props;\n            if (this.props.compareMethod !== compute_lines_1.DiffMethod.JSON) {\n                if (typeof oldValue !== 'string' || typeof newValue !== 'string') {\n                    throw Error('\"oldValue\" and \"newValue\" should be strings');\n                }\n            }\n            this.styles = this.computeStyles(this.props.styles, useDarkTheme);\n            const nodes = this.renderDiff();\n            const colSpanOnSplitView = hideLineNumbers ? 2 : 3;\n            const colSpanOnInlineView = hideLineNumbers ? 2 : 4;\n            let columnExtension = this.props.renderGutter ? 1 : 0;\n            const title = (leftTitle || rightTitle) && (React.createElement(\"tr\", null,\n                React.createElement(\"td\", { colSpan: (splitView ? colSpanOnSplitView : colSpanOnInlineView) +\n                        columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, leftTitle)),\n                splitView && (React.createElement(\"td\", { colSpan: colSpanOnSplitView + columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, rightTitle)))));\n            return (React.createElement(\"table\", { className: (0, classnames_1.default)(this.styles.diffContainer, {\n                    [this.styles.splitView]: splitView,\n                }) },\n                React.createElement(\"tbody\", null,\n                    title,\n                    nodes)));\n        };\n        this.state = {\n            expandedBlocks: [],\n        };\n    }\n}\nDiffViewer.defaultProps = {\n    oldValue: '',\n    newValue: '',\n    splitView: true,\n    highlightLines: [],\n    disableWordDiff: false,\n    compareMethod: compute_lines_1.DiffMethod.CHARS,\n    styles: {},\n    hideLineNumbers: false,\n    extraLinesSurroundingDiff: 3,\n    showDiffOnly: true,\n    useDarkTheme: false,\n    linesOffset: 0,\n};\nDiffViewer.propTypes = {\n    oldValue: PropTypes.any.isRequired,\n    newValue: PropTypes.any.isRequired,\n    splitView: PropTypes.bool,\n    disableWordDiff: PropTypes.bool,\n    compareMethod: PropTypes.oneOf(Object.values(compute_lines_1.DiffMethod)),\n    renderContent: PropTypes.func,\n    renderGutter: PropTypes.func,\n    onLineNumberClick: PropTypes.func,\n    extraLinesSurroundingDiff: PropTypes.number,\n    styles: PropTypes.object,\n    hideLineNumbers: PropTypes.bool,\n    showDiffOnly: PropTypes.bool,\n    highlightLines: PropTypes.arrayOf(PropTypes.string),\n    leftTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    rightTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    linesOffset: PropTypes.number,\n};\nexports[\"default\"] = DiffViewer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHdCQUF3QjtBQUM3QyxjQUFjLG1CQUFPLENBQUMsc09BQU87QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsa0dBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUdBQVk7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsZ01BQWlCO0FBQ2pELDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQyxrTEFBVTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsbUhBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxHQUFHLFdBQVc7QUFDL0Qsb0RBQW9ELGlCQUFpQixHQUFHLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG1DQUFtQztBQUNwRixxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG1DQUFtQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUUsZ0RBQWdELDZCQUE2QjtBQUM3RSxnREFBZ0QsNkJBQTZCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRCxzTEFBc0wsd0NBQXdDO0FBQzlOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJEQUEyRDtBQUN0RztBQUNBLGdEQUFnRCxRQUFRLG9CQUFvQixHQUFHLHFCQUFxQixvQ0FBb0M7QUFDeEksZ0VBQWdFLHVDQUF1QztBQUN2Ryx1RUFBdUUsdUNBQXVDO0FBQzlHLDRDQUE0QztBQUM1QztBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhFQUE4RTtBQUNsRyxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLHVGQUF1RjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRFQUE0RTtBQUM1RSxpREFBaUQsb0NBQW9DO0FBQ3JGLDBEQUEwRCxrRkFBa0Y7QUFDNUksaURBQWlELG9DQUFvQztBQUNyRixtREFBbUQ7QUFDbkQ7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL2hvbWUvcGF1bC9wcm9qZWN0cy9wYXlsb2FkL3BsdWdpbi1kZXZlbG9wbWVudC9iZXR0ZXItZmllbGRzL2dpdHJvb3Qvbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaWZmTWV0aG9kID0gZXhwb3J0cy5MaW5lTnVtYmVyUHJlZml4ID0gdm9pZCAwO1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBQcm9wVHlwZXMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTtcbmNvbnN0IGNsYXNzbmFtZXNfMSA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xuY29uc3QgY29tcHV0ZV9saW5lc18xID0gcmVxdWlyZShcIi4vY29tcHV0ZS1saW5lc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZmZNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXB1dGVfbGluZXNfMS5EaWZmTWV0aG9kOyB9IH0pO1xuY29uc3Qgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG5jb25zdCBtID0gcmVxdWlyZSgnbWVtb2l6ZS1vbmUnKTtcbmNvbnN0IG1lbW9pemUgPSBtLmRlZmF1bHQgfHwgbTtcbnZhciBMaW5lTnVtYmVyUHJlZml4O1xuKGZ1bmN0aW9uIChMaW5lTnVtYmVyUHJlZml4KSB7XG4gICAgTGluZU51bWJlclByZWZpeFtcIkxFRlRcIl0gPSBcIkxcIjtcbiAgICBMaW5lTnVtYmVyUHJlZml4W1wiUklHSFRcIl0gPSBcIlJcIjtcbn0pKExpbmVOdW1iZXJQcmVmaXggPSBleHBvcnRzLkxpbmVOdW1iZXJQcmVmaXggfHwgKGV4cG9ydHMuTGluZU51bWJlclByZWZpeCA9IHt9KSk7XG5jbGFzcyBEaWZmVmlld2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgY29kZSBibG9jayBleHBhbmQgdG8gdGhlIGluaXRpYWwgc3RhZ2UuIFdpbGwgYmUgZXhwb3NlZCB0byB0aGUgcGFyZW50IGNvbXBvbmVudCB2aWFcbiAgICAgICAgICogcmVmcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXRDb2RlQmxvY2tzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhwYW5kZWRCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZEJsb2NrczogW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdXNoZXMgdGhlIHRhcmdldCBleHBhbmRlZCBjb2RlIGJsb2NrIHRvIHRoZSBzdGF0ZS4gRHVyaW5nIHRoZSByZS1yZW5kZXIsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgaXMgdXNlZCB0byBleHBhbmQvZm9sZCB1bm1vZGlmaWVkIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmxvY2tFeHBhbmQgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGUuZXhwYW5kZWRCbG9ja3Muc2xpY2UoKTtcbiAgICAgICAgICAgIHByZXZTdGF0ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkQmxvY2tzOiBwcmV2U3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGVzIGZpbmFsIHN0eWxlcyBmb3IgdGhlIGRpZmYgdmlld2VyLiBJdCBjb21iaW5lcyB0aGUgZGVmYXVsdCBzdHlsZXMgd2l0aCB0aGUgdXNlclxuICAgICAgICAgKiBzdXBwbGllZCBvdmVycmlkZXMuIFRoZSBjb21wdXRlZCBzdHlsZXMgYXJlIGNhY2hlZCB3aXRoIHBlcmZvcm1hbmNlIGluIG1pbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHlsZXMgVXNlciBzdXBwbGllZCBzdHlsZSBvdmVycmlkZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXB1dGVTdHlsZXMgPSBtZW1vaXplKHN0eWxlc18xLmRlZmF1bHQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHdpdGggY2xpY2tlZCBsaW5lIG51bWJlciBpbiB0aGUgY2xvc3VyZS4gUmV0dXJucyBhbiBuby1vcCBmdW5jdGlvbiB3aGVuIG5vXG4gICAgICAgICAqIG9uTGluZU51bWJlckNsaWNrIGhhbmRsZXIgaXMgc3VwcGxpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpZCBMaW5lIGlkIG9mIGEgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25MaW5lTnVtYmVyQ2xpY2tQcm94eSA9IChpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25MaW5lTnVtYmVyQ2xpY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGUpID0+IHRoaXMucHJvcHMub25MaW5lTnVtYmVyQ2xpY2soaWQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgb3ZlciB0aGUgd29yZCBkaWZmIGFuZCBjb25zdHJ1Y3RzIHRoZSByZXF1aXJlZCBSZWFjdCBlbGVtZW50cyB0byBzaG93IHdvcmQgZGlmZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpZmZBcnJheSBXb3JkIGRpZmYgaW5mb3JtYXRpb24gZGVyaXZlZCBmcm9tIGxpbmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSByZW5kZXJlciBPcHRpb25hbCByZW5kZXJlciB0byBmb3JtYXQgZGlmZiB3b3Jkcy4gVXNlZnVsIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJXb3JkRGlmZiA9IChkaWZmQXJyYXksIHJlbmRlcmVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkFycmF5Lm1hcCgod29yZERpZmYsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBpLCBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMud29yZERpZmYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy53b3JkQWRkZWRdOiB3b3JkRGlmZi50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuQURERUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMud29yZFJlbW92ZWRdOiB3b3JkRGlmZi50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuUkVNT1ZFRCxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSwgcmVuZGVyZXIgPyByZW5kZXJlcih3b3JkRGlmZi52YWx1ZSkgOiB3b3JkRGlmZi52YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIG92ZXIgdGhlIGxpbmUgZGlmZiBhbmQgY29uc3RydWN0cyB0aGUgcmVxdWlyZWQgcmVhY3QgZWxlbWVudHMgdG8gc2hvdyBsaW5lIGRpZmYuIEl0IGNhbGxzXG4gICAgICAgICAqIHJlbmRlcldvcmREaWZmIHdoZW4gZW5jb3VudGVyaW5nIHdvcmQgZGlmZi4gVGhpcyB0YWtlcyBjYXJlIG9mIGJvdGggaW5saW5lIGFuZCBzcGxpdCB2aWV3IGxpbmVcbiAgICAgICAgICogcmVuZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxpbmVOdW1iZXIgTGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiBkaWZmIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAqIEBwYXJhbSBwcmVmaXggVW5pcXVlIGlkIHRvIHByZWZpeCB3aXRoIHRoZSBsaW5lIG51bWJlcnMuXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBDb250ZW50IG9mIHRoZSBsaW5lLiBJdCBjYW4gYmUgYSBzdHJpbmcgb3IgYSB3b3JkIGRpZmYgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsTGluZU51bWJlciBBZGRpdGlvbmFsIGxpbmUgbnVtYmVyIHRvIGJlIHNob3duLiBVc2VmdWwgZm9yIHJlbmRlcmluZyBpbmxpbmVcbiAgICAgICAgICogIGRpZmYgdmlldy4gUmlnaHQgbGluZSBudW1iZXIgd2lsbCBiZSBwYXNzZWQgYXMgYWRkaXRpb25hbExpbmVOdW1iZXIuXG4gICAgICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsUHJlZml4IFNpbWlsYXIgdG8gcHJlZml4IGJ1dCBmb3IgYWRkaXRpb25hbCBsaW5lIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyTGluZSA9IChsaW5lTnVtYmVyLCB0eXBlLCBwcmVmaXgsIHZhbHVlLCBhZGRpdGlvbmFsTGluZU51bWJlciwgYWRkaXRpb25hbFByZWZpeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlclRlbXBsYXRlID0gYCR7cHJlZml4fS0ke2xpbmVOdW1iZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxMaW5lTnVtYmVyVGVtcGxhdGUgPSBgJHthZGRpdGlvbmFsUHJlZml4fS0ke2FkZGl0aW9uYWxMaW5lTnVtYmVyfWA7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRMaW5lID0gdGhpcy5wcm9wcy5oaWdobGlnaHRMaW5lcy5pbmNsdWRlcyhsaW5lTnVtYmVyVGVtcGxhdGUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5oaWdobGlnaHRMaW5lcy5pbmNsdWRlcyhhZGRpdGlvbmFsTGluZU51bWJlclRlbXBsYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gdHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkFEREVEO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5DSEFOR0VEO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJXb3JkRGlmZih2YWx1ZSwgdGhpcy5wcm9wcy5yZW5kZXJDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMucmVuZGVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnByb3BzLnJlbmRlckNvbnRlbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmhpZGVMaW5lTnVtYmVycyAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgb25DbGljazogbGluZU51bWJlciAmJiB0aGlzLm9uTGluZU51bWJlckNsaWNrUHJveHkobGluZU51bWJlclRlbXBsYXRlKSwgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLmd1dHRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmVtcHR5R3V0dGVyXTogIWxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkFkZGVkXTogYWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZlJlbW92ZWRdOiByZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZDaGFuZ2VkXTogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5oaWdobGlnaHRlZEd1dHRlcl06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmVOdW1iZXIgfSwgbGluZU51bWJlcikpKSxcbiAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5zcGxpdFZpZXcgJiYgIXRoaXMucHJvcHMuaGlkZUxpbmVOdW1iZXJzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBvbkNsaWNrOiBhZGRpdGlvbmFsTGluZU51bWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxpbmVOdW1iZXJDbGlja1Byb3h5KGFkZGl0aW9uYWxMaW5lTnVtYmVyVGVtcGxhdGUpLCBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMuZ3V0dGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZW1wdHlHdXR0ZXJdOiAhYWRkaXRpb25hbExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkFkZGVkXTogYWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZlJlbW92ZWRdOiByZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZDaGFuZ2VkXTogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5oaWdobGlnaHRlZEd1dHRlcl06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmVOdW1iZXIgfSwgYWRkaXRpb25hbExpbmVOdW1iZXIpKSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yZW5kZXJHdXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLnJlbmRlckd1dHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy5tYXJrZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5lbXB0eUxpbmVdOiAhY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkTGluZV06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkICYmICcrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgJiYgJy0nKSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLmNvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5lbXB0eUxpbmVdOiAhY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkTGluZV06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvbnRlbnRUZXh0IH0sIGNvbnRlbnQpKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGxpbmVzIGZvciBzcGxpdCB2aWV3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JqIExpbmUgZGlmZiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHBhcmFtIG9iai5sZWZ0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIGxlZnQgcGFuZSBvZiB0aGUgc3BsaXQgdmlldy5cbiAgICAgICAgICogQHBhcmFtIG9iai5yaWdodCBMaWZlIGRpZmYgaW5mb3JtYXRpb24gZm9yIHRoZSByaWdodCBwYW5lIG9mIHRoZSBzcGxpdCB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggUmVhY3Qga2V5IGZvciB0aGUgbGluZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclNwbGl0VmlldyA9ICh7IGxlZnQsIHJpZ2h0IH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogaW5kZXgsIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZSB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpbmUocmlnaHQubGluZU51bWJlciwgcmlnaHQudHlwZSwgTGluZU51bWJlclByZWZpeC5SSUdIVCwgcmlnaHQudmFsdWUpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgbGluZXMgZm9yIGlubGluZSB2aWV3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JqIExpbmUgZGlmZiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHBhcmFtIG9iai5sZWZ0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkZGVkIHNlY3Rpb24gb2YgdGhlIGlubGluZSB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gb2JqLnJpZ2h0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlbW92ZWQgc2VjdGlvbiBvZiB0aGUgaW5saW5lIHZpZXcuXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCBSZWFjdCBrZXkgZm9yIHRoZSBsaW5lcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVySW5saW5lVmlldyA9ICh7IGxlZnQsIHJpZ2h0IH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEICYmIHJpZ2h0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5BRERFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgeyBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZSB9LCB0aGlzLnJlbmRlckxpbmUobGVmdC5saW5lTnVtYmVyLCBsZWZ0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguTEVGVCwgbGVmdC52YWx1ZSwgbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmUgfSwgdGhpcy5yZW5kZXJMaW5lKG51bGwsIHJpZ2h0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguUklHSFQsIHJpZ2h0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyLCBMaW5lTnVtYmVyUHJlZml4LlJJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuQURERUQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJMaW5lKG51bGwsIHJpZ2h0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguUklHSFQsIHJpZ2h0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBpbmRleCwgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5saW5lIH0sIGNvbnRlbnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGNsaWNrZWQgYmxvY2sgbnVtYmVyIGluIHRoZSBjbG9zdXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaWQgQ29sZCBmb2xkIGJsb2NrIGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsb2NrQ2xpY2tQcm94eSA9IChpZCkgPT4gKCkgPT4gdGhpcy5vbkJsb2NrRXhwYW5kKGlkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBjb2xkIGZvbGQgYmxvY2suIEl0IGFsc28gdXNlcyB0aGUgY3VzdG9tIG1lc3NhZ2UgcmVuZGVyZXIgd2hlbiBhdmFpbGFibGUgdG8gc2hvd1xuICAgICAgICAgKiBjb2xkIGZvbGQgbWVzc2FnZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW0gTnVtYmVyIG9mIHNraXBwZWQgbGluZXMgYmV0d2VlbiB0d28gYmxvY2tzLlxuICAgICAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgQ29kZSBmb2xkIGJsb2NrIGlkLlxuICAgICAgICAgKiBAcGFyYW0gbGVmdEJsb2NrTGluZU51bWJlciBGaXJzdCBsZWZ0IGxpbmUgbnVtYmVyIGFmdGVyIHRoZSBjdXJyZW50IGNvZGUgZm9sZCBibG9jay5cbiAgICAgICAgICogQHBhcmFtIHJpZ2h0QmxvY2tMaW5lTnVtYmVyIEZpcnN0IHJpZ2h0IGxpbmUgbnVtYmVyIGFmdGVyIHRoZSBjdXJyZW50IGNvZGUgZm9sZCBibG9jay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyU2tpcHBlZExpbmVJbmRpY2F0b3IgPSAobnVtLCBibG9ja051bWJlciwgbGVmdEJsb2NrTGluZU51bWJlciwgcmlnaHRCbG9ja0xpbmVOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGlkZUxpbmVOdW1iZXJzLCBzcGxpdFZpZXcgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wcm9wcy5jb2RlRm9sZE1lc3NhZ2VSZW5kZXJlciA/ICh0aGlzLnByb3BzLmNvZGVGb2xkTWVzc2FnZVJlbmRlcmVyKG51bSwgbGVmdEJsb2NrTGluZU51bWJlciwgcmlnaHRCbG9ja0xpbmVOdW1iZXIpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb2RlRm9sZENvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICBcIkV4cGFuZCBcIixcbiAgICAgICAgICAgICAgICBudW0sXG4gICAgICAgICAgICAgICAgXCIgbGluZXMgLi4uXCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBvbkNsaWNrOiB0aGlzLm9uQmxvY2tDbGlja1Byb3h5KGJsb2NrTnVtYmVyKSwgdGFiSW5kZXg6IDAgfSwgbWVzc2FnZSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVW5pZmllZFZpZXdXaXRob3V0TGluZU51bWJlcnMgPSAhc3BsaXRWaWV3ICYmICFoaWRlTGluZU51bWJlcnM7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogYCR7bGVmdEJsb2NrTGluZU51bWJlcn0tJHtyaWdodEJsb2NrTGluZU51bWJlcn1gLCBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvZGVGb2xkIH0sXG4gICAgICAgICAgICAgICAgIWhpZGVMaW5lTnVtYmVycyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvZGVGb2xkR3V0dGVyIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucmVuZGVyR3V0dGVyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29kZUZvbGRHdXR0ZXIgfSkpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmNvZGVGb2xkR3V0dGVyXTogaXNVbmlmaWVkVmlld1dpdGhvdXRMaW5lTnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSksXG4gICAgICAgICAgICAgICAgaXNVbmlmaWVkVmlld1dpdGhvdXRMaW5lTnVtYmVycyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJlbmRlckd1dHRlciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyB0aGUgZW50aXJlIGRpZmYgdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyRGlmZiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2xkVmFsdWUsIG5ld1ZhbHVlLCBzcGxpdFZpZXcsIGRpc2FibGVXb3JkRGlmZiwgY29tcGFyZU1ldGhvZCwgbGluZXNPZmZzZXQsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBsaW5lSW5mb3JtYXRpb24sIGRpZmZMaW5lcyB9ID0gKDAsIGNvbXB1dGVfbGluZXNfMS5jb21wdXRlTGluZUluZm9ybWF0aW9uKShvbGRWYWx1ZSwgbmV3VmFsdWUsIGRpc2FibGVXb3JkRGlmZiwgY29tcGFyZU1ldGhvZCwgbGluZXNPZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFMaW5lcyA9IHRoaXMucHJvcHMuZXh0cmFMaW5lc1N1cnJvdW5kaW5nRGlmZiA8IDBcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMuZXh0cmFMaW5lc1N1cnJvdW5kaW5nRGlmZjtcbiAgICAgICAgICAgIGxldCBza2lwcGVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lSW5mb3JtYXRpb24ubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZkJsb2NrU3RhcnQgPSBkaWZmTGluZXNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gZGlmZkJsb2NrU3RhcnQgLSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNob3dEaWZmT25seSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSAtZXh0cmFMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmTGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5ERUZBVUxUICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFBvc2l0aW9uID4gZXh0cmFMaW5lcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkaWZmQmxvY2tTdGFydCA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5leHBhbmRlZEJsb2Nrcy5pbmNsdWRlcyhkaWZmQmxvY2tTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRMaW5lcy5wdXNoKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3cgc2tpcHBlZCBsaW5lIGluZGljYXRvciBvbmx5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbGluZSB0byBoaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGluZUluZm9ybWF0aW9uLmxlbmd0aCAtIDEgJiYgc2tpcHBlZExpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTa2lwcGVkTGluZUluZGljYXRvcihza2lwcGVkTGluZXMubGVuZ3RoLCBkaWZmQmxvY2tTdGFydCwgbGluZS5sZWZ0LmxpbmVOdW1iZXIsIGxpbmUucmlnaHQubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHRyeWluZyB0byBoaWRlIHRoZSBsYXN0IGxpbmUsIGp1c3Qgc2hvdyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGxpbmVJbmZvcm1hdGlvbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZk5vZGVzID0gc3BsaXRWaWV3XG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5yZW5kZXJTcGxpdFZpZXcobGluZSwgaSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnJlbmRlcklubGluZVZpZXcobGluZSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gZXh0cmFMaW5lcyAmJiBza2lwcGVkTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc2tpcHBlZExpbmVzO1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTa2lwcGVkTGluZUluZGljYXRvcihsZW5ndGgsIGRpZmZCbG9ja1N0YXJ0LCBsaW5lLmxlZnQubGluZU51bWJlciwgbGluZS5yaWdodC5saW5lTnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZOb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZk5vZGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbGRWYWx1ZSwgbmV3VmFsdWUsIHVzZURhcmtUaGVtZSwgbGVmdFRpdGxlLCByaWdodFRpdGxlLCBzcGxpdFZpZXcsIGhpZGVMaW5lTnVtYmVycywgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5jb21wYXJlTWV0aG9kICE9PSBjb21wdXRlX2xpbmVzXzEuRGlmZk1ldGhvZC5KU09OKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1ZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignXCJvbGRWYWx1ZVwiIGFuZCBcIm5ld1ZhbHVlXCIgc2hvdWxkIGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHRoaXMuY29tcHV0ZVN0eWxlcyh0aGlzLnByb3BzLnN0eWxlcywgdXNlRGFya1RoZW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5yZW5kZXJEaWZmKCk7XG4gICAgICAgICAgICBjb25zdCBjb2xTcGFuT25TcGxpdFZpZXcgPSBoaWRlTGluZU51bWJlcnMgPyAyIDogMztcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW5PbklubGluZVZpZXcgPSBoaWRlTGluZU51bWJlcnMgPyAyIDogNDtcbiAgICAgICAgICAgIGxldCBjb2x1bW5FeHRlbnNpb24gPSB0aGlzLnByb3BzLnJlbmRlckd1dHRlciA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSAobGVmdFRpdGxlIHx8IHJpZ2h0VGl0bGUpICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAoc3BsaXRWaWV3ID8gY29sU3Bhbk9uU3BsaXRWaWV3IDogY29sU3Bhbk9uSW5saW5lVmlldykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uRXh0ZW5zaW9uLCBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLnRpdGxlQmxvY2sgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29udGVudFRleHQgfSwgbGVmdFRpdGxlKSksXG4gICAgICAgICAgICAgICAgc3BsaXRWaWV3ICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiBjb2xTcGFuT25TcGxpdFZpZXcgKyBjb2x1bW5FeHRlbnNpb24sIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMudGl0bGVCbG9jayB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb250ZW50VGV4dCB9LCByaWdodFRpdGxlKSkpKSk7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy5kaWZmQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5zcGxpdFZpZXddOiBzcGxpdFZpZXcsXG4gICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXhwYW5kZWRCbG9ja3M6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkRpZmZWaWV3ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIG9sZFZhbHVlOiAnJyxcbiAgICBuZXdWYWx1ZTogJycsXG4gICAgc3BsaXRWaWV3OiB0cnVlLFxuICAgIGhpZ2hsaWdodExpbmVzOiBbXSxcbiAgICBkaXNhYmxlV29yZERpZmY6IGZhbHNlLFxuICAgIGNvbXBhcmVNZXRob2Q6IGNvbXB1dGVfbGluZXNfMS5EaWZmTWV0aG9kLkNIQVJTLFxuICAgIHN0eWxlczoge30sXG4gICAgaGlkZUxpbmVOdW1iZXJzOiBmYWxzZSxcbiAgICBleHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmOiAzLFxuICAgIHNob3dEaWZmT25seTogdHJ1ZSxcbiAgICB1c2VEYXJrVGhlbWU6IGZhbHNlLFxuICAgIGxpbmVzT2Zmc2V0OiAwLFxufTtcbkRpZmZWaWV3ZXIucHJvcFR5cGVzID0ge1xuICAgIG9sZFZhbHVlOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4gICAgbmV3VmFsdWU6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgICBzcGxpdFZpZXc6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVXb3JkRGlmZjogUHJvcFR5cGVzLmJvb2wsXG4gICAgY29tcGFyZU1ldGhvZDogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC52YWx1ZXMoY29tcHV0ZV9saW5lc18xLkRpZmZNZXRob2QpKSxcbiAgICByZW5kZXJDb250ZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZW5kZXJHdXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTGluZU51bWJlckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBleHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHN0eWxlczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBoaWRlTGluZU51bWJlcnM6IFByb3BUeXBlcy5ib29sLFxuICAgIHNob3dEaWZmT25seTogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGlnaGxpZ2h0TGluZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGxlZnRUaXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmVsZW1lbnRdKSxcbiAgICByaWdodFRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICAgIGxpbmVzT2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IERpZmZWaWV3ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/styles.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/styles.js ***!
  \******************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst css_1 = __webpack_require__(/*! @emotion/css */ \"(ssr)/../node_modules/.pnpm/@emotion+css@11.13.5/node_modules/@emotion/css/dist/emotion-css.development.esm.js\");\n// eslint-disable-next-line import/no-anonymous-default-export\nexports[\"default\"] = (styleOverride, useDarkTheme = false) => {\n    const { variables: overrideVariables = {} } = styleOverride, styles = __rest(styleOverride, [\"variables\"]);\n    const themeVariables = {\n        light: Object.assign({\n            diffViewerBackground: '#fff',\n            diffViewerColor: '#212529',\n            addedBackground: '#e6ffed',\n            addedColor: '#24292e',\n            removedBackground: '#ffeef0',\n            removedColor: '#24292e',\n            changedBackground: '#fffbdd',\n            wordAddedBackground: '#acf2bd',\n            wordRemovedBackground: '#fdb8c0',\n            addedGutterBackground: '#cdffd8',\n            removedGutterBackground: '#ffdce0',\n            gutterBackground: '#f7f7f7',\n            gutterBackgroundDark: '#f3f1f1',\n            highlightBackground: '#fffbdd',\n            highlightGutterBackground: '#fff5b1',\n            codeFoldGutterBackground: '#dbedff',\n            codeFoldBackground: '#f1f8ff',\n            emptyLineBackground: '#fafbfc',\n            gutterColor: '#212529',\n            addedGutterColor: '#212529',\n            removedGutterColor: '#212529',\n            codeFoldContentColor: '#212529',\n            diffViewerTitleBackground: '#fafbfc',\n            diffViewerTitleColor: '#212529',\n            diffViewerTitleBorderColor: '#eee',\n        }, (overrideVariables.light || {})),\n        dark: Object.assign({\n            diffViewerBackground: '#2e303c',\n            diffViewerColor: '#FFF',\n            addedBackground: '#044B53',\n            addedColor: 'white',\n            removedBackground: '#632F34',\n            removedColor: 'white',\n            changedBackground: '#3e302c',\n            wordAddedBackground: '#055d67',\n            wordRemovedBackground: '#7d383f',\n            addedGutterBackground: '#034148',\n            removedGutterBackground: '#632b30',\n            gutterBackground: '#2c2f3a',\n            gutterBackgroundDark: '#262933',\n            highlightBackground: '#2a3967',\n            highlightGutterBackground: '#2d4077',\n            codeFoldGutterBackground: '#21232b',\n            codeFoldBackground: '#262831',\n            emptyLineBackground: '#363946',\n            gutterColor: '#666c87',\n            addedGutterColor: '#8c8c8c',\n            removedGutterColor: '#8c8c8c',\n            codeFoldContentColor: '#656a8b',\n            diffViewerTitleBackground: '#2f323e',\n            diffViewerTitleColor: '#555a7b',\n            diffViewerTitleBorderColor: '#353846',\n        }, (overrideVariables.dark || {})),\n    };\n    const variables = useDarkTheme ? themeVariables.dark : themeVariables.light;\n    const content = (0, css_1.css)({\n        width: '100%',\n        label: 'content',\n    });\n    const splitView = (0, css_1.css)({\n        [`.${content}`]: {\n            width: '50%',\n        },\n        label: 'split-view',\n    });\n    const diffContainer = (0, css_1.css)({\n        width: '100%',\n        background: variables.diffViewerBackground,\n        pre: {\n            margin: 0,\n            whiteSpace: 'pre-wrap',\n            lineHeight: '25px',\n        },\n        label: 'diff-container',\n        borderCollapse: 'collapse',\n    });\n    const codeFoldContent = (0, css_1.css)({\n        color: variables.codeFoldContentColor,\n        label: 'code-fold-content',\n    });\n    const contentText = (0, css_1.css)({\n        color: variables.diffViewerColor,\n        label: 'content-text',\n    });\n    const titleBlock = (0, css_1.css)({\n        background: variables.diffViewerTitleBackground,\n        padding: 10,\n        borderBottom: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        label: 'title-block',\n        ':last-child': {\n            borderLeft: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        },\n        [`.${contentText}`]: {\n            color: variables.diffViewerTitleColor,\n        },\n    });\n    const lineNumber = (0, css_1.css)({\n        color: variables.gutterColor,\n        label: 'line-number',\n    });\n    const diffRemoved = (0, css_1.css)({\n        background: variables.removedBackground,\n        color: variables.removedColor,\n        pre: {\n            color: variables.removedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.removedGutterColor,\n        },\n        label: 'diff-removed',\n    });\n    const diffAdded = (0, css_1.css)({\n        background: variables.addedBackground,\n        color: variables.addedColor,\n        pre: {\n            color: variables.addedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.addedGutterColor,\n        },\n        label: 'diff-added',\n    });\n    const diffChanged = (0, css_1.css)({\n        background: variables.changedBackground,\n        [`.${lineNumber}`]: {\n            color: variables.gutterColor,\n        },\n        label: 'diff-changed',\n    });\n    const wordDiff = (0, css_1.css)({\n        padding: 2,\n        display: 'inline-flex',\n        borderRadius: 4,\n        wordBreak: 'break-all',\n        label: 'word-diff',\n    });\n    const wordAdded = (0, css_1.css)({\n        background: variables.wordAddedBackground,\n        label: 'word-added',\n    });\n    const wordRemoved = (0, css_1.css)({\n        background: variables.wordRemovedBackground,\n        label: 'word-removed',\n    });\n    const codeFoldGutter = (0, css_1.css)({\n        backgroundColor: variables.codeFoldGutterBackground,\n        label: 'code-fold-gutter',\n    });\n    const codeFold = (0, css_1.css)({\n        backgroundColor: variables.codeFoldBackground,\n        height: 40,\n        fontSize: 14,\n        fontWeight: 700,\n        label: 'code-fold',\n        a: {\n            textDecoration: 'underline !important',\n            cursor: 'pointer',\n            pre: {\n                display: 'inline',\n            },\n        },\n    });\n    const emptyLine = (0, css_1.css)({\n        backgroundColor: variables.emptyLineBackground,\n        label: 'empty-line',\n    });\n    const marker = (0, css_1.css)({\n        width: 25,\n        paddingLeft: 10,\n        paddingRight: 10,\n        userSelect: 'none',\n        label: 'marker',\n        [`&.${diffAdded}`]: {\n            pre: {\n                color: variables.addedColor,\n            },\n        },\n        [`&.${diffRemoved}`]: {\n            pre: {\n                color: variables.removedColor,\n            },\n        },\n    });\n    const highlightedLine = (0, css_1.css)({\n        background: variables.highlightBackground,\n        label: 'highlighted-line',\n        [`.${wordAdded}, .${wordRemoved}`]: {\n            backgroundColor: 'initial',\n        },\n    });\n    const highlightedGutter = (0, css_1.css)({\n        label: 'highlighted-gutter',\n    });\n    const gutter = (0, css_1.css)({\n        userSelect: 'none',\n        minWidth: 50,\n        padding: '0 10px',\n        whiteSpace: 'nowrap',\n        label: 'gutter',\n        textAlign: 'right',\n        background: variables.gutterBackground,\n        '&:hover': {\n            cursor: 'pointer',\n            background: variables.gutterBackgroundDark,\n            pre: {\n                opacity: 1,\n            },\n        },\n        pre: {\n            opacity: 0.5,\n        },\n        [`&.${diffAdded}`]: {\n            background: variables.addedGutterBackground,\n        },\n        [`&.${diffRemoved}`]: {\n            background: variables.removedGutterBackground,\n        },\n        [`&.${highlightedGutter}`]: {\n            background: variables.highlightGutterBackground,\n            '&:hover': {\n                background: variables.highlightGutterBackground,\n            },\n        },\n    });\n    const emptyGutter = (0, css_1.css)({\n        '&:hover': {\n            background: variables.gutterBackground,\n            cursor: 'initial',\n        },\n        label: 'empty-gutter',\n    });\n    const line = (0, css_1.css)({\n        verticalAlign: 'baseline',\n        label: 'line',\n    });\n    const defaultStyles = {\n        diffContainer,\n        diffRemoved,\n        diffAdded,\n        diffChanged,\n        splitView,\n        marker,\n        highlightedGutter,\n        highlightedLine,\n        gutter,\n        line,\n        wordDiff,\n        wordAdded,\n        wordRemoved,\n        codeFoldGutter,\n        codeFold,\n        emptyGutter,\n        emptyLine,\n        lineNumber,\n        contentText,\n        content,\n        codeFoldContent,\n        titleBlock,\n    };\n    const computerOverrideStyles = Object.keys(styles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: (0, css_1.css)(styles[key]),\n    })), {});\n    return Object.keys(defaultStyles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: computerOverrideStyles[key]\n            ? (0, css_1.cx)(defaultStyles[key], computerOverrideStyles[key])\n            : defaultStyles[key],\n    })), {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxvSUFBYztBQUNwQztBQUNBLGtCQUFlO0FBQ2YsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUUsU0FBUztBQUNULGFBQWEsWUFBWTtBQUN6QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVLEtBQUssWUFBWTtBQUN4QztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjLFVBQVU7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsY0FBYyxZQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNULGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSxLQUFLLE1BQU07QUFDWCwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNO0FBQ1giLCJzb3VyY2VzIjpbIi9ob21lL3BhdWwvcHJvamVjdHMvcGF5bG9hZC9wbHVnaW4tZGV2ZWxvcG1lbnQvYmV0dGVyLWZpZWxkcy9naXRyb290L25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWRAMy4yLjZfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9zdHlsZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjc3NfMSA9IHJlcXVpcmUoXCJAZW1vdGlvbi9jc3NcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWFub255bW91cy1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0cy5kZWZhdWx0ID0gKHN0eWxlT3ZlcnJpZGUsIHVzZURhcmtUaGVtZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyB2YXJpYWJsZXM6IG92ZXJyaWRlVmFyaWFibGVzID0ge30gfSA9IHN0eWxlT3ZlcnJpZGUsIHN0eWxlcyA9IF9fcmVzdChzdHlsZU92ZXJyaWRlLCBbXCJ2YXJpYWJsZXNcIl0pO1xuICAgIGNvbnN0IHRoZW1lVmFyaWFibGVzID0ge1xuICAgICAgICBsaWdodDogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkaWZmVmlld2VyQmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICAgICAgZGlmZlZpZXdlckNvbG9yOiAnIzIxMjUyOScsXG4gICAgICAgICAgICBhZGRlZEJhY2tncm91bmQ6ICcjZTZmZmVkJyxcbiAgICAgICAgICAgIGFkZGVkQ29sb3I6ICcjMjQyOTJlJyxcbiAgICAgICAgICAgIHJlbW92ZWRCYWNrZ3JvdW5kOiAnI2ZmZWVmMCcsXG4gICAgICAgICAgICByZW1vdmVkQ29sb3I6ICcjMjQyOTJlJyxcbiAgICAgICAgICAgIGNoYW5nZWRCYWNrZ3JvdW5kOiAnI2ZmZmJkZCcsXG4gICAgICAgICAgICB3b3JkQWRkZWRCYWNrZ3JvdW5kOiAnI2FjZjJiZCcsXG4gICAgICAgICAgICB3b3JkUmVtb3ZlZEJhY2tncm91bmQ6ICcjZmRiOGMwJyxcbiAgICAgICAgICAgIGFkZGVkR3V0dGVyQmFja2dyb3VuZDogJyNjZGZmZDgnLFxuICAgICAgICAgICAgcmVtb3ZlZEd1dHRlckJhY2tncm91bmQ6ICcjZmZkY2UwJyxcbiAgICAgICAgICAgIGd1dHRlckJhY2tncm91bmQ6ICcjZjdmN2Y3JyxcbiAgICAgICAgICAgIGd1dHRlckJhY2tncm91bmREYXJrOiAnI2YzZjFmMScsXG4gICAgICAgICAgICBoaWdobGlnaHRCYWNrZ3JvdW5kOiAnI2ZmZmJkZCcsXG4gICAgICAgICAgICBoaWdobGlnaHRHdXR0ZXJCYWNrZ3JvdW5kOiAnI2ZmZjViMScsXG4gICAgICAgICAgICBjb2RlRm9sZEd1dHRlckJhY2tncm91bmQ6ICcjZGJlZGZmJyxcbiAgICAgICAgICAgIGNvZGVGb2xkQmFja2dyb3VuZDogJyNmMWY4ZmYnLFxuICAgICAgICAgICAgZW1wdHlMaW5lQmFja2dyb3VuZDogJyNmYWZiZmMnLFxuICAgICAgICAgICAgZ3V0dGVyQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGFkZGVkR3V0dGVyQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIHJlbW92ZWRHdXR0ZXJDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgY29kZUZvbGRDb250ZW50Q29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJUaXRsZUJhY2tncm91bmQ6ICcjZmFmYmZjJyxcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJUaXRsZUNvbG9yOiAnIzIxMjUyOScsXG4gICAgICAgICAgICBkaWZmVmlld2VyVGl0bGVCb3JkZXJDb2xvcjogJyNlZWUnLFxuICAgICAgICB9LCAob3ZlcnJpZGVWYXJpYWJsZXMubGlnaHQgfHwge30pKSxcbiAgICAgICAgZGFyazogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkaWZmVmlld2VyQmFja2dyb3VuZDogJyMyZTMwM2MnLFxuICAgICAgICAgICAgZGlmZlZpZXdlckNvbG9yOiAnI0ZGRicsXG4gICAgICAgICAgICBhZGRlZEJhY2tncm91bmQ6ICcjMDQ0QjUzJyxcbiAgICAgICAgICAgIGFkZGVkQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICByZW1vdmVkQmFja2dyb3VuZDogJyM2MzJGMzQnLFxuICAgICAgICAgICAgcmVtb3ZlZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgY2hhbmdlZEJhY2tncm91bmQ6ICcjM2UzMDJjJyxcbiAgICAgICAgICAgIHdvcmRBZGRlZEJhY2tncm91bmQ6ICcjMDU1ZDY3JyxcbiAgICAgICAgICAgIHdvcmRSZW1vdmVkQmFja2dyb3VuZDogJyM3ZDM4M2YnLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJCYWNrZ3JvdW5kOiAnIzAzNDE0OCcsXG4gICAgICAgICAgICByZW1vdmVkR3V0dGVyQmFja2dyb3VuZDogJyM2MzJiMzAnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZDogJyMyYzJmM2EnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZERhcms6ICcjMjYyOTMzJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEJhY2tncm91bmQ6ICcjMmEzOTY3JyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEd1dHRlckJhY2tncm91bmQ6ICcjMmQ0MDc3JyxcbiAgICAgICAgICAgIGNvZGVGb2xkR3V0dGVyQmFja2dyb3VuZDogJyMyMTIzMmInLFxuICAgICAgICAgICAgY29kZUZvbGRCYWNrZ3JvdW5kOiAnIzI2MjgzMScsXG4gICAgICAgICAgICBlbXB0eUxpbmVCYWNrZ3JvdW5kOiAnIzM2Mzk0NicsXG4gICAgICAgICAgICBndXR0ZXJDb2xvcjogJyM2NjZjODcnLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJDb2xvcjogJyM4YzhjOGMnLFxuICAgICAgICAgICAgcmVtb3ZlZEd1dHRlckNvbG9yOiAnIzhjOGM4YycsXG4gICAgICAgICAgICBjb2RlRm9sZENvbnRlbnRDb2xvcjogJyM2NTZhOGInLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQmFja2dyb3VuZDogJyMyZjMyM2UnLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQ29sb3I6ICcjNTU1YTdiJyxcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yOiAnIzM1Mzg0NicsXG4gICAgICAgIH0sIChvdmVycmlkZVZhcmlhYmxlcy5kYXJrIHx8IHt9KSksXG4gICAgfTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSB1c2VEYXJrVGhlbWUgPyB0aGVtZVZhcmlhYmxlcy5kYXJrIDogdGhlbWVWYXJpYWJsZXMubGlnaHQ7XG4gICAgY29uc3QgY29udGVudCA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbGFiZWw6ICdjb250ZW50JyxcbiAgICB9KTtcbiAgICBjb25zdCBzcGxpdFZpZXcgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIFtgLiR7Y29udGVudH1gXToge1xuICAgICAgICAgICAgd2lkdGg6ICc1MCUnLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ3NwbGl0LXZpZXcnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZDb250YWluZXIgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5kaWZmVmlld2VyQmFja2dyb3VuZCxcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgICAgICAgbGluZUhlaWdodDogJzI1cHgnLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ2RpZmYtY29udGFpbmVyJyxcbiAgICAgICAgYm9yZGVyQ29sbGFwc2U6ICdjb2xsYXBzZScsXG4gICAgfSk7XG4gICAgY29uc3QgY29kZUZvbGRDb250ZW50ID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBjb2xvcjogdmFyaWFibGVzLmNvZGVGb2xkQ29udGVudENvbG9yLFxuICAgICAgICBsYWJlbDogJ2NvZGUtZm9sZC1jb250ZW50JyxcbiAgICB9KTtcbiAgICBjb25zdCBjb250ZW50VGV4dCA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5kaWZmVmlld2VyQ29sb3IsXG4gICAgICAgIGxhYmVsOiAnY29udGVudC10ZXh0JyxcbiAgICB9KTtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuZGlmZlZpZXdlclRpdGxlQmFja2dyb3VuZCxcbiAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgIGJvcmRlckJvdHRvbTogYDFweCBzb2xpZCAke3ZhcmlhYmxlcy5kaWZmVmlld2VyVGl0bGVCb3JkZXJDb2xvcn1gLFxuICAgICAgICBsYWJlbDogJ3RpdGxlLWJsb2NrJyxcbiAgICAgICAgJzpsYXN0LWNoaWxkJzoge1xuICAgICAgICAgICAgYm9yZGVyTGVmdDogYDFweCBzb2xpZCAke3ZhcmlhYmxlcy5kaWZmVmlld2VyVGl0bGVCb3JkZXJDb2xvcn1gLFxuICAgICAgICB9LFxuICAgICAgICBbYC4ke2NvbnRlbnRUZXh0fWBdOiB7XG4gICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLmRpZmZWaWV3ZXJUaXRsZUNvbG9yLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmVOdW1iZXIgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZ3V0dGVyQ29sb3IsXG4gICAgICAgIGxhYmVsOiAnbGluZS1udW1iZXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZSZW1vdmVkID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMucmVtb3ZlZEJhY2tncm91bmQsXG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMucmVtb3ZlZENvbG9yLFxuICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMucmVtb3ZlZENvbG9yLFxuICAgICAgICB9LFxuICAgICAgICBbYC4ke2xpbmVOdW1iZXJ9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMucmVtb3ZlZEd1dHRlckNvbG9yLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ2RpZmYtcmVtb3ZlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgZGlmZkFkZGVkID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuYWRkZWRCYWNrZ3JvdW5kLFxuICAgICAgICBjb2xvcjogdmFyaWFibGVzLmFkZGVkQ29sb3IsXG4gICAgICAgIHByZToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5hZGRlZENvbG9yLFxuICAgICAgICB9LFxuICAgICAgICBbYC4ke2xpbmVOdW1iZXJ9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuYWRkZWRHdXR0ZXJDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICdkaWZmLWFkZGVkJyxcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmQ2hhbmdlZCA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmNoYW5nZWRCYWNrZ3JvdW5kLFxuICAgICAgICBbYC4ke2xpbmVOdW1iZXJ9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZ3V0dGVyQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZGlmZi1jaGFuZ2VkJyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JkRGlmZiA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgcGFkZGluZzogMixcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgICAgICB3b3JkQnJlYWs6ICdicmVhay1hbGwnLFxuICAgICAgICBsYWJlbDogJ3dvcmQtZGlmZicsXG4gICAgfSk7XG4gICAgY29uc3Qgd29yZEFkZGVkID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMud29yZEFkZGVkQmFja2dyb3VuZCxcbiAgICAgICAgbGFiZWw6ICd3b3JkLWFkZGVkJyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JkUmVtb3ZlZCA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLndvcmRSZW1vdmVkQmFja2dyb3VuZCxcbiAgICAgICAgbGFiZWw6ICd3b3JkLXJlbW92ZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvZGVGb2xkR3V0dGVyID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHZhcmlhYmxlcy5jb2RlRm9sZEd1dHRlckJhY2tncm91bmQsXG4gICAgICAgIGxhYmVsOiAnY29kZS1mb2xkLWd1dHRlcicsXG4gICAgfSk7XG4gICAgY29uc3QgY29kZUZvbGQgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFyaWFibGVzLmNvZGVGb2xkQmFja2dyb3VuZCxcbiAgICAgICAgaGVpZ2h0OiA0MCxcbiAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICBmb250V2VpZ2h0OiA3MDAsXG4gICAgICAgIGxhYmVsOiAnY29kZS1mb2xkJyxcbiAgICAgICAgYToge1xuICAgICAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUgIWltcG9ydGFudCcsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIHByZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBlbXB0eUxpbmUgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFyaWFibGVzLmVtcHR5TGluZUJhY2tncm91bmQsXG4gICAgICAgIGxhYmVsOiAnZW1wdHktbGluZScsXG4gICAgfSk7XG4gICAgY29uc3QgbWFya2VyID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICB3aWR0aDogMjUsXG4gICAgICAgIHBhZGRpbmdMZWZ0OiAxMCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiAxMCxcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICBsYWJlbDogJ21hcmtlcicsXG4gICAgICAgIFtgJi4ke2RpZmZBZGRlZH1gXToge1xuICAgICAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5hZGRlZENvbG9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2AmLiR7ZGlmZlJlbW92ZWR9YF06IHtcbiAgICAgICAgICAgIHByZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMucmVtb3ZlZENvbG9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBoaWdobGlnaHRlZExpbmUgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5oaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgICAgICBsYWJlbDogJ2hpZ2hsaWdodGVkLWxpbmUnLFxuICAgICAgICBbYC4ke3dvcmRBZGRlZH0sIC4ke3dvcmRSZW1vdmVkfWBdOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdpbml0aWFsJyxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBoaWdobGlnaHRlZEd1dHRlciA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgbGFiZWw6ICdoaWdobGlnaHRlZC1ndXR0ZXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGd1dHRlciA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICBtaW5XaWR0aDogNTAsXG4gICAgICAgIHBhZGRpbmc6ICcwIDEwcHgnLFxuICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgbGFiZWw6ICdndXR0ZXInLFxuICAgICAgICB0ZXh0QWxpZ246ICdyaWdodCcsXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5ndXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmd1dHRlckJhY2tncm91bmREYXJrLFxuICAgICAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByZToge1xuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtkaWZmQWRkZWR9YF06IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5hZGRlZEd1dHRlckJhY2tncm91bmQsXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2RpZmZSZW1vdmVkfWBdOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMucmVtb3ZlZEd1dHRlckJhY2tncm91bmQsXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2hpZ2hsaWdodGVkR3V0dGVyfWBdOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuaGlnaGxpZ2h0R3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5oaWdobGlnaHRHdXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBlbXB0eUd1dHRlciA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuZ3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgICAgIGN1cnNvcjogJ2luaXRpYWwnLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ2VtcHR5LWd1dHRlcicsXG4gICAgfSk7XG4gICAgY29uc3QgbGluZSA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJyxcbiAgICAgICAgbGFiZWw6ICdsaW5lJyxcbiAgICB9KTtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGVzID0ge1xuICAgICAgICBkaWZmQ29udGFpbmVyLFxuICAgICAgICBkaWZmUmVtb3ZlZCxcbiAgICAgICAgZGlmZkFkZGVkLFxuICAgICAgICBkaWZmQ2hhbmdlZCxcbiAgICAgICAgc3BsaXRWaWV3LFxuICAgICAgICBtYXJrZXIsXG4gICAgICAgIGhpZ2hsaWdodGVkR3V0dGVyLFxuICAgICAgICBoaWdobGlnaHRlZExpbmUsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgbGluZSxcbiAgICAgICAgd29yZERpZmYsXG4gICAgICAgIHdvcmRBZGRlZCxcbiAgICAgICAgd29yZFJlbW92ZWQsXG4gICAgICAgIGNvZGVGb2xkR3V0dGVyLFxuICAgICAgICBjb2RlRm9sZCxcbiAgICAgICAgZW1wdHlHdXR0ZXIsXG4gICAgICAgIGVtcHR5TGluZSxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgY29udGVudFRleHQsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNvZGVGb2xkQ29udGVudCxcbiAgICAgICAgdGl0bGVCbG9jayxcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVyT3ZlcnJpZGVTdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHtcbiAgICAgICAgW2tleV06ICgwLCBjc3NfMS5jc3MpKHN0eWxlc1trZXldKSxcbiAgICB9KSksIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGVmYXVsdFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwge1xuICAgICAgICBba2V5XTogY29tcHV0ZXJPdmVycmlkZVN0eWxlc1trZXldXG4gICAgICAgICAgICA/ICgwLCBjc3NfMS5jeCkoZGVmYXVsdFN0eWxlc1trZXldLCBjb21wdXRlck92ZXJyaWRlU3R5bGVzW2tleV0pXG4gICAgICAgICAgICA6IGRlZmF1bHRTdHlsZXNba2V5XSxcbiAgICB9KSksIHt9KTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/react-diff-viewer-continued/lib/styles.js\n");

/***/ })

};
;